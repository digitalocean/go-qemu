
##QEMU SPECIFICATION VERSION:  2.11.2


# Whitelists to permit QAPI rule violations; think twice before you
# add to them!
{
  "pragma": {
    "returns-whitelist": [
      "human-monitor-command",
      "qom-get",
      "query-migrate-cache-size",
      "query-tpm-models",
      "query-tpm-types",
      "ringbuf-read"
    ],
    "name-case-whitelist": [
      "ACPISlotType",
      "CpuInfoMIPS",
      "CpuInfoTricore",
      "QapiErrorClass",
      "UuidInfo",
      "X86CPURegister32",
      "q_obj_CpuInfo-base"
    ]
  }
}

##
# @QapiErrorClass:
#
# QEMU error classes
#
# @GenericError: this is used for errors that don't require a specific error
#                class. This should be the default case for most errors
#
# @CommandNotFound: the requested command has not been found
#
# @DeviceNotActive: a device has failed to be become active
#
# @DeviceNotFound: the requested device has not been found
#
# @KVMMissingCap: the requested operation can't be fulfilled because a
#                 required KVM capability is missing
#
# Since: 1.2
##
{
  "enum": "QapiErrorClass",
  "data": [
    "GenericError",
    "CommandNotFound",
    "DeviceNotActive",
    "DeviceNotFound",
    "KVMMissingCap"
  ]
}

##
# @IoOperationType:
#
# An enumeration of the I/O operation types
#
# @read: read operation
#
# @write: write operation
#
# Since: 2.1
##
{
  "enum": "IoOperationType",
  "data": [
    "read",
    "write"
  ]
}

##
# @OnOffAuto:
#
# An enumeration of three options: on, off, and auto
#
# @auto: QEMU selects the value between on and off
#
# @on: Enabled
#
# @off: Disabled
#
# Since: 2.2
##
{
  "enum": "OnOffAuto",
  "data": [
    "auto",
    "on",
    "off"
  ]
}

##
# @OnOffSplit:
#
# An enumeration of three values: on, off, and split
#
# @on: Enabled
#
# @off: Disabled
#
# @split: Mixed
#
# Since: 2.6
##
{
  "enum": "OnOffSplit",
  "data": [
    "on",
    "off",
    "split"
  ]
}

##
# @String:
#
# A fat type wrapping 'str', to be embedded in lists.
#
# Since: 1.2
##
{
  "struct": "String",
  "data": {
    "str": "str"
  }
}

##
# @StrOrNull:
#
# This is a string value or the explicit lack of a string (null
# pointer in C).  Intended for cases when 'optional absent' already
# has a different meaning.
#
# @s: the string value
# @n: no string value
#
# Since: 2.10
##
{
  "alternate": "StrOrNull",
  "data": {
    "s": "str",
    "n": "null"
  }
}


##
# @QapiErrorClass:
#
# QEMU error classes
#
# @GenericError: this is used for errors that don't require a specific error
#                class. This should be the default case for most errors
#
# @CommandNotFound: the requested command has not been found
#
# @DeviceNotActive: a device has failed to be become active
#
# @DeviceNotFound: the requested device has not been found
#
# @KVMMissingCap: the requested operation can't be fulfilled because a
#                 required KVM capability is missing
#
# Since: 1.2
##
{
  "enum": "QapiErrorClass",
  "data": [
    "GenericError",
    "CommandNotFound",
    "DeviceNotActive",
    "DeviceNotFound",
    "KVMMissingCap"
  ]
}

##
# @IoOperationType:
#
# An enumeration of the I/O operation types
#
# @read: read operation
#
# @write: write operation
#
# Since: 2.1
##
{
  "enum": "IoOperationType",
  "data": [
    "read",
    "write"
  ]
}

##
# @OnOffAuto:
#
# An enumeration of three options: on, off, and auto
#
# @auto: QEMU selects the value between on and off
#
# @on: Enabled
#
# @off: Disabled
#
# Since: 2.2
##
{
  "enum": "OnOffAuto",
  "data": [
    "auto",
    "on",
    "off"
  ]
}

##
# @OnOffSplit:
#
# An enumeration of three values: on, off, and split
#
# @on: Enabled
#
# @off: Disabled
#
# @split: Mixed
#
# Since: 2.6
##
{
  "enum": "OnOffSplit",
  "data": [
    "on",
    "off",
    "split"
  ]
}

##
# @String:
#
# A fat type wrapping 'str', to be embedded in lists.
#
# Since: 1.2
##
{
  "struct": "String",
  "data": {
    "str": "str"
  }
}

##
# @StrOrNull:
#
# This is a string value or the explicit lack of a string (null
# pointer in C).  Intended for cases when 'optional absent' already
# has a different meaning.
#
# @s: the string value
# @n: no string value
#
# Since: 2.10
##
{
  "alternate": "StrOrNull",
  "data": {
    "s": "str",
    "n": "null"
  }
}


##
# @NetworkAddressFamily:
#
# The network address family
#
# @ipv4: IPV4 family
#
# @ipv6: IPV6 family
#
# @unix: unix socket
#
# @vsock: vsock family (since 2.8)
#
# @unknown: otherwise
#
# Since: 2.1
##
{
  "enum": "NetworkAddressFamily",
  "data": [
    "ipv4",
    "ipv6",
    "unix",
    "vsock",
    "unknown"
  ]
}

##
# @InetSocketAddressBase:
#
# @host: host part of the address
# @port: port part of the address
##
{
  "struct": "InetSocketAddressBase",
  "data": {
    "host": "str",
    "port": "str"
  }
}

##
# @InetSocketAddress:
#
# Captures a socket address or address range in the Internet namespace.
#
# @numeric: true if the host/port are guaranteed to be numeric,
#           false if name resolution should be attempted. Defaults to false.
#           (Since 2.9)
#
# @to: If present, this is range of possible addresses, with port
#      between @port and @to.
#
# @ipv4: whether to accept IPv4 addresses, default try both IPv4 and IPv6
#
# @ipv6: whether to accept IPv6 addresses, default try both IPv4 and IPv6
#
# Since: 1.3
##
{
  "struct": "InetSocketAddress",
  "base": "InetSocketAddressBase",
  "data": {
    "*numeric": "bool",
    "*to": "uint16",
    "*ipv4": "bool",
    "*ipv6": "bool"
  }
}

##
# @UnixSocketAddress:
#
# Captures a socket address in the local ("Unix socket") namespace.
#
# @path: filesystem path to use
#
# Since: 1.3
##
{
  "struct": "UnixSocketAddress",
  "data": {
    "path": "str"
  }
}

##
# @VsockSocketAddress:
#
# Captures a socket address in the vsock namespace.
#
# @cid: unique host identifier
# @port: port
#
# Note: string types are used to allow for possible future hostname or
# service resolution support.
#
# Since: 2.8
##
{
  "struct": "VsockSocketAddress",
  "data": {
    "cid": "str",
    "port": "str"
  }
}

#
# Since: 1.3
##
{
  "union": "SocketAddressLegacy",
  "data": {
    "inet": "InetSocketAddress",
    "unix": "UnixSocketAddress",
    "vsock": "VsockSocketAddress",
    "fd": "String"
  }
}

##
# @SocketAddressType:
#
# Available SocketAddress types
#
# @inet:  Internet address
#
# @unix:  Unix domain socket
#
# Since: 2.9
##
{
  "enum": "SocketAddressType",
  "data": [
    "inet",
    "unix",
    "vsock",
    "fd"
  ]
}

##
# @SocketAddress:
#
# Captures the address of a socket, which could also be a named file
# descriptor
#
# @type:       Transport type
#
# Since: 2.9
##
{
  "union": "SocketAddress",
  "base": {
    "type": "SocketAddressType"
  },
  "discriminator": "type",
  "data": {
    "inet": "InetSocketAddress",
    "unix": "UnixSocketAddress",
    "vsock": "VsockSocketAddress",
    "fd": "String"
  }
}


##
# @RunState:
#
# An enumeration of VM run states.
#
# @debug: QEMU is running on a debugger
#
# @finish-migrate: guest is paused to finish the migration process
#
# @inmigrate: guest is paused waiting for an incoming migration.  Note
# that this state does not tell whether the machine will start at the
# end of the migration.  This depends on the command-line -S option and
# any invocation of 'stop' or 'cont' that has happened since QEMU was
# started.
#
# @internal-error: An internal error that prevents further guest execution
# has occurred
#
# @io-error: the last IOP has failed and the device is configured to pause
# on I/O errors
#
# @paused: guest has been paused via the 'stop' command
#
# @postmigrate: guest is paused following a successful 'migrate'
#
# @prelaunch: QEMU was started with -S and guest has not started
#
# @restore-vm: guest is paused to restore VM state
#
# @running: guest is actively running
#
# @save-vm: guest is paused to save the VM state
#
# @shutdown: guest is shut down (and -no-shutdown is in use)
#
# @suspended: guest is suspended (ACPI S3)
#
# @watchdog: the watchdog action is configured to pause and has been triggered
#
# @guest-panicked: guest has been panicked as a result of guest OS panic
#
# @colo: guest is paused to save/restore VM state under colo checkpoint,
#        VM can not get into this state unless colo capability is enabled
#        for migration. (since 2.8)
##
{
  "enum": "RunState",
  "data": [
    "debug",
    "inmigrate",
    "internal-error",
    "io-error",
    "paused",
    "postmigrate",
    "prelaunch",
    "finish-migrate",
    "restore-vm",
    "running",
    "save-vm",
    "shutdown",
    "suspended",
    "watchdog",
    "guest-panicked",
    "colo"
  ]
}

##
# @StatusInfo:
#
# Information about VCPU run state
#
# @running: true if all VCPUs are runnable, false if not runnable
#
# @singlestep: true if VCPUs are in single-step mode
#
# @status: the virtual machine @RunState
#
# Since:  0.14.0
#
# Notes: @singlestep is enabled through the GDB stub
##
{
  "struct": "StatusInfo",
  "data": {
    "running": "bool",
    "singlestep": "bool",
    "status": "RunState"
  }
}

##
# @query-status:
#
# Query the run status of all VCPUs
#
# Returns: @StatusInfo reflecting all VCPUs
#
# Since:  0.14.0
#
# Example:
#
# -> { "execute": "query-status" }
# <- { "return": { "running": true,
#                  "singlestep": false,
#                  "status": "running" } }
#
##
{
  "command": "query-status",
  "returns": "StatusInfo"
}

##
# @SHUTDOWN:
#
# Emitted when the virtual machine has shut down, indicating that qemu is
# about to exit.
#
# @guest: If true, the shutdown was triggered by a guest request (such as
# a guest-initiated ACPI shutdown request or other hardware-specific action)
# rather than a host request (such as sending qemu a SIGINT). (since 2.10)
#
# Note: If the command-line option "-no-shutdown" has been specified, qemu will
# not exit, and a STOP event will eventually follow the SHUTDOWN event
#
# Since: 0.12.0
#
# Example:
#
# <- { "event": "SHUTDOWN", "data": { "guest": true },
#      "timestamp": { "seconds": 1267040730, "microseconds": 682951 } }
#
##
{
  "event": "SHUTDOWN",
  "data": {
    "guest": "bool"
  }
}

##
# @POWERDOWN:
#
# Emitted when the virtual machine is powered down through the power control
# system, such as via ACPI.
#
# Since: 0.12.0
#
# Example:
#
# <- { "event": "POWERDOWN",
#      "timestamp": { "seconds": 1267040730, "microseconds": 682951 } }
#
##
{
  "event": "POWERDOWN"
}

##
# @RESET:
#
# Emitted when the virtual machine is reset
#
# @guest: If true, the reset was triggered by a guest request (such as
# a guest-initiated ACPI reboot request or other hardware-specific action)
# rather than a host request (such as the QMP command system_reset).
# (since 2.10)
#
# Since: 0.12.0
#
# Example:
#
# <- { "event": "RESET", "data": { "guest": false },
#      "timestamp": { "seconds": 1267041653, "microseconds": 9518 } }
#
##
{
  "event": "RESET",
  "data": {
    "guest": "bool"
  }
}

##
# @STOP:
#
# Emitted when the virtual machine is stopped
#
# Since: 0.12.0
#
# Example:
#
# <- { "event": "STOP",
#      "timestamp": { "seconds": 1267041730, "microseconds": 281295 } }
#
##
{
  "event": "STOP"
}

##
# @RESUME:
#
# Emitted when the virtual machine resumes execution
#
# Since: 0.12.0
#
# Example:
#
# <- { "event": "RESUME",
#      "timestamp": { "seconds": 1271770767, "microseconds": 582542 } }
#
##
{
  "event": "RESUME"
}

##
# @SUSPEND:
#
# Emitted when guest enters a hardware suspension state, for example, S3 state,
# which is sometimes called standby state
#
# Since: 1.1
#
# Example:
#
# <- { "event": "SUSPEND",
#      "timestamp": { "seconds": 1344456160, "microseconds": 309119 } }
#
##
{
  "event": "SUSPEND"
}

##
# @SUSPEND_DISK:
#
# Emitted when guest enters a hardware suspension state with data saved on
# disk, for example, S4 state, which is sometimes called hibernate state
#
# Note: QEMU shuts down (similar to event @SHUTDOWN) when entering this state
#
# Since: 1.2
#
# Example:
#
# <-   { "event": "SUSPEND_DISK",
#        "timestamp": { "seconds": 1344456160, "microseconds": 309119 } }
#
##
{
  "event": "SUSPEND_DISK"
}

##
# @WAKEUP:
#
# Emitted when the guest has woken up from suspend state and is running
#
# Since: 1.1
#
# Example:
#
# <- { "event": "WAKEUP",
#      "timestamp": { "seconds": 1344522075, "microseconds": 745528 } }
#
##
{
  "event": "WAKEUP"
}

##
# @WATCHDOG:
#
# Emitted when the watchdog device's timer is expired
#
# @action: action that has been taken
#
# Note: If action is "reset", "shutdown", or "pause" the WATCHDOG event is
# followed respectively by the RESET, SHUTDOWN, or STOP events
#
# Note: This event is rate-limited.
#
# Since: 0.13.0
#
# Example:
#
# <- { "event": "WATCHDOG",
#      "data": { "action": "reset" },
#      "timestamp": { "seconds": 1267061043, "microseconds": 959568 } }
#
##
{
  "event": "WATCHDOG",
  "data": {
    "action": "WatchdogAction"
  }
}

##
# @WatchdogAction:
#
# An enumeration of the actions taken when the watchdog device's timer is
# expired
#
# @reset: system resets
#
# @shutdown: system shutdown, note that it is similar to @powerdown, which
#            tries to set to system status and notify guest
#
# @poweroff: system poweroff, the emulator program exits
#
# @pause: system pauses, similar to @stop
#
# @debug: system enters debug state
#
# @none: nothing is done
#
# @inject-nmi: a non-maskable interrupt is injected into the first VCPU (all
#              VCPUS on x86) (since 2.4)
#
# Since: 2.1
##
{
  "enum": "WatchdogAction",
  "data": [
    "reset",
    "shutdown",
    "poweroff",
    "pause",
    "debug",
    "none",
    "inject-nmi"
  ]
}

##
# @GUEST_PANICKED:
#
# Emitted when guest OS panic is detected
#
# @action: action that has been taken, currently always "pause"
#
# @info: information about a panic (since 2.9)
#
# Since: 1.5
#
# Example:
#
# <- { "event": "GUEST_PANICKED",
#      "data": { "action": "pause" } }
#
##
{
  "event": "GUEST_PANICKED",
  "data": {
    "action": "GuestPanicAction",
    "*info": "GuestPanicInformation"
  }
}

##
# @GuestPanicAction:
#
# An enumeration of the actions taken when guest OS panic is detected
#
# @pause: system pauses
#
# Since: 2.1 (poweroff since 2.8)
##
{
  "enum": "GuestPanicAction",
  "data": [
    "pause",
    "poweroff"
  ]
}

##
# @GuestPanicInformationType:
#
# An enumeration of the guest panic information types
#
# Since: 2.9
##
{
  "enum": "GuestPanicInformationType",
  "data": [
    "hyper-v"
  ]
}

##
# @GuestPanicInformation:
#
# Information about a guest panic
#
# Since: 2.9
##
{
  "union": "GuestPanicInformation",
  "base": {
    "type": "GuestPanicInformationType"
  },
  "discriminator": "type",
  "data": {
    "hyper-v": "GuestPanicInformationHyperV"
  }
}

##
# @GuestPanicInformationHyperV:
#
# Hyper-V specific guest panic information (HV crash MSRs)
#
# Since: 2.9
##
{
  "struct": "GuestPanicInformationHyperV",
  "data": {
    "arg1": "uint64",
    "arg2": "uint64",
    "arg3": "uint64",
    "arg4": "uint64",
    "arg5": "uint64"
  }
}


##
# @QCryptoTLSCredsEndpoint:
#
# The type of network endpoint that will be using the credentials.
# Most types of credential require different setup / structures
# depending on whether they will be used in a server versus a
# client.
#
# @client: the network endpoint is acting as the client
#
# @server: the network endpoint is acting as the server
#
# Since: 2.5
##
{
  "enum": "QCryptoTLSCredsEndpoint",
  "prefix": "QCRYPTO_TLS_CREDS_ENDPOINT",
  "data": [
    "client",
    "server"
  ]
}


##
# @QCryptoSecretFormat:
#
# The data format that the secret is provided in
#
# @raw: raw bytes. When encoded in JSON only valid UTF-8 sequences can be used
# @base64: arbitrary base64 encoded binary data
# Since: 2.6
##
{
  "enum": "QCryptoSecretFormat",
  "prefix": "QCRYPTO_SECRET_FORMAT",
  "data": [
    "raw",
    "base64"
  ]
}


##
# @QCryptoHashAlgorithm:
#
# The supported algorithms for computing content digests
#
# @md5: MD5. Should not be used in any new code, legacy compat only
# @sha1: SHA-1. Should not be used in any new code, legacy compat only
# @sha224: SHA-224. (since 2.7)
# @sha256: SHA-256. Current recommended strong hash.
# @sha384: SHA-384. (since 2.7)
# @sha512: SHA-512. (since 2.7)
# @ripemd160: RIPEMD-160. (since 2.7)
# Since: 2.6
##
{
  "enum": "QCryptoHashAlgorithm",
  "prefix": "QCRYPTO_HASH_ALG",
  "data": [
    "md5",
    "sha1",
    "sha224",
    "sha256",
    "sha384",
    "sha512",
    "ripemd160"
  ]
}


##
# @QCryptoCipherAlgorithm:
#
# The supported algorithms for content encryption ciphers
#
# @aes-128: AES with 128 bit / 16 byte keys
# @aes-192: AES with 192 bit / 24 byte keys
# @aes-256: AES with 256 bit / 32 byte keys
# @des-rfb: RFB specific variant of single DES. Do not use except in VNC.
# @3des: 3DES(EDE) with 192 bit / 24 byte keys (since 2.9)
# @cast5-128: Cast5 with 128 bit / 16 byte keys
# @serpent-128: Serpent with 128 bit / 16 byte keys
# @serpent-192: Serpent with 192 bit / 24 byte keys
# @serpent-256: Serpent with 256 bit / 32 byte keys
# @twofish-128: Twofish with 128 bit / 16 byte keys
# @twofish-192: Twofish with 192 bit / 24 byte keys
# @twofish-256: Twofish with 256 bit / 32 byte keys
# Since: 2.6
##
{
  "enum": "QCryptoCipherAlgorithm",
  "prefix": "QCRYPTO_CIPHER_ALG",
  "data": [
    "aes-128",
    "aes-192",
    "aes-256",
    "des-rfb",
    "3des",
    "cast5-128",
    "serpent-128",
    "serpent-192",
    "serpent-256",
    "twofish-128",
    "twofish-192",
    "twofish-256"
  ]
}


##
# @QCryptoCipherMode:
#
# The supported modes for content encryption ciphers
#
# @ecb: Electronic Code Book
# @cbc: Cipher Block Chaining
# @xts: XEX with tweaked code book and ciphertext stealing
# @ctr: Counter (Since 2.8)
# Since: 2.6
##
{
  "enum": "QCryptoCipherMode",
  "prefix": "QCRYPTO_CIPHER_MODE",
  "data": [
    "ecb",
    "cbc",
    "xts",
    "ctr"
  ]
}


##
# @QCryptoIVGenAlgorithm:
#
# The supported algorithms for generating initialization
# vectors for full disk encryption. The 'plain' generator
# should not be used for disks with sector numbers larger
# than 2^32, except where compatibility with pre-existing
# Linux dm-crypt volumes is required.
#
# @plain: 64-bit sector number truncated to 32-bits
# @plain64: 64-bit sector number
# @essiv: 64-bit sector number encrypted with a hash of the encryption key
# Since: 2.6
##
{
  "enum": "QCryptoIVGenAlgorithm",
  "prefix": "QCRYPTO_IVGEN_ALG",
  "data": [
    "plain",
    "plain64",
    "essiv"
  ]
}

##
# @QCryptoBlockFormat:
#
# The supported full disk encryption formats
#
# @qcow: QCow/QCow2 built-in AES-CBC encryption. Use only
#        for liberating data from old images.
# @luks: LUKS encryption format. Recommended for new images
#
# Since: 2.6
##
{
  "enum": "QCryptoBlockFormat",
  "data": [
    "qcow",
    "luks"
  ]
}

##
# @QCryptoBlockOptionsBase:
#
# The common options that apply to all full disk
# encryption formats
#
# @format: the encryption format
#
# Since: 2.6
##
{
  "struct": "QCryptoBlockOptionsBase",
  "data": {
    "format": "QCryptoBlockFormat"
  }
}

##
# @QCryptoBlockOptionsQCow:
#
# The options that apply to QCow/QCow2 AES-CBC encryption format
#
# @key-secret: the ID of a QCryptoSecret object providing the
#              decryption key. Mandatory except when probing image for
#              metadata only.
#
# Since: 2.6
##
{
  "struct": "QCryptoBlockOptionsQCow",
  "data": {
    "*key-secret": "str"
  }
}

##
# @QCryptoBlockOptionsLUKS:
#
# The options that apply to LUKS encryption format
#
# @key-secret: the ID of a QCryptoSecret object providing the
#              decryption key. Mandatory except when probing image for
#              metadata only.
# Since: 2.6
##
{
  "struct": "QCryptoBlockOptionsLUKS",
  "data": {
    "*key-secret": "str"
  }
}


##
# @QCryptoBlockCreateOptionsLUKS:
#
# The options that apply to LUKS encryption format initialization
#
# @cipher-alg: the cipher algorithm for data encryption
#              Currently defaults to 'aes'.
# @cipher-mode: the cipher mode for data encryption
#               Currently defaults to 'cbc'
# @ivgen-alg: the initialization vector generator
#             Currently defaults to 'essiv'
# @ivgen-hash-alg: the initialization vector generator hash
#                  Currently defaults to 'sha256'
# @hash-alg: the master key hash algorithm
#            Currently defaults to 'sha256'
# @iter-time: number of milliseconds to spend in
#             PBKDF passphrase processing. Currently defaults
#             to 2000. (since 2.8)
# Since: 2.6
##
{
  "struct": "QCryptoBlockCreateOptionsLUKS",
  "base": "QCryptoBlockOptionsLUKS",
  "data": {
    "*cipher-alg": "QCryptoCipherAlgorithm",
    "*cipher-mode": "QCryptoCipherMode",
    "*ivgen-alg": "QCryptoIVGenAlgorithm",
    "*ivgen-hash-alg": "QCryptoHashAlgorithm",
    "*hash-alg": "QCryptoHashAlgorithm",
    "*iter-time": "int"
  }
}


##
# @QCryptoBlockOpenOptions:
#
# The options that are available for all encryption formats
# when opening an existing volume
#
# Since: 2.6
##
{
  "union": "QCryptoBlockOpenOptions",
  "base": "QCryptoBlockOptionsBase",
  "discriminator": "format",
  "data": {
    "qcow": "QCryptoBlockOptionsQCow",
    "luks": "QCryptoBlockOptionsLUKS"
  }
}


##
# @QCryptoBlockCreateOptions:
#
# The options that are available for all encryption formats
# when initializing a new volume
#
# Since: 2.6
##
{
  "union": "QCryptoBlockCreateOptions",
  "base": "QCryptoBlockOptionsBase",
  "discriminator": "format",
  "data": {
    "qcow": "QCryptoBlockOptionsQCow",
    "luks": "QCryptoBlockCreateOptionsLUKS"
  }
}


##
# @QCryptoBlockInfoBase:
#
# The common information that applies to all full disk
# encryption formats
#
# @format: the encryption format
#
# Since: 2.7
##
{
  "struct": "QCryptoBlockInfoBase",
  "data": {
    "format": "QCryptoBlockFormat"
  }
}


##
# @QCryptoBlockInfoLUKSSlot:
#
# Information about the LUKS block encryption key
# slot options
#
# @active: whether the key slot is currently in use
# @key-offset: offset to the key material in bytes
# @iters: number of PBKDF2 iterations for key material
# @stripes: number of stripes for splitting key material
#
# Since: 2.7
##
{
  "struct": "QCryptoBlockInfoLUKSSlot",
  "data": {
    "active": "bool",
    "*iters": "int",
    "*stripes": "int",
    "key-offset": "int"
  }
}


##
# @QCryptoBlockInfoLUKS:
#
# Information about the LUKS block encryption options
#
# @cipher-alg: the cipher algorithm for data encryption
# @cipher-mode: the cipher mode for data encryption
# @ivgen-alg: the initialization vector generator
# @ivgen-hash-alg: the initialization vector generator hash
# @hash-alg: the master key hash algorithm
# @payload-offset: offset to the payload data in bytes
# @master-key-iters: number of PBKDF2 iterations for key material
# @uuid: unique identifier for the volume
# @slots: information about each key slot
#
# Since: 2.7
##
{
  "struct": "QCryptoBlockInfoLUKS",
  "data": {
    "cipher-alg": "QCryptoCipherAlgorithm",
    "cipher-mode": "QCryptoCipherMode",
    "ivgen-alg": "QCryptoIVGenAlgorithm",
    "*ivgen-hash-alg": "QCryptoHashAlgorithm",
    "hash-alg": "QCryptoHashAlgorithm",
    "payload-offset": "int",
    "master-key-iters": "int",
    "uuid": "str",
    "slots": [
      "QCryptoBlockInfoLUKSSlot"
    ]
  }
}

##
# @QCryptoBlockInfoQCow:
#
# Information about the QCow block encryption options
#
# Since: 2.7
##
{
  "struct": "QCryptoBlockInfoQCow",
  "data": {}
}


##
# @QCryptoBlockInfo:
#
# Information about the block encryption options
#
# Since: 2.7
##
{
  "union": "QCryptoBlockInfo",
  "base": "QCryptoBlockInfoBase",
  "discriminator": "format",
  "data": {
    "qcow": "QCryptoBlockInfoQCow",
    "luks": "QCryptoBlockInfoLUKS"
  }
}


##
# @QapiErrorClass:
#
# QEMU error classes
#
# @GenericError: this is used for errors that don't require a specific error
#                class. This should be the default case for most errors
#
# @CommandNotFound: the requested command has not been found
#
# @DeviceNotActive: a device has failed to be become active
#
# @DeviceNotFound: the requested device has not been found
#
# @KVMMissingCap: the requested operation can't be fulfilled because a
#                 required KVM capability is missing
#
# Since: 1.2
##
{
  "enum": "QapiErrorClass",
  "data": [
    "GenericError",
    "CommandNotFound",
    "DeviceNotActive",
    "DeviceNotFound",
    "KVMMissingCap"
  ]
}

##
# @IoOperationType:
#
# An enumeration of the I/O operation types
#
# @read: read operation
#
# @write: write operation
#
# Since: 2.1
##
{
  "enum": "IoOperationType",
  "data": [
    "read",
    "write"
  ]
}

##
# @OnOffAuto:
#
# An enumeration of three options: on, off, and auto
#
# @auto: QEMU selects the value between on and off
#
# @on: Enabled
#
# @off: Disabled
#
# Since: 2.2
##
{
  "enum": "OnOffAuto",
  "data": [
    "auto",
    "on",
    "off"
  ]
}

##
# @OnOffSplit:
#
# An enumeration of three values: on, off, and split
#
# @on: Enabled
#
# @off: Disabled
#
# @split: Mixed
#
# Since: 2.6
##
{
  "enum": "OnOffSplit",
  "data": [
    "on",
    "off",
    "split"
  ]
}

##
# @String:
#
# A fat type wrapping 'str', to be embedded in lists.
#
# Since: 1.2
##
{
  "struct": "String",
  "data": {
    "str": "str"
  }
}

##
# @StrOrNull:
#
# This is a string value or the explicit lack of a string (null
# pointer in C).  Intended for cases when 'optional absent' already
# has a different meaning.
#
# @s: the string value
# @n: no string value
#
# Since: 2.10
##
{
  "alternate": "StrOrNull",
  "data": {
    "s": "str",
    "n": "null"
  }
}


##
# @QCryptoTLSCredsEndpoint:
#
# The type of network endpoint that will be using the credentials.
# Most types of credential require different setup / structures
# depending on whether they will be used in a server versus a
# client.
#
# @client: the network endpoint is acting as the client
#
# @server: the network endpoint is acting as the server
#
# Since: 2.5
##
{
  "enum": "QCryptoTLSCredsEndpoint",
  "prefix": "QCRYPTO_TLS_CREDS_ENDPOINT",
  "data": [
    "client",
    "server"
  ]
}


##
# @QCryptoSecretFormat:
#
# The data format that the secret is provided in
#
# @raw: raw bytes. When encoded in JSON only valid UTF-8 sequences can be used
# @base64: arbitrary base64 encoded binary data
# Since: 2.6
##
{
  "enum": "QCryptoSecretFormat",
  "prefix": "QCRYPTO_SECRET_FORMAT",
  "data": [
    "raw",
    "base64"
  ]
}


##
# @QCryptoHashAlgorithm:
#
# The supported algorithms for computing content digests
#
# @md5: MD5. Should not be used in any new code, legacy compat only
# @sha1: SHA-1. Should not be used in any new code, legacy compat only
# @sha224: SHA-224. (since 2.7)
# @sha256: SHA-256. Current recommended strong hash.
# @sha384: SHA-384. (since 2.7)
# @sha512: SHA-512. (since 2.7)
# @ripemd160: RIPEMD-160. (since 2.7)
# Since: 2.6
##
{
  "enum": "QCryptoHashAlgorithm",
  "prefix": "QCRYPTO_HASH_ALG",
  "data": [
    "md5",
    "sha1",
    "sha224",
    "sha256",
    "sha384",
    "sha512",
    "ripemd160"
  ]
}


##
# @QCryptoCipherAlgorithm:
#
# The supported algorithms for content encryption ciphers
#
# @aes-128: AES with 128 bit / 16 byte keys
# @aes-192: AES with 192 bit / 24 byte keys
# @aes-256: AES with 256 bit / 32 byte keys
# @des-rfb: RFB specific variant of single DES. Do not use except in VNC.
# @3des: 3DES(EDE) with 192 bit / 24 byte keys (since 2.9)
# @cast5-128: Cast5 with 128 bit / 16 byte keys
# @serpent-128: Serpent with 128 bit / 16 byte keys
# @serpent-192: Serpent with 192 bit / 24 byte keys
# @serpent-256: Serpent with 256 bit / 32 byte keys
# @twofish-128: Twofish with 128 bit / 16 byte keys
# @twofish-192: Twofish with 192 bit / 24 byte keys
# @twofish-256: Twofish with 256 bit / 32 byte keys
# Since: 2.6
##
{
  "enum": "QCryptoCipherAlgorithm",
  "prefix": "QCRYPTO_CIPHER_ALG",
  "data": [
    "aes-128",
    "aes-192",
    "aes-256",
    "des-rfb",
    "3des",
    "cast5-128",
    "serpent-128",
    "serpent-192",
    "serpent-256",
    "twofish-128",
    "twofish-192",
    "twofish-256"
  ]
}


##
# @QCryptoCipherMode:
#
# The supported modes for content encryption ciphers
#
# @ecb: Electronic Code Book
# @cbc: Cipher Block Chaining
# @xts: XEX with tweaked code book and ciphertext stealing
# @ctr: Counter (Since 2.8)
# Since: 2.6
##
{
  "enum": "QCryptoCipherMode",
  "prefix": "QCRYPTO_CIPHER_MODE",
  "data": [
    "ecb",
    "cbc",
    "xts",
    "ctr"
  ]
}


##
# @QCryptoIVGenAlgorithm:
#
# The supported algorithms for generating initialization
# vectors for full disk encryption. The 'plain' generator
# should not be used for disks with sector numbers larger
# than 2^32, except where compatibility with pre-existing
# Linux dm-crypt volumes is required.
#
# @plain: 64-bit sector number truncated to 32-bits
# @plain64: 64-bit sector number
# @essiv: 64-bit sector number encrypted with a hash of the encryption key
# Since: 2.6
##
{
  "enum": "QCryptoIVGenAlgorithm",
  "prefix": "QCRYPTO_IVGEN_ALG",
  "data": [
    "plain",
    "plain64",
    "essiv"
  ]
}

##
# @QCryptoBlockFormat:
#
# The supported full disk encryption formats
#
# @qcow: QCow/QCow2 built-in AES-CBC encryption. Use only
#        for liberating data from old images.
# @luks: LUKS encryption format. Recommended for new images
#
# Since: 2.6
##
{
  "enum": "QCryptoBlockFormat",
  "data": [
    "qcow",
    "luks"
  ]
}

##
# @QCryptoBlockOptionsBase:
#
# The common options that apply to all full disk
# encryption formats
#
# @format: the encryption format
#
# Since: 2.6
##
{
  "struct": "QCryptoBlockOptionsBase",
  "data": {
    "format": "QCryptoBlockFormat"
  }
}

##
# @QCryptoBlockOptionsQCow:
#
# The options that apply to QCow/QCow2 AES-CBC encryption format
#
# @key-secret: the ID of a QCryptoSecret object providing the
#              decryption key. Mandatory except when probing image for
#              metadata only.
#
# Since: 2.6
##
{
  "struct": "QCryptoBlockOptionsQCow",
  "data": {
    "*key-secret": "str"
  }
}

##
# @QCryptoBlockOptionsLUKS:
#
# The options that apply to LUKS encryption format
#
# @key-secret: the ID of a QCryptoSecret object providing the
#              decryption key. Mandatory except when probing image for
#              metadata only.
# Since: 2.6
##
{
  "struct": "QCryptoBlockOptionsLUKS",
  "data": {
    "*key-secret": "str"
  }
}


##
# @QCryptoBlockCreateOptionsLUKS:
#
# The options that apply to LUKS encryption format initialization
#
# @cipher-alg: the cipher algorithm for data encryption
#              Currently defaults to 'aes'.
# @cipher-mode: the cipher mode for data encryption
#               Currently defaults to 'cbc'
# @ivgen-alg: the initialization vector generator
#             Currently defaults to 'essiv'
# @ivgen-hash-alg: the initialization vector generator hash
#                  Currently defaults to 'sha256'
# @hash-alg: the master key hash algorithm
#            Currently defaults to 'sha256'
# @iter-time: number of milliseconds to spend in
#             PBKDF passphrase processing. Currently defaults
#             to 2000. (since 2.8)
# Since: 2.6
##
{
  "struct": "QCryptoBlockCreateOptionsLUKS",
  "base": "QCryptoBlockOptionsLUKS",
  "data": {
    "*cipher-alg": "QCryptoCipherAlgorithm",
    "*cipher-mode": "QCryptoCipherMode",
    "*ivgen-alg": "QCryptoIVGenAlgorithm",
    "*ivgen-hash-alg": "QCryptoHashAlgorithm",
    "*hash-alg": "QCryptoHashAlgorithm",
    "*iter-time": "int"
  }
}


##
# @QCryptoBlockOpenOptions:
#
# The options that are available for all encryption formats
# when opening an existing volume
#
# Since: 2.6
##
{
  "union": "QCryptoBlockOpenOptions",
  "base": "QCryptoBlockOptionsBase",
  "discriminator": "format",
  "data": {
    "qcow": "QCryptoBlockOptionsQCow",
    "luks": "QCryptoBlockOptionsLUKS"
  }
}


##
# @QCryptoBlockCreateOptions:
#
# The options that are available for all encryption formats
# when initializing a new volume
#
# Since: 2.6
##
{
  "union": "QCryptoBlockCreateOptions",
  "base": "QCryptoBlockOptionsBase",
  "discriminator": "format",
  "data": {
    "qcow": "QCryptoBlockOptionsQCow",
    "luks": "QCryptoBlockCreateOptionsLUKS"
  }
}


##
# @QCryptoBlockInfoBase:
#
# The common information that applies to all full disk
# encryption formats
#
# @format: the encryption format
#
# Since: 2.7
##
{
  "struct": "QCryptoBlockInfoBase",
  "data": {
    "format": "QCryptoBlockFormat"
  }
}


##
# @QCryptoBlockInfoLUKSSlot:
#
# Information about the LUKS block encryption key
# slot options
#
# @active: whether the key slot is currently in use
# @key-offset: offset to the key material in bytes
# @iters: number of PBKDF2 iterations for key material
# @stripes: number of stripes for splitting key material
#
# Since: 2.7
##
{
  "struct": "QCryptoBlockInfoLUKSSlot",
  "data": {
    "active": "bool",
    "*iters": "int",
    "*stripes": "int",
    "key-offset": "int"
  }
}


##
# @QCryptoBlockInfoLUKS:
#
# Information about the LUKS block encryption options
#
# @cipher-alg: the cipher algorithm for data encryption
# @cipher-mode: the cipher mode for data encryption
# @ivgen-alg: the initialization vector generator
# @ivgen-hash-alg: the initialization vector generator hash
# @hash-alg: the master key hash algorithm
# @payload-offset: offset to the payload data in bytes
# @master-key-iters: number of PBKDF2 iterations for key material
# @uuid: unique identifier for the volume
# @slots: information about each key slot
#
# Since: 2.7
##
{
  "struct": "QCryptoBlockInfoLUKS",
  "data": {
    "cipher-alg": "QCryptoCipherAlgorithm",
    "cipher-mode": "QCryptoCipherMode",
    "ivgen-alg": "QCryptoIVGenAlgorithm",
    "*ivgen-hash-alg": "QCryptoHashAlgorithm",
    "hash-alg": "QCryptoHashAlgorithm",
    "payload-offset": "int",
    "master-key-iters": "int",
    "uuid": "str",
    "slots": [
      "QCryptoBlockInfoLUKSSlot"
    ]
  }
}

##
# @QCryptoBlockInfoQCow:
#
# Information about the QCow block encryption options
#
# Since: 2.7
##
{
  "struct": "QCryptoBlockInfoQCow",
  "data": {}
}


##
# @QCryptoBlockInfo:
#
# Information about the block encryption options
#
# Since: 2.7
##
{
  "union": "QCryptoBlockInfo",
  "base": "QCryptoBlockInfoBase",
  "discriminator": "format",
  "data": {
    "qcow": "QCryptoBlockInfoQCow",
    "luks": "QCryptoBlockInfoLUKS"
  }
}


##
# @QapiErrorClass:
#
# QEMU error classes
#
# @GenericError: this is used for errors that don't require a specific error
#                class. This should be the default case for most errors
#
# @CommandNotFound: the requested command has not been found
#
# @DeviceNotActive: a device has failed to be become active
#
# @DeviceNotFound: the requested device has not been found
#
# @KVMMissingCap: the requested operation can't be fulfilled because a
#                 required KVM capability is missing
#
# Since: 1.2
##
{
  "enum": "QapiErrorClass",
  "data": [
    "GenericError",
    "CommandNotFound",
    "DeviceNotActive",
    "DeviceNotFound",
    "KVMMissingCap"
  ]
}

##
# @IoOperationType:
#
# An enumeration of the I/O operation types
#
# @read: read operation
#
# @write: write operation
#
# Since: 2.1
##
{
  "enum": "IoOperationType",
  "data": [
    "read",
    "write"
  ]
}

##
# @OnOffAuto:
#
# An enumeration of three options: on, off, and auto
#
# @auto: QEMU selects the value between on and off
#
# @on: Enabled
#
# @off: Disabled
#
# Since: 2.2
##
{
  "enum": "OnOffAuto",
  "data": [
    "auto",
    "on",
    "off"
  ]
}

##
# @OnOffSplit:
#
# An enumeration of three values: on, off, and split
#
# @on: Enabled
#
# @off: Disabled
#
# @split: Mixed
#
# Since: 2.6
##
{
  "enum": "OnOffSplit",
  "data": [
    "on",
    "off",
    "split"
  ]
}

##
# @String:
#
# A fat type wrapping 'str', to be embedded in lists.
#
# Since: 1.2
##
{
  "struct": "String",
  "data": {
    "str": "str"
  }
}

##
# @StrOrNull:
#
# This is a string value or the explicit lack of a string (null
# pointer in C).  Intended for cases when 'optional absent' already
# has a different meaning.
#
# @s: the string value
# @n: no string value
#
# Since: 2.10
##
{
  "alternate": "StrOrNull",
  "data": {
    "s": "str",
    "n": "null"
  }
}


##
# @NetworkAddressFamily:
#
# The network address family
#
# @ipv4: IPV4 family
#
# @ipv6: IPV6 family
#
# @unix: unix socket
#
# @vsock: vsock family (since 2.8)
#
# @unknown: otherwise
#
# Since: 2.1
##
{
  "enum": "NetworkAddressFamily",
  "data": [
    "ipv4",
    "ipv6",
    "unix",
    "vsock",
    "unknown"
  ]
}

##
# @InetSocketAddressBase:
#
# @host: host part of the address
# @port: port part of the address
##
{
  "struct": "InetSocketAddressBase",
  "data": {
    "host": "str",
    "port": "str"
  }
}

##
# @InetSocketAddress:
#
# Captures a socket address or address range in the Internet namespace.
#
# @numeric: true if the host/port are guaranteed to be numeric,
#           false if name resolution should be attempted. Defaults to false.
#           (Since 2.9)
#
# @to: If present, this is range of possible addresses, with port
#      between @port and @to.
#
# @ipv4: whether to accept IPv4 addresses, default try both IPv4 and IPv6
#
# @ipv6: whether to accept IPv6 addresses, default try both IPv4 and IPv6
#
# Since: 1.3
##
{
  "struct": "InetSocketAddress",
  "base": "InetSocketAddressBase",
  "data": {
    "*numeric": "bool",
    "*to": "uint16",
    "*ipv4": "bool",
    "*ipv6": "bool"
  }
}

##
# @UnixSocketAddress:
#
# Captures a socket address in the local ("Unix socket") namespace.
#
# @path: filesystem path to use
#
# Since: 1.3
##
{
  "struct": "UnixSocketAddress",
  "data": {
    "path": "str"
  }
}

##
# @VsockSocketAddress:
#
# Captures a socket address in the vsock namespace.
#
# @cid: unique host identifier
# @port: port
#
# Note: string types are used to allow for possible future hostname or
# service resolution support.
#
# Since: 2.8
##
{
  "struct": "VsockSocketAddress",
  "data": {
    "cid": "str",
    "port": "str"
  }
}

#
# Since: 1.3
##
{
  "union": "SocketAddressLegacy",
  "data": {
    "inet": "InetSocketAddress",
    "unix": "UnixSocketAddress",
    "vsock": "VsockSocketAddress",
    "fd": "String"
  }
}

##
# @SocketAddressType:
#
# Available SocketAddress types
#
# @inet:  Internet address
#
# @unix:  Unix domain socket
#
# Since: 2.9
##
{
  "enum": "SocketAddressType",
  "data": [
    "inet",
    "unix",
    "vsock",
    "fd"
  ]
}

##
# @SocketAddress:
#
# Captures the address of a socket, which could also be a named file
# descriptor
#
# @type:       Transport type
#
# Since: 2.9
##
{
  "union": "SocketAddress",
  "base": {
    "type": "SocketAddressType"
  },
  "discriminator": "type",
  "data": {
    "inet": "InetSocketAddress",
    "unix": "UnixSocketAddress",
    "vsock": "VsockSocketAddress",
    "fd": "String"
  }
}


##
# @SnapshotInfo:
#
# @id: unique snapshot id
#
# @name: user chosen name
#
# @vm-state-size: size of the VM state
#
# @date-sec: UTC date of the snapshot in seconds
#
# @date-nsec: fractional part in nano seconds to be used with date-sec
#
# @vm-clock-sec: VM clock relative to boot in seconds
#
# @vm-clock-nsec: fractional part in nano seconds to be used with vm-clock-sec
#
# Since: 1.3
#
##
{
  "struct": "SnapshotInfo",
  "data": {
    "id": "str",
    "name": "str",
    "vm-state-size": "int",
    "date-sec": "int",
    "date-nsec": "int",
    "vm-clock-sec": "int",
    "vm-clock-nsec": "int"
  }
}

##
# @ImageInfoSpecificQCow2EncryptionBase:
#
# @format: The encryption format
#
# Since: 2.10
##
{
  "struct": "ImageInfoSpecificQCow2EncryptionBase",
  "data": {
    "format": "BlockdevQcow2EncryptionFormat"
  }
}

##
# @ImageInfoSpecificQCow2Encryption:
#
# Since: 2.10
##
{
  "union": "ImageInfoSpecificQCow2Encryption",
  "base": "ImageInfoSpecificQCow2EncryptionBase",
  "discriminator": "format",
  "data": {
    "aes": "QCryptoBlockInfoQCow",
    "luks": "QCryptoBlockInfoLUKS"
  }
}

##
# @ImageInfoSpecificQCow2:
#
# @compat: compatibility level
#
# @lazy-refcounts: on or off; only valid for compat >= 1.1
#
# @corrupt: true if the image has been marked corrupt; only valid for
#           compat >= 1.1 (since 2.2)
#
# @refcount-bits: width of a refcount entry in bits (since 2.3)
#
# @encrypt: details about encryption parameters; only set if image
#           is encrypted (since 2.10)
#
# Since: 1.7
##
{
  "struct": "ImageInfoSpecificQCow2",
  "data": {
    "compat": "str",
    "*lazy-refcounts": "bool",
    "*corrupt": "bool",
    "refcount-bits": "int",
    "*encrypt": "ImageInfoSpecificQCow2Encryption"
  }
}

##
# @ImageInfoSpecificVmdk:
#
# @create-type: The create type of VMDK image
#
# @cid: Content id of image
#
# @parent-cid: Parent VMDK image's cid
#
# @extents: List of extent files
#
# Since: 1.7
##
{
  "struct": "ImageInfoSpecificVmdk",
  "data": {
    "create-type": "str",
    "cid": "int",
    "parent-cid": "int",
    "extents": [
      "ImageInfo"
    ]
  }
}

##
# @ImageInfoSpecific:
#
# A discriminated record of image format specific information structures.
#
# Since: 1.7
##
{
  "union": "ImageInfoSpecific",
  "data": {
    "qcow2": "ImageInfoSpecificQCow2",
    "vmdk": "ImageInfoSpecificVmdk",
    "luks": "QCryptoBlockInfoLUKS"
  }
}

##
# @ImageInfo:
#
# Information about a QEMU image file
#
# @filename: name of the image file
#
# @format: format of the image file
#
# @virtual-size: maximum capacity in bytes of the image
#
# @actual-size: actual size on disk in bytes of the image
#
# @dirty-flag: true if image is not cleanly closed
#
# @cluster-size: size of a cluster in bytes
#
# @encrypted: true if the image is encrypted
#
# @compressed: true if the image is compressed (Since 1.7)
#
# @backing-filename: name of the backing file
#
# @full-backing-filename: full path of the backing file
#
# @backing-filename-format: the format of the backing file
#
# @snapshots: list of VM snapshots
#
# @backing-image: info of the backing image (since 1.6)
#
# @format-specific: structure supplying additional format-specific
# information (since 1.7)
#
# Since: 1.3
#
##
{
  "struct": "ImageInfo",
  "data": {
    "filename": "str",
    "format": "str",
    "*dirty-flag": "bool",
    "*actual-size": "int",
    "virtual-size": "int",
    "*cluster-size": "int",
    "*encrypted": "bool",
    "*compressed": "bool",
    "*backing-filename": "str",
    "*full-backing-filename": "str",
    "*backing-filename-format": "str",
    "*snapshots": [
      "SnapshotInfo"
    ],
    "*backing-image": "ImageInfo",
    "*format-specific": "ImageInfoSpecific"
  }
}

##
# @ImageCheck:
#
# Information about a QEMU image file check
#
# @filename: name of the image file checked
#
# @format: format of the image file checked
#
# @check-errors: number of unexpected errors occurred during check
#
# @image-end-offset: offset (in bytes) where the image ends, this
#                    field is present if the driver for the image format
#                    supports it
#
# @corruptions: number of corruptions found during the check if any
#
# @leaks: number of leaks found during the check if any
#
# @corruptions-fixed: number of corruptions fixed during the check
#                     if any
#
# @leaks-fixed: number of leaks fixed during the check if any
#
# @total-clusters: total number of clusters, this field is present
#                  if the driver for the image format supports it
#
# @allocated-clusters: total number of allocated clusters, this
#                      field is present if the driver for the image format
#                      supports it
#
# @fragmented-clusters: total number of fragmented clusters, this
#                       field is present if the driver for the image format
#                       supports it
#
# @compressed-clusters: total number of compressed clusters, this
#                       field is present if the driver for the image format
#                       supports it
#
# Since: 1.4
#
##
{
  "struct": "ImageCheck",
  "data": {
    "filename": "str",
    "format": "str",
    "check-errors": "int",
    "*image-end-offset": "int",
    "*corruptions": "int",
    "*leaks": "int",
    "*corruptions-fixed": "int",
    "*leaks-fixed": "int",
    "*total-clusters": "int",
    "*allocated-clusters": "int",
    "*fragmented-clusters": "int",
    "*compressed-clusters": "int"
  }
}

##
# @MapEntry:
#
# Mapping information from a virtual block range to a host file range
#
# @start: the start byte of the mapped virtual range
#
# @length: the number of bytes of the mapped virtual range
#
# @data: whether the mapped range has data
#
# @zero: whether the virtual blocks are zeroed
#
# @depth: the depth of the mapping
#
# @offset: the offset in file that the virtual sectors are mapped to
#
# @filename: filename that is referred to by @offset
#
# Since: 2.6
#
##
{
  "struct": "MapEntry",
  "data": {
    "start": "int",
    "length": "int",
    "data": "bool",
    "zero": "bool",
    "depth": "int",
    "*offset": "int",
    "*filename": "str"
  }
}

##
# @BlockdevCacheInfo:
#
# Cache mode information for a block device
#
# @writeback:   true if writeback mode is enabled
# @direct:      true if the host page cache is bypassed (O_DIRECT)
# @no-flush:    true if flush requests are ignored for the device
#
# Since: 2.3
##
{
  "struct": "BlockdevCacheInfo",
  "data": {
    "writeback": "bool",
    "direct": "bool",
    "no-flush": "bool"
  }
}

##
# @BlockDeviceInfo:
#
# Information about the backing device for a block device.
#
# @file: the filename of the backing device
#
# @node-name: the name of the block driver node (Since 2.0)
#
# @ro: true if the backing device was open read-only
#
# @drv: the name of the block format used to open the backing device. As of
#       0.14.0 this can be: 'blkdebug', 'bochs', 'cloop', 'cow', 'dmg',
#       'file', 'file', 'ftp', 'ftps', 'host_cdrom', 'host_device',
#       'http', 'https', 'luks', 'nbd', 'parallels', 'qcow',
#       'qcow2', 'raw', 'vdi', 'vmdk', 'vpc', 'vvfat'
#       2.2: 'archipelago' added, 'cow' dropped
#       2.3: 'host_floppy' deprecated
#       2.5: 'host_floppy' dropped
#       2.6: 'luks' added
#       2.8: 'replication' added, 'tftp' dropped
#       2.9: 'archipelago' dropped
#
# @backing_file: the name of the backing file (for copy-on-write)
#
# @backing_file_depth: number of files in the backing file chain (since: 1.2)
#
# @encrypted: true if the backing device is encrypted
#
# @encryption_key_missing: Deprecated; always false
#
# @detect_zeroes: detect and optimize zero writes (Since 2.1)
#
# @bps: total throughput limit in bytes per second is specified
#
# @bps_rd: read throughput limit in bytes per second is specified
#
# @bps_wr: write throughput limit in bytes per second is specified
#
# @iops: total I/O operations per second is specified
#
# @iops_rd: read I/O operations per second is specified
#
# @iops_wr: write I/O operations per second is specified
#
# @image: the info of image used (since: 1.6)
#
# @bps_max: total throughput limit during bursts,
#                     in bytes (Since 1.7)
#
# @bps_rd_max: read throughput limit during bursts,
#                        in bytes (Since 1.7)
#
# @bps_wr_max: write throughput limit during bursts,
#                        in bytes (Since 1.7)
#
# @iops_max: total I/O operations per second during bursts,
#                      in bytes (Since 1.7)
#
# @iops_rd_max: read I/O operations per second during bursts,
#                         in bytes (Since 1.7)
#
# @iops_wr_max: write I/O operations per second during bursts,
#                         in bytes (Since 1.7)
#
# @bps_max_length: maximum length of the @bps_max burst
#                            period, in seconds. (Since 2.6)
#
# @bps_rd_max_length: maximum length of the @bps_rd_max
#                               burst period, in seconds. (Since 2.6)
#
# @bps_wr_max_length: maximum length of the @bps_wr_max
#                               burst period, in seconds. (Since 2.6)
#
# @iops_max_length: maximum length of the @iops burst
#                             period, in seconds. (Since 2.6)
#
# @iops_rd_max_length: maximum length of the @iops_rd_max
#                                burst period, in seconds. (Since 2.6)
#
# @iops_wr_max_length: maximum length of the @iops_wr_max
#                                burst period, in seconds. (Since 2.6)
#
# @iops_size: an I/O size in bytes (Since 1.7)
#
# @group: throttle group name (Since 2.4)
#
# @cache: the cache mode used for the block device (since: 2.3)
#
# @write_threshold: configured write threshold for the device.
#                   0 if disabled. (Since 2.3)
#
# Since: 0.14.0
#
##
{
  "struct": "BlockDeviceInfo",
  "data": {
    "file": "str",
    "*node-name": "str",
    "ro": "bool",
    "drv": "str",
    "*backing_file": "str",
    "backing_file_depth": "int",
    "encrypted": "bool",
    "encryption_key_missing": "bool",
    "detect_zeroes": "BlockdevDetectZeroesOptions",
    "bps": "int",
    "bps_rd": "int",
    "bps_wr": "int",
    "iops": "int",
    "iops_rd": "int",
    "iops_wr": "int",
    "image": "ImageInfo",
    "*bps_max": "int",
    "*bps_rd_max": "int",
    "*bps_wr_max": "int",
    "*iops_max": "int",
    "*iops_rd_max": "int",
    "*iops_wr_max": "int",
    "*bps_max_length": "int",
    "*bps_rd_max_length": "int",
    "*bps_wr_max_length": "int",
    "*iops_max_length": "int",
    "*iops_rd_max_length": "int",
    "*iops_wr_max_length": "int",
    "*iops_size": "int",
    "*group": "str",
    "cache": "BlockdevCacheInfo",
    "write_threshold": "int"
  }
}

##
# @BlockDeviceIoStatus:
#
# An enumeration of block device I/O status.
#
# @ok: The last I/O operation has succeeded
#
# @failed: The last I/O operation has failed
#
# @nospace: The last I/O operation has failed due to a no-space condition
#
# Since: 1.0
##
{
  "enum": "BlockDeviceIoStatus",
  "data": [
    "ok",
    "failed",
    "nospace"
  ]
}

##
# @BlockDeviceMapEntry:
#
# Entry in the metadata map of the device (returned by "qemu-img map")
#
# @start: Offset in the image of the first byte described by this entry
#         (in bytes)
#
# @length: Length of the range described by this entry (in bytes)
#
# @depth: Number of layers (0 = top image, 1 = top image's backing file, etc.)
#         before reaching one for which the range is allocated.  The value is
#         in the range 0 to the depth of the image chain - 1.
#
# @zero: the sectors in this range read as zeros
#
# @data: reading the image will actually read data from a file (in particular,
#        if @offset is present this means that the sectors are not simply
#        preallocated, but contain actual data in raw format)
#
# @offset: if present, the image file stores the data for this range in
#          raw format at the given offset.
#
# Since: 1.7
##
{
  "struct": "BlockDeviceMapEntry",
  "data": {
    "start": "int",
    "length": "int",
    "depth": "int",
    "zero": "bool",
    "data": "bool",
    "*offset": "int"
  }
}

##
# @DirtyBitmapStatus:
#
# An enumeration of possible states that a dirty bitmap can report to the user.
#
# @frozen: The bitmap is currently in-use by a backup operation or block job,
#          and is immutable.
#
# @disabled: The bitmap is currently in-use by an internal operation and is
#            read-only. It can still be deleted.
#
# @active: The bitmap is actively monitoring for new writes, and can be cleared,
#          deleted, or used for backup operations.
#
# Since: 2.4
##
{
  "enum": "DirtyBitmapStatus",
  "data": [
    "active",
    "disabled",
    "frozen"
  ]
}

##
# @BlockDirtyInfo:
#
# Block dirty bitmap information.
#
# @name: the name of the dirty bitmap (Since 2.4)
#
# @count: number of dirty bytes according to the dirty bitmap
#
# @granularity: granularity of the dirty bitmap in bytes (since 1.4)
#
# @status: current status of the dirty bitmap (since 2.4)
#
# Since: 1.3
##
{
  "struct": "BlockDirtyInfo",
  "data": {
    "*name": "str",
    "count": "int",
    "granularity": "uint32",
    "status": "DirtyBitmapStatus"
  }
}

##
# @BlockInfo:
#
# Block device information.  This structure describes a virtual device and
# the backing device associated with it.
#
# @device: The device name associated with the virtual device.
#
# @qdev: The qdev ID, or if no ID is assigned, the QOM path of the block
#        device. (since 2.10)
#
# @type: This field is returned only for compatibility reasons, it should
#        not be used (always returns 'unknown')
#
# @removable: True if the device supports removable media.
#
# @locked: True if the guest has locked this device from having its media
#          removed
#
# @tray_open: True if the device's tray is open
#             (only present if it has a tray)
#
# @dirty-bitmaps: dirty bitmaps information (only present if the
#                 driver has one or more dirty bitmaps) (Since 2.0)
#
# @io-status: @BlockDeviceIoStatus. Only present if the device
#             supports it and the VM is configured to stop on errors
#             (supported device models: virtio-blk, IDE, SCSI except
#             scsi-generic)
#
# @inserted: @BlockDeviceInfo describing the device if media is
#            present
#
# Since:  0.14.0
##
{
  "struct": "BlockInfo",
  "data": {
    "device": "str",
    "*qdev": "str",
    "type": "str",
    "removable": "bool",
    "locked": "bool",
    "*inserted": "BlockDeviceInfo",
    "*tray_open": "bool",
    "*io-status": "BlockDeviceIoStatus",
    "*dirty-bitmaps": [
      "BlockDirtyInfo"
    ]
  }
}

##
# @BlockMeasureInfo:
#
# Image file size calculation information.  This structure describes the size
# requirements for creating a new image file.
#
# The size requirements depend on the new image file format.  File size always
# equals virtual disk size for the 'raw' format, even for sparse POSIX files.
# Compact formats such as 'qcow2' represent unallocated and zero regions
# efficiently so file size may be smaller than virtual disk size.
#
# The values are upper bounds that are guaranteed to fit the new image file.
# Subsequent modification, such as internal snapshot or bitmap creation, may
# require additional space and is not covered here.
#
# @required: Size required for a new image file, in bytes.
#
# @fully-allocated: Image file size, in bytes, once data has been written
#                   to all sectors.
#
# Since: 2.10
##
{
  "struct": "BlockMeasureInfo",
  "data": {
    "required": "int",
    "fully-allocated": "int"
  }
}

##
# @query-block:
#
# Get a list of BlockInfo for all virtual block devices.
#
# Returns: a list of @BlockInfo describing each virtual block device. Filter
# nodes that were created implicitly are skipped over.
#
# Since: 0.14.0
#
# Example:
#
# -> { "execute": "query-block" }
# <- {
#       "return":[
#          {
#             "io-status": "ok",
#             "device":"ide0-hd0",
#             "locked":false,
#             "removable":false,
#             "inserted":{
#                "ro":false,
#                "drv":"qcow2",
#                "encrypted":false,
#                "file":"disks/test.qcow2",
#                "backing_file_depth":1,
#                "bps":1000000,
#                "bps_rd":0,
#                "bps_wr":0,
#                "iops":1000000,
#                "iops_rd":0,
#                "iops_wr":0,
#                "bps_max": 8000000,
#                "bps_rd_max": 0,
#                "bps_wr_max": 0,
#                "iops_max": 0,
#                "iops_rd_max": 0,
#                "iops_wr_max": 0,
#                "iops_size": 0,
#                "detect_zeroes": "on",
#                "write_threshold": 0,
#                "image":{
#                   "filename":"disks/test.qcow2",
#                   "format":"qcow2",
#                   "virtual-size":2048000,
#                   "backing_file":"base.qcow2",
#                   "full-backing-filename":"disks/base.qcow2",
#                   "backing-filename-format":"qcow2",
#                   "snapshots":[
#                      {
#                         "id": "1",
#                         "name": "snapshot1",
#                         "vm-state-size": 0,
#                         "date-sec": 10000200,
#                         "date-nsec": 12,
#                         "vm-clock-sec": 206,
#                         "vm-clock-nsec": 30
#                      }
#                   ],
#                   "backing-image":{
#                       "filename":"disks/base.qcow2",
#                       "format":"qcow2",
#                       "virtual-size":2048000
#                   }
#                }
#             },
#             "qdev": "ide_disk",
#             "type":"unknown"
#          },
#          {
#             "io-status": "ok",
#             "device":"ide1-cd0",
#             "locked":false,
#             "removable":true,
#             "qdev": "/machine/unattached/device[23]",
#             "tray_open": false,
#             "type":"unknown"
#          },
#          {
#             "device":"floppy0",
#             "locked":false,
#             "removable":true,
#             "qdev": "/machine/unattached/device[20]",
#             "type":"unknown"
#          },
#          {
#             "device":"sd0",
#             "locked":false,
#             "removable":true,
#             "type":"unknown"
#          }
#       ]
#    }
#
##
{
  "command": "query-block",
  "returns": [
    "BlockInfo"
  ]
}


##
# @BlockDeviceTimedStats:
#
# Statistics of a block device during a given interval of time.
#
# @interval_length: Interval used for calculating the statistics,
#                   in seconds.
#
# @min_rd_latency_ns: Minimum latency of read operations in the
#                     defined interval, in nanoseconds.
#
# @min_wr_latency_ns: Minimum latency of write operations in the
#                     defined interval, in nanoseconds.
#
# @min_flush_latency_ns: Minimum latency of flush operations in the
#                        defined interval, in nanoseconds.
#
# @max_rd_latency_ns: Maximum latency of read operations in the
#                     defined interval, in nanoseconds.
#
# @max_wr_latency_ns: Maximum latency of write operations in the
#                     defined interval, in nanoseconds.
#
# @max_flush_latency_ns: Maximum latency of flush operations in the
#                        defined interval, in nanoseconds.
#
# @avg_rd_latency_ns: Average latency of read operations in the
#                     defined interval, in nanoseconds.
#
# @avg_wr_latency_ns: Average latency of write operations in the
#                     defined interval, in nanoseconds.
#
# @avg_flush_latency_ns: Average latency of flush operations in the
#                        defined interval, in nanoseconds.
#
# @avg_rd_queue_depth: Average number of pending read operations
#                      in the defined interval.
#
# @avg_wr_queue_depth: Average number of pending write operations
#                      in the defined interval.
#
# Since: 2.5
##
{
  "struct": "BlockDeviceTimedStats",
  "data": {
    "interval_length": "int",
    "min_rd_latency_ns": "int",
    "max_rd_latency_ns": "int",
    "avg_rd_latency_ns": "int",
    "min_wr_latency_ns": "int",
    "max_wr_latency_ns": "int",
    "avg_wr_latency_ns": "int",
    "min_flush_latency_ns": "int",
    "max_flush_latency_ns": "int",
    "avg_flush_latency_ns": "int",
    "avg_rd_queue_depth": "number",
    "avg_wr_queue_depth": "number"
  }
}

##
# @BlockDeviceStats:
#
# Statistics of a virtual block device or a block backing device.
#
# @rd_bytes:      The number of bytes read by the device.
#
# @wr_bytes:      The number of bytes written by the device.
#
# @rd_operations: The number of read operations performed by the device.
#
# @wr_operations: The number of write operations performed by the device.
#
# @flush_operations: The number of cache flush operations performed by the
#                    device (since 0.15.0)
#
# @flush_total_time_ns: Total time spend on cache flushes in nano-seconds
#                       (since 0.15.0).
#
# @wr_total_time_ns: Total time spend on writes in nano-seconds (since 0.15.0).
#
# @rd_total_time_ns: Total_time_spend on reads in nano-seconds (since 0.15.0).
#
# @wr_highest_offset: The offset after the greatest byte written to the
#                     device.  The intended use of this information is for
#                     growable sparse files (like qcow2) that are used on top
#                     of a physical device.
#
# @rd_merged: Number of read requests that have been merged into another
#             request (Since 2.3).
#
# @wr_merged: Number of write requests that have been merged into another
#             request (Since 2.3).
#
# @idle_time_ns: Time since the last I/O operation, in
#                nanoseconds. If the field is absent it means that
#                there haven't been any operations yet (Since 2.5).
#
# @failed_rd_operations: The number of failed read operations
#                        performed by the device (Since 2.5)
#
# @failed_wr_operations: The number of failed write operations
#                        performed by the device (Since 2.5)
#
# @failed_flush_operations: The number of failed flush operations
#                           performed by the device (Since 2.5)
#
# @invalid_rd_operations: The number of invalid read operations
#                          performed by the device (Since 2.5)
#
# @invalid_wr_operations: The number of invalid write operations
#                         performed by the device (Since 2.5)
#
# @invalid_flush_operations: The number of invalid flush operations
#                            performed by the device (Since 2.5)
#
# @account_invalid: Whether invalid operations are included in the
#                   last access statistics (Since 2.5)
#
# @account_failed: Whether failed operations are included in the
#                  latency and last access statistics (Since 2.5)
#
# @timed_stats: Statistics specific to the set of previously defined
#               intervals of time (Since 2.5)
#
# Since: 0.14.0
##
{
  "struct": "BlockDeviceStats",
  "data": {
    "rd_bytes": "int",
    "wr_bytes": "int",
    "rd_operations": "int",
    "wr_operations": "int",
    "flush_operations": "int",
    "flush_total_time_ns": "int",
    "wr_total_time_ns": "int",
    "rd_total_time_ns": "int",
    "wr_highest_offset": "int",
    "rd_merged": "int",
    "wr_merged": "int",
    "*idle_time_ns": "int",
    "failed_rd_operations": "int",
    "failed_wr_operations": "int",
    "failed_flush_operations": "int",
    "invalid_rd_operations": "int",
    "invalid_wr_operations": "int",
    "invalid_flush_operations": "int",
    "account_invalid": "bool",
    "account_failed": "bool",
    "timed_stats": [
      "BlockDeviceTimedStats"
    ]
  }
}

##
# @BlockStats:
#
# Statistics of a virtual block device or a block backing device.
#
# @device: If the stats are for a virtual block device, the name
#          corresponding to the virtual block device.
#
# @node-name: The node name of the device. (Since 2.3)
#
# @stats:  A @BlockDeviceStats for the device.
#
# @parent: This describes the file block device if it has one.
#          Contains recursively the statistics of the underlying
#          protocol (e.g. the host file for a qcow2 image). If there is
#          no underlying protocol, this field is omitted
#
# @backing: This describes the backing block device if it has one.
#           (Since 2.0)
#
# Since: 0.14.0
##
{
  "struct": "BlockStats",
  "data": {
    "*device": "str",
    "*node-name": "str",
    "stats": "BlockDeviceStats",
    "*parent": "BlockStats",
    "*backing": "BlockStats"
  }
}

##
# @query-blockstats:
#
# Query the @BlockStats for all virtual block devices.
#
# @query-nodes: If true, the command will query all the block nodes
#               that have a node name, in a list which will include "parent"
#               information, but not "backing".
#               If false or omitted, the behavior is as before - query all the
#               device backends, recursively including their "parent" and
#               "backing". Filter nodes that were created implicitly are
#               skipped over in this mode. (Since 2.3)
#
# Returns: A list of @BlockStats for each virtual block devices.
#
# Since: 0.14.0
#
# Example:
#
# -> { "execute": "query-blockstats" }
# <- {
#       "return":[
#          {
#             "device":"ide0-hd0",
#             "parent":{
#                "stats":{
#                   "wr_highest_offset":3686448128,
#                   "wr_bytes":9786368,
#                   "wr_operations":751,
#                   "rd_bytes":122567168,
#                   "rd_operations":36772
#                   "wr_total_times_ns":313253456
#                   "rd_total_times_ns":3465673657
#                   "flush_total_times_ns":49653
#                   "flush_operations":61,
#                   "rd_merged":0,
#                   "wr_merged":0,
#                   "idle_time_ns":2953431879,
#                   "account_invalid":true,
#                   "account_failed":false
#                }
#             },
#             "stats":{
#                "wr_highest_offset":2821110784,
#                "wr_bytes":9786368,
#                "wr_operations":692,
#                "rd_bytes":122739200,
#                "rd_operations":36604
#                "flush_operations":51,
#                "wr_total_times_ns":313253456
#                "rd_total_times_ns":3465673657
#                "flush_total_times_ns":49653,
#                "rd_merged":0,
#                "wr_merged":0,
#                "idle_time_ns":2953431879,
#                "account_invalid":true,
#                "account_failed":false
#             }
#          },
#          {
#             "device":"ide1-cd0",
#             "stats":{
#                "wr_highest_offset":0,
#                "wr_bytes":0,
#                "wr_operations":0,
#                "rd_bytes":0,
#                "rd_operations":0
#                "flush_operations":0,
#                "wr_total_times_ns":0
#                "rd_total_times_ns":0
#                "flush_total_times_ns":0,
#                "rd_merged":0,
#                "wr_merged":0,
#                "account_invalid":false,
#                "account_failed":false
#             }
#          },
#          {
#             "device":"floppy0",
#             "stats":{
#                "wr_highest_offset":0,
#                "wr_bytes":0,
#                "wr_operations":0,
#                "rd_bytes":0,
#                "rd_operations":0
#                "flush_operations":0,
#                "wr_total_times_ns":0
#                "rd_total_times_ns":0
#                "flush_total_times_ns":0,
#                "rd_merged":0,
#                "wr_merged":0,
#                "account_invalid":false,
#                "account_failed":false
#             }
#          },
#          {
#             "device":"sd0",
#             "stats":{
#                "wr_highest_offset":0,
#                "wr_bytes":0,
#                "wr_operations":0,
#                "rd_bytes":0,
#                "rd_operations":0
#                "flush_operations":0,
#                "wr_total_times_ns":0
#                "rd_total_times_ns":0
#                "flush_total_times_ns":0,
#                "rd_merged":0,
#                "wr_merged":0,
#                "account_invalid":false,
#                "account_failed":false
#             }
#          }
#       ]
#    }
#
##
{
  "command": "query-blockstats",
  "data": {
    "*query-nodes": "bool"
  },
  "returns": [
    "BlockStats"
  ]
}

##
# @BlockdevOnError:
#
# An enumeration of possible behaviors for errors on I/O operations.
# The exact meaning depends on whether the I/O was initiated by a guest
# or by a block job
#
# @report: for guest operations, report the error to the guest;
#          for jobs, cancel the job
#
# @ignore: ignore the error, only report a QMP event (BLOCK_IO_ERROR
#          or BLOCK_JOB_ERROR)
#
# @enospc: same as @stop on ENOSPC, same as @report otherwise.
#
# @stop: for guest operations, stop the virtual machine;
#        for jobs, pause the job
#
# @auto: inherit the error handling policy of the backend (since: 2.7)
#
# Since: 1.3
##
{
  "enum": "BlockdevOnError",
  "data": [
    "report",
    "ignore",
    "enospc",
    "stop",
    "auto"
  ]
}

##
# @MirrorSyncMode:
#
# An enumeration of possible behaviors for the initial synchronization
# phase of storage mirroring.
#
# @top: copies data in the topmost image to the destination
#
# @full: copies data from all images to the destination
#
# @none: only copy data written from now on
#
# @incremental: only copy data described by the dirty bitmap. Since: 2.4
#
# Since: 1.3
##
{
  "enum": "MirrorSyncMode",
  "data": [
    "top",
    "full",
    "none",
    "incremental"
  ]
}

##
# @BlockJobType:
#
# Type of a block job.
#
# @commit: block commit job type, see "block-commit"
#
# @stream: block stream job type, see "block-stream"
#
# @mirror: drive mirror job type, see "drive-mirror"
#
# @backup: drive backup job type, see "drive-backup"
#
# Since: 1.7
##
{
  "enum": "BlockJobType",
  "data": [
    "commit",
    "stream",
    "mirror",
    "backup"
  ]
}

##
# @BlockJobInfo:
#
# Information about a long-running block device operation.
#
# @type: the job type ('stream' for image streaming)
#
# @device: The job identifier. Originally the device name but other
#          values are allowed since QEMU 2.7
#
# @len: the maximum progress value
#
# @busy: false if the job is known to be in a quiescent state, with
#        no pending I/O.  Since 1.3.
#
# @paused: whether the job is paused or, if @busy is true, will
#          pause itself as soon as possible.  Since 1.3.
#
# @offset: the current progress value
#
# @speed: the rate limit, bytes per second
#
# @io-status: the status of the job (since 1.3)
#
# @ready: true if the job may be completed (since 2.2)
#
# Since: 1.1
##
{
  "struct": "BlockJobInfo",
  "data": {
    "type": "str",
    "device": "str",
    "len": "int",
    "offset": "int",
    "busy": "bool",
    "paused": "bool",
    "speed": "int",
    "io-status": "BlockDeviceIoStatus",
    "ready": "bool"
  }
}

##
# @query-block-jobs:
#
# Return information about long-running block device operations.
#
# Returns: a list of @BlockJobInfo for each active block job
#
# Since: 1.1
##
{
  "command": "query-block-jobs",
  "returns": [
    "BlockJobInfo"
  ]
}

##
# @block_passwd:
#
# This command sets the password of a block device that has not been open
# with a password and requires one.
#
# This command is now obsolete and will always return an error since 2.10
#
##
{
  "command": "block_passwd",
  "data": {
    "*device": "str",
    "*node-name": "str",
    "password": "str"
  }
}

##
# @block_resize:
#
# Resize a block image while a guest is running.
#
# Either @device or @node-name must be set but not both.
#
# @device: the name of the device to get the image resized
#
# @node-name: graph node name to get the image resized (Since 2.0)
#
# @size:  new image size in bytes
#
# Returns: nothing on success
#          If @device is not a valid block device, DeviceNotFound
#
# Since: 0.14.0
#
# Example:
#
# -> { "execute": "block_resize",
#      "arguments": { "device": "scratch", "size": 1073741824 } }
# <- { "return": {} }
#
##
{
  "command": "block_resize",
  "data": {
    "*device": "str",
    "*node-name": "str",
    "size": "int"
  }
}

##
# @NewImageMode:
#
# An enumeration that tells QEMU how to set the backing file path in
# a new image file.
#
# @existing: QEMU should look for an existing image file.
#
# @absolute-paths: QEMU should create a new image with absolute paths
# for the backing file. If there is no backing file available, the new
# image will not be backed either.
#
# Since: 1.1
##
{
  "enum": "NewImageMode",
  "data": [
    "existing",
    "absolute-paths"
  ]
}

##
# @BlockdevSnapshotSync:
#
# Either @device or @node-name must be set but not both.
#
# @device: the name of the device to generate the snapshot from.
#
# @node-name: graph node name to generate the snapshot from (Since 2.0)
#
# @snapshot-file: the target of the new image. If the file exists, or
# if it is a device, the snapshot will be created in the existing
# file/device. Otherwise, a new file will be created.
#
# @snapshot-node-name: the graph node name of the new image (Since 2.0)
#
# @format: the format of the snapshot image, default is 'qcow2'.
#
# @mode: whether and how QEMU should create a new image, default is
#        'absolute-paths'.
##
{
  "struct": "BlockdevSnapshotSync",
  "data": {
    "*device": "str",
    "*node-name": "str",
    "snapshot-file": "str",
    "*snapshot-node-name": "str",
    "*format": "str",
    "*mode": "NewImageMode"
  }
}

##
# @BlockdevSnapshot:
#
# @node: device or node name that will have a snapshot created.
#
# @overlay: reference to the existing block device that will become
#           the overlay of @node, as part of creating the snapshot.
#           It must not have a current backing file (this can be
#           achieved by passing "backing": "" to blockdev-add).
#
# Since: 2.5
##
{
  "struct": "BlockdevSnapshot",
  "data": {
    "node": "str",
    "overlay": "str"
  }
}

##
# @DriveBackup:
#
# @job-id: identifier for the newly-created block job. If
#          omitted, the device name will be used. (Since 2.7)
#
# @device: the device name or node-name of a root node which should be copied.
#
# @target: the target of the new image. If the file exists, or if it
#          is a device, the existing file/device will be used as the new
#          destination.  If it does not exist, a new file will be created.
#
# @format: the format of the new destination, default is to
#          probe if @mode is 'existing', else the format of the source
#
# @sync: what parts of the disk image should be copied to the destination
#        (all the disk, only the sectors allocated in the topmost image, from a
#        dirty bitmap, or only new I/O).
#
# @mode: whether and how QEMU should create a new image, default is
#        'absolute-paths'.
#
# @speed: the maximum speed, in bytes per second
#
# @bitmap: the name of dirty bitmap if sync is "incremental".
#          Must be present if sync is "incremental", must NOT be present
#          otherwise. (Since 2.4)
#
# @compress: true to compress data, if the target format supports it.
#            (default: false) (since 2.8)
#
# @on-source-error: the action to take on an error on the source,
#                   default 'report'.  'stop' and 'enospc' can only be used
#                   if the block device supports io-status (see BlockInfo).
#
# @on-target-error: the action to take on an error on the target,
#                   default 'report' (no limitations, since this applies to
#                   a different block device than @device).
#
# Note: @on-source-error and @on-target-error only affect background
# I/O.  If an error occurs during a guest write request, the device's
# rerror/werror actions will be used.
#
# Since: 1.6
##
{
  "struct": "DriveBackup",
  "data": {
    "*job-id": "str",
    "device": "str",
    "target": "str",
    "*format": "str",
    "sync": "MirrorSyncMode",
    "*mode": "NewImageMode",
    "*speed": "int",
    "*bitmap": "str",
    "*compress": "bool",
    "*on-source-error": "BlockdevOnError",
    "*on-target-error": "BlockdevOnError"
  }
}

##
# @BlockdevBackup:
#
# @job-id: identifier for the newly-created block job. If
#          omitted, the device name will be used. (Since 2.7)
#
# @device: the device name or node-name of a root node which should be copied.
#
# @target: the device name or node-name of the backup target node.
#
# @sync: what parts of the disk image should be copied to the destination
#        (all the disk, only the sectors allocated in the topmost image, or
#        only new I/O).
#
# @speed: the maximum speed, in bytes per second. The default is 0,
#         for unlimited.
#
# @compress: true to compress data, if the target format supports it.
#            (default: false) (since 2.8)
#
# @on-source-error: the action to take on an error on the source,
#                   default 'report'.  'stop' and 'enospc' can only be used
#                   if the block device supports io-status (see BlockInfo).
#
# @on-target-error: the action to take on an error on the target,
#                   default 'report' (no limitations, since this applies to
#                   a different block device than @device).
#
# Note: @on-source-error and @on-target-error only affect background
# I/O.  If an error occurs during a guest write request, the device's
# rerror/werror actions will be used.
#
# Since: 2.3
##
{
  "struct": "BlockdevBackup",
  "data": {
    "*job-id": "str",
    "device": "str",
    "target": "str",
    "sync": "MirrorSyncMode",
    "*speed": "int",
    "*compress": "bool",
    "*on-source-error": "BlockdevOnError",
    "*on-target-error": "BlockdevOnError"
  }
}

##
# @blockdev-snapshot-sync:
#
# Generates a synchronous snapshot of a block device.
#
# For the arguments, see the documentation of BlockdevSnapshotSync.
#
# Returns: nothing on success
#          If @device is not a valid block device, DeviceNotFound
#
# Since: 0.14.0
#
# Example:
#
# -> { "execute": "blockdev-snapshot-sync",
#      "arguments": { "device": "ide-hd0",
#                     "snapshot-file":
#                     "/some/place/my-image",
#                     "format": "qcow2" } }
# <- { "return": {} }
#
##
{
  "command": "blockdev-snapshot-sync",
  "data": "BlockdevSnapshotSync"
}


##
# @blockdev-snapshot:
#
# Generates a snapshot of a block device.
#
# Create a snapshot, by installing 'node' as the backing image of
# 'overlay'. Additionally, if 'node' is associated with a block
# device, the block device changes to using 'overlay' as its new active
# image.
#
# For the arguments, see the documentation of BlockdevSnapshot.
#
# Since: 2.5
#
# Example:
#
# -> { "execute": "blockdev-add",
#      "arguments": { "driver": "qcow2",
#                     "node-name": "node1534",
#                     "file": { "driver": "file",
#                               "filename": "hd1.qcow2" },
#                     "backing": "" } }
#
# <- { "return": {} }
#
# -> { "execute": "blockdev-snapshot",
#      "arguments": { "node": "ide-hd0",
#                     "overlay": "node1534" } }
# <- { "return": {} }
#
##
{
  "command": "blockdev-snapshot",
  "data": "BlockdevSnapshot"
}

##
# @change-backing-file:
#
# Change the backing file in the image file metadata.  This does not
# cause QEMU to reopen the image file to reparse the backing filename
# (it may, however, perform a reopen to change permissions from
# r/o -> r/w -> r/o, if needed). The new backing file string is written
# into the image file metadata, and the QEMU internal strings are
# updated.
#
# @image-node-name: The name of the block driver state node of the
#                   image to modify. The "device" argument is used
#                   to verify "image-node-name" is in the chain
#                   described by "device".
#
# @device:          The device name or node-name of the root node that owns
#                   image-node-name.
#
# @backing-file:    The string to write as the backing file.  This
#                   string is not validated, so care should be taken
#                   when specifying the string or the image chain may
#                   not be able to be reopened again.
#
# Returns: Nothing on success
#
#          If "device" does not exist or cannot be determined, DeviceNotFound
#
# Since: 2.1
##
{
  "command": "change-backing-file",
  "data": {
    "device": "str",
    "image-node-name": "str",
    "backing-file": "str"
  }
}

##
# @block-commit:
#
# Live commit of data from overlay image nodes into backing nodes - i.e.,
# writes data between 'top' and 'base' into 'base'.
#
# @job-id: identifier for the newly-created block job. If
#          omitted, the device name will be used. (Since 2.7)
#
# @device:  the device name or node-name of a root node
#
# @base:   The file name of the backing image to write data into.
#                    If not specified, this is the deepest backing image.
#
# @top:    The file name of the backing image within the image chain,
#                    which contains the topmost data to be committed down. If
#                    not specified, this is the active layer.
#
# @backing-file:  The backing file string to write into the overlay
#                           image of 'top'.  If 'top' is the active layer,
#                           specifying a backing file string is an error. This
#                           filename is not validated.
#
#                           If a pathname string is such that it cannot be
#                           resolved by QEMU, that means that subsequent QMP or
#                           HMP commands must use node-names for the image in
#                           question, as filename lookup methods will fail.
#
#                           If not specified, QEMU will automatically determine
#                           the backing file string to use, or error out if
#                           there is no obvious choice. Care should be taken
#                           when specifying the string, to specify a valid
#                           filename or protocol.
#                           (Since 2.1)
#
#                    If top == base, that is an error.
#                    If top == active, the job will not be completed by itself,
#                    user needs to complete the job with the block-job-complete
#                    command after getting the ready event. (Since 2.0)
#
#                    If the base image is smaller than top, then the base image
#                    will be resized to be the same size as top.  If top is
#                    smaller than the base image, the base will not be
#                    truncated.  If you want the base image size to match the
#                    size of the smaller top, you can safely truncate it
#                    yourself once the commit operation successfully completes.
#
# @speed:  the maximum speed, in bytes per second
#
# @filter-node-name: the node name that should be assigned to the
#                    filter driver that the commit job inserts into the graph
#                    above @top. If this option is not given, a node name is
#                    autogenerated. (Since: 2.9)
#
# Returns: Nothing on success
#          If commit or stream is already active on this device, DeviceInUse
#          If @device does not exist, DeviceNotFound
#          If image commit is not supported by this device, NotSupported
#          If @base or @top is invalid, a generic error is returned
#          If @speed is invalid, InvalidParameter
#
# Since: 1.3
#
# Example:
#
# -> { "execute": "block-commit",
#      "arguments": { "device": "virtio0",
#                     "top": "/tmp/snap1.qcow2" } }
# <- { "return": {} }
#
##
{
  "command": "block-commit",
  "data": {
    "*job-id": "str",
    "device": "str",
    "*base": "str",
    "*top": "str",
    "*backing-file": "str",
    "*speed": "int",
    "*filter-node-name": "str"
  }
}

##
# @drive-backup:
#
# Start a point-in-time copy of a block device to a new destination.  The
# status of ongoing drive-backup operations can be checked with
# query-block-jobs where the BlockJobInfo.type field has the value 'backup'.
# The operation can be stopped before it has completed using the
# block-job-cancel command.
#
# Returns: nothing on success
#          If @device is not a valid block device, GenericError
#
# Since: 1.6
#
# Example:
#
# -> { "execute": "drive-backup",
#      "arguments": { "device": "drive0",
#                     "sync": "full",
#                     "target": "backup.img" } }
# <- { "return": {} }
#
##
{
  "command": "drive-backup",
  "boxed": true,
  "data": "DriveBackup"
}

##
# @blockdev-backup:
#
# Start a point-in-time copy of a block device to a new destination.  The
# status of ongoing blockdev-backup operations can be checked with
# query-block-jobs where the BlockJobInfo.type field has the value 'backup'.
# The operation can be stopped before it has completed using the
# block-job-cancel command.
#
# Returns: nothing on success
#          If @device is not a valid block device, DeviceNotFound
#
# Since: 2.3
#
# Example:
# -> { "execute": "blockdev-backup",
#      "arguments": { "device": "src-id",
#                     "sync": "full",
#                     "target": "tgt-id" } }
# <- { "return": {} }
#
##
{
  "command": "blockdev-backup",
  "boxed": true,
  "data": "BlockdevBackup"
}


##
# @query-named-block-nodes:
#
# Get the named block driver list
#
# Returns: the list of BlockDeviceInfo
#
# Since: 2.0
#
# Example:
#
# -> { "execute": "query-named-block-nodes" }
# <- { "return": [ { "ro":false,
#                    "drv":"qcow2",
#                    "encrypted":false,
#                    "file":"disks/test.qcow2",
#                    "node-name": "my-node",
#                    "backing_file_depth":1,
#                    "bps":1000000,
#                    "bps_rd":0,
#                    "bps_wr":0,
#                    "iops":1000000,
#                    "iops_rd":0,
#                    "iops_wr":0,
#                    "bps_max": 8000000,
#                    "bps_rd_max": 0,
#                    "bps_wr_max": 0,
#                    "iops_max": 0,
#                    "iops_rd_max": 0,
#                    "iops_wr_max": 0,
#                    "iops_size": 0,
#                    "write_threshold": 0,
#                    "image":{
#                       "filename":"disks/test.qcow2",
#                       "format":"qcow2",
#                       "virtual-size":2048000,
#                       "backing_file":"base.qcow2",
#                       "full-backing-filename":"disks/base.qcow2",
#                       "backing-filename-format":"qcow2",
#                       "snapshots":[
#                          {
#                             "id": "1",
#                             "name": "snapshot1",
#                             "vm-state-size": 0,
#                             "date-sec": 10000200,
#                             "date-nsec": 12,
#                             "vm-clock-sec": 206,
#                             "vm-clock-nsec": 30
#                          }
#                       ],
#                       "backing-image":{
#                           "filename":"disks/base.qcow2",
#                           "format":"qcow2",
#                           "virtual-size":2048000
#                       }
#                    } } ] }
#
##
{
  "command": "query-named-block-nodes",
  "returns": [
    "BlockDeviceInfo"
  ]
}

##
# @drive-mirror:
#
# Start mirroring a block device's writes to a new destination. target
# specifies the target of the new image. If the file exists, or if it
# is a device, it will be used as the new destination for writes. If
# it does not exist, a new file will be created. format specifies the
# format of the mirror image, default is to probe if mode='existing',
# else the format of the source.
#
# Returns: nothing on success
#          If @device is not a valid block device, GenericError
#
# Since: 1.3
#
# Example:
#
# -> { "execute": "drive-mirror",
#      "arguments": { "device": "ide-hd0",
#                     "target": "/some/place/my-image",
#                     "sync": "full",
#                     "format": "qcow2" } }
# <- { "return": {} }
#
##
{
  "command": "drive-mirror",
  "boxed": true,
  "data": "DriveMirror"
}

##
# @DriveMirror:
#
# A set of parameters describing drive mirror setup.
#
# @job-id: identifier for the newly-created block job. If
#          omitted, the device name will be used. (Since 2.7)
#
# @device:  the device name or node-name of a root node whose writes should be
#           mirrored.
#
# @target: the target of the new image. If the file exists, or if it
#          is a device, the existing file/device will be used as the new
#          destination.  If it does not exist, a new file will be created.
#
# @format: the format of the new destination, default is to
#          probe if @mode is 'existing', else the format of the source
#
# @node-name: the new block driver state node name in the graph
#             (Since 2.1)
#
# @replaces: with sync=full graph node name to be replaced by the new
#            image when a whole image copy is done. This can be used to repair
#            broken Quorum files. (Since 2.1)
#
# @mode: whether and how QEMU should create a new image, default is
#        'absolute-paths'.
#
# @speed:  the maximum speed, in bytes per second
#
# @sync: what parts of the disk image should be copied to the destination
#        (all the disk, only the sectors allocated in the topmost image, or
#        only new I/O).
#
# @granularity: granularity of the dirty bitmap, default is 64K
#               if the image format doesn't have clusters, 4K if the clusters
#               are smaller than that, else the cluster size.  Must be a
#               power of 2 between 512 and 64M (since 1.4).
#
# @buf-size: maximum amount of data in flight from source to
#            target (since 1.4).
#
# @on-source-error: the action to take on an error on the source,
#                   default 'report'.  'stop' and 'enospc' can only be used
#                   if the block device supports io-status (see BlockInfo).
#
# @on-target-error: the action to take on an error on the target,
#                   default 'report' (no limitations, since this applies to
#                   a different block device than @device).
# @unmap: Whether to try to unmap target sectors where source has
#         only zero. If true, and target unallocated sectors will read as zero,
#         target image sectors will be unmapped; otherwise, zeroes will be
#         written. Both will result in identical contents.
#         Default is true. (Since 2.4)
#
# Since: 1.3
##
{
  "struct": "DriveMirror",
  "data": {
    "*job-id": "str",
    "device": "str",
    "target": "str",
    "*format": "str",
    "*node-name": "str",
    "*replaces": "str",
    "sync": "MirrorSyncMode",
    "*mode": "NewImageMode",
    "*speed": "int",
    "*granularity": "uint32",
    "*buf-size": "int",
    "*on-source-error": "BlockdevOnError",
    "*on-target-error": "BlockdevOnError",
    "*unmap": "bool"
  }
}

##
# @BlockDirtyBitmap:
#
# @node: name of device/node which the bitmap is tracking
#
# @name: name of the dirty bitmap
#
# Since: 2.4
##
{
  "struct": "BlockDirtyBitmap",
  "data": {
    "node": "str",
    "name": "str"
  }
}

##
# @BlockDirtyBitmapAdd:
#
# @node: name of device/node which the bitmap is tracking
#
# @name: name of the dirty bitmap
#
# @granularity: the bitmap granularity, default is 64k for
#               block-dirty-bitmap-add
#
# @persistent: the bitmap is persistent, i.e. it will be saved to the
#              corresponding block device image file on its close. For now only
#              Qcow2 disks support persistent bitmaps. Default is false for
#              block-dirty-bitmap-add. (Since: 2.10)
#
# @autoload: the bitmap will be automatically loaded when the image it is stored
#            in is opened. This flag may only be specified for persistent
#            bitmaps. Default is false for block-dirty-bitmap-add. (Since: 2.10)
#
# Since: 2.4
##
{
  "struct": "BlockDirtyBitmapAdd",
  "data": {
    "node": "str",
    "name": "str",
    "*granularity": "uint32",
    "*persistent": "bool",
    "*autoload": "bool"
  }
}

##
# @block-dirty-bitmap-add:
#
# Create a dirty bitmap with a name on the node, and start tracking the writes.
#
# Returns: nothing on success
#          If @node is not a valid block device or node, DeviceNotFound
#          If @name is already taken, GenericError with an explanation
#
# Since: 2.4
#
# Example:
#
# -> { "execute": "block-dirty-bitmap-add",
#      "arguments": { "node": "drive0", "name": "bitmap0" } }
# <- { "return": {} }
#
##
{
  "command": "block-dirty-bitmap-add",
  "data": "BlockDirtyBitmapAdd"
}

##
# @block-dirty-bitmap-remove:
#
# Stop write tracking and remove the dirty bitmap that was created
# with block-dirty-bitmap-add. If the bitmap is persistent, remove it from its
# storage too.
#
# Returns: nothing on success
#          If @node is not a valid block device or node, DeviceNotFound
#          If @name is not found, GenericError with an explanation
#          if @name is frozen by an operation, GenericError
#
# Since: 2.4
#
# Example:
#
# -> { "execute": "block-dirty-bitmap-remove",
#      "arguments": { "node": "drive0", "name": "bitmap0" } }
# <- { "return": {} }
#
##
{
  "command": "block-dirty-bitmap-remove",
  "data": "BlockDirtyBitmap"
}

##
# @block-dirty-bitmap-clear:
#
# Clear (reset) a dirty bitmap on the device, so that an incremental
# backup from this point in time forward will only backup clusters
# modified after this clear operation.
#
# Returns: nothing on success
#          If @node is not a valid block device, DeviceNotFound
#          If @name is not found, GenericError with an explanation
#
# Since: 2.4
#
# Example:
#
# -> { "execute": "block-dirty-bitmap-clear",
#      "arguments": { "node": "drive0", "name": "bitmap0" } }
# <- { "return": {} }
#
##
{
  "command": "block-dirty-bitmap-clear",
  "data": "BlockDirtyBitmap"
}

##
# @blockdev-mirror:
#
# Start mirroring a block device's writes to a new destination.
#
# @job-id: identifier for the newly-created block job. If
#          omitted, the device name will be used. (Since 2.7)
#
# @device: The device name or node-name of a root node whose writes should be
#          mirrored.
#
# @target: the id or node-name of the block device to mirror to. This mustn't be
#          attached to guest.
#
# @replaces: with sync=full graph node name to be replaced by the new
#            image when a whole image copy is done. This can be used to repair
#            broken Quorum files.
#
# @speed:  the maximum speed, in bytes per second
#
# @sync: what parts of the disk image should be copied to the destination
#        (all the disk, only the sectors allocated in the topmost image, or
#        only new I/O).
#
# @granularity: granularity of the dirty bitmap, default is 64K
#               if the image format doesn't have clusters, 4K if the clusters
#               are smaller than that, else the cluster size.  Must be a
#               power of 2 between 512 and 64M
#
# @buf-size: maximum amount of data in flight from source to
#            target
#
# @on-source-error: the action to take on an error on the source,
#                   default 'report'.  'stop' and 'enospc' can only be used
#                   if the block device supports io-status (see BlockInfo).
#
# @on-target-error: the action to take on an error on the target,
#                   default 'report' (no limitations, since this applies to
#                   a different block device than @device).
#
# @filter-node-name: the node name that should be assigned to the
#                    filter driver that the mirror job inserts into the graph
#                    above @device. If this option is not given, a node name is
#                    autogenerated. (Since: 2.9)
#
# Returns: nothing on success.
#
# Since: 2.6
#
# Example:
#
# -> { "execute": "blockdev-mirror",
#      "arguments": { "device": "ide-hd0",
#                     "target": "target0",
#                     "sync": "full" } }
# <- { "return": {} }
#
##
{
  "command": "blockdev-mirror",
  "data": {
    "*job-id": "str",
    "device": "str",
    "target": "str",
    "*replaces": "str",
    "sync": "MirrorSyncMode",
    "*speed": "int",
    "*granularity": "uint32",
    "*buf-size": "int",
    "*on-source-error": "BlockdevOnError",
    "*on-target-error": "BlockdevOnError",
    "*filter-node-name": "str"
  }
}

##
{
  "command": "block_set_io_throttle",
  "boxed": true,
  "data": "BlockIOThrottle"
}

##
# @BlockIOThrottle:
#
# A set of parameters describing block throttling.
#
# @device: Block device name (deprecated, use @id instead)
#
# @id: The name or QOM path of the guest device (since: 2.8)
#
# @bps: total throughput limit in bytes per second
#
# @bps_rd: read throughput limit in bytes per second
#
# @bps_wr: write throughput limit in bytes per second
#
# @iops: total I/O operations per second
#
# @iops_rd: read I/O operations per second
#
# @iops_wr: write I/O operations per second
#
# @bps_max: total throughput limit during bursts,
#                     in bytes (Since 1.7)
#
# @bps_rd_max: read throughput limit during bursts,
#                        in bytes (Since 1.7)
#
# @bps_wr_max: write throughput limit during bursts,
#                        in bytes (Since 1.7)
#
# @iops_max: total I/O operations per second during bursts,
#                      in bytes (Since 1.7)
#
# @iops_rd_max: read I/O operations per second during bursts,
#                         in bytes (Since 1.7)
#
# @iops_wr_max: write I/O operations per second during bursts,
#                         in bytes (Since 1.7)
#
# @bps_max_length: maximum length of the @bps_max burst
#                            period, in seconds. It must only
#                            be set if @bps_max is set as well.
#                            Defaults to 1. (Since 2.6)
#
# @bps_rd_max_length: maximum length of the @bps_rd_max
#                               burst period, in seconds. It must only
#                               be set if @bps_rd_max is set as well.
#                               Defaults to 1. (Since 2.6)
#
# @bps_wr_max_length: maximum length of the @bps_wr_max
#                               burst period, in seconds. It must only
#                               be set if @bps_wr_max is set as well.
#                               Defaults to 1. (Since 2.6)
#
# @iops_max_length: maximum length of the @iops burst
#                             period, in seconds. It must only
#                             be set if @iops_max is set as well.
#                             Defaults to 1. (Since 2.6)
#
# @iops_rd_max_length: maximum length of the @iops_rd_max
#                                burst period, in seconds. It must only
#                                be set if @iops_rd_max is set as well.
#                                Defaults to 1. (Since 2.6)
#
# @iops_wr_max_length: maximum length of the @iops_wr_max
#                                burst period, in seconds. It must only
#                                be set if @iops_wr_max is set as well.
#                                Defaults to 1. (Since 2.6)
#
# @iops_size: an I/O size in bytes (Since 1.7)
#
# @group: throttle group name (Since 2.4)
#
# Since: 1.1
##
{
  "struct": "BlockIOThrottle",
  "data": {
    "*device": "str",
    "*id": "str",
    "bps": "int",
    "bps_rd": "int",
    "bps_wr": "int",
    "iops": "int",
    "iops_rd": "int",
    "iops_wr": "int",
    "*bps_max": "int",
    "*bps_rd_max": "int",
    "*bps_wr_max": "int",
    "*iops_max": "int",
    "*iops_rd_max": "int",
    "*iops_wr_max": "int",
    "*bps_max_length": "int",
    "*bps_rd_max_length": "int",
    "*bps_wr_max_length": "int",
    "*iops_max_length": "int",
    "*iops_rd_max_length": "int",
    "*iops_wr_max_length": "int",
    "*iops_size": "int",
    "*group": "str"
  }
}

##
# @ThrottleLimits:
#
# Limit parameters for throttling.
# Since some limit combinations are illegal, limits should always be set in one
# transaction. All fields are optional. When setting limits, if a field is
# missing the current value is not changed.
#
# @iops-total:             limit total I/O operations per second
# @iops-total-max:         I/O operations burst
# @iops-total-max-length:  length of the iops-total-max burst period, in seconds
#                          It must only be set if @iops-total-max is set as well.
# @iops-read:              limit read operations per second
# @iops-read-max:          I/O operations read burst
# @iops-read-max-length:   length of the iops-read-max burst period, in seconds
#                          It must only be set if @iops-read-max is set as well.
# @iops-write:             limit write operations per second
# @iops-write-max:         I/O operations write burst
# @iops-write-max-length:  length of the iops-write-max burst period, in seconds
#                          It must only be set if @iops-write-max is set as well.
# @bps-total:              limit total bytes per second
# @bps-total-max:          total bytes burst
# @bps-total-max-length:   length of the bps-total-max burst period, in seconds.
#                          It must only be set if @bps-total-max is set as well.
# @bps-read:               limit read bytes per second
# @bps-read-max:           total bytes read burst
# @bps-read-max-length:    length of the bps-read-max burst period, in seconds
#                          It must only be set if @bps-read-max is set as well.
# @bps-write:              limit write bytes per second
# @bps-write-max:          total bytes write burst
# @bps-write-max-length:   length of the bps-write-max burst period, in seconds
#                          It must only be set if @bps-write-max is set as well.
# @iops-size:              when limiting by iops max size of an I/O in bytes
#
# Since: 2.11
##
{
  "struct": "ThrottleLimits",
  "data": {
    "*iops-total": "int",
    "*iops-total-max": "int",
    "*iops-total-max-length": "int",
    "*iops-read": "int",
    "*iops-read-max": "int",
    "*iops-read-max-length": "int",
    "*iops-write": "int",
    "*iops-write-max": "int",
    "*iops-write-max-length": "int",
    "*bps-total": "int",
    "*bps-total-max": "int",
    "*bps-total-max-length": "int",
    "*bps-read": "int",
    "*bps-read-max": "int",
    "*bps-read-max-length": "int",
    "*bps-write": "int",
    "*bps-write-max": "int",
    "*bps-write-max-length": "int",
    "*iops-size": "int"
  }
}

##
# @block-stream:
#
# Copy data from a backing file into a block device.
#
# The block streaming operation is performed in the background until the entire
# backing file has been copied.  This command returns immediately once streaming
# has started.  The status of ongoing block streaming operations can be checked
# with query-block-jobs.  The operation can be stopped before it has completed
# using the block-job-cancel command.
#
# The node that receives the data is called the top image, can be located in
# any part of the chain (but always above the base image; see below) and can be
# specified using its device or node name. Earlier qemu versions only allowed
# 'device' to name the top level node; presence of the 'base-node' parameter
# during introspection can be used as a witness of the enhanced semantics
# of 'device'.
#
# If a base file is specified then sectors are not copied from that base file and
# its backing chain.  When streaming completes the image file will have the base
# file as its backing file.  This can be used to stream a subset of the backing
# file chain instead of flattening the entire image.
#
# On successful completion the image file is updated to drop the backing file
# and the BLOCK_JOB_COMPLETED event is emitted.
#
# @job-id: identifier for the newly-created block job. If
#          omitted, the device name will be used. (Since 2.7)
#
# @device: the device or node name of the top image
#
# @base:   the common backing file name.
#                    It cannot be set if @base-node is also set.
#
# @base-node: the node name of the backing file.
#                       It cannot be set if @base is also set. (Since 2.8)
#
# @backing-file: The backing file string to write into the top
#                          image. This filename is not validated.
#
#                          If a pathname string is such that it cannot be
#                          resolved by QEMU, that means that subsequent QMP or
#                          HMP commands must use node-names for the image in
#                          question, as filename lookup methods will fail.
#
#                          If not specified, QEMU will automatically determine
#                          the backing file string to use, or error out if there
#                          is no obvious choice.  Care should be taken when
#                          specifying the string, to specify a valid filename or
#                          protocol.
#                          (Since 2.1)
#
# @speed:  the maximum speed, in bytes per second
#
# @on-error: the action to take on an error (default report).
#            'stop' and 'enospc' can only be used if the block device
#            supports io-status (see BlockInfo).  Since 1.3.
#
# Returns: Nothing on success. If @device does not exist, DeviceNotFound.
#
# Since: 1.1
#
# Example:
#
# -> { "execute": "block-stream",
#      "arguments": { "device": "virtio0",
#                     "base": "/tmp/master.qcow2" } }
# <- { "return": {} }
#
##
{
  "command": "block-stream",
  "data": {
    "*job-id": "str",
    "device": "str",
    "*base": "str",
    "*base-node": "str",
    "*backing-file": "str",
    "*speed": "int",
    "*on-error": "BlockdevOnError"
  }
}

##
# @block-job-set-speed:
#
# Set maximum speed for a background block operation.
#
# This command can only be issued when there is an active block job.
#
# Throttling can be disabled by setting the speed to 0.
#
# @device: The job identifier. This used to be a device name (hence
#          the name of the parameter), but since QEMU 2.7 it can have
#          other values.
#
# @speed:  the maximum speed, in bytes per second, or 0 for unlimited.
#          Defaults to 0.
#
# Returns: Nothing on success
#          If no background operation is active on this device, DeviceNotActive
#
# Since: 1.1
##
{
  "command": "block-job-set-speed",
  "data": {
    "device": "str",
    "speed": "int"
  }
}

##
# @block-job-cancel:
#
# Stop an active background block operation.
#
# This command returns immediately after marking the active background block
# operation for cancellation.  It is an error to call this command if no
# operation is in progress.
#
# The operation will cancel as soon as possible and then emit the
# BLOCK_JOB_CANCELLED event.  Before that happens the job is still visible when
# enumerated using query-block-jobs.
#
# Note that if you issue 'block-job-cancel' after 'drive-mirror' has indicated
# (via the event BLOCK_JOB_READY) that the source and destination are
# synchronized, then the event triggered by this command changes to
# BLOCK_JOB_COMPLETED, to indicate that the mirroring has ended and the
# destination now has a point-in-time copy tied to the time of the cancellation.
#
# For streaming, the image file retains its backing file unless the streaming
# operation happens to complete just as it is being cancelled.  A new streaming
# operation can be started at a later time to finish copying all data from the
# backing file.
#
# @device: The job identifier. This used to be a device name (hence
#          the name of the parameter), but since QEMU 2.7 it can have
#          other values.
#
# @force: whether to allow cancellation of a paused job (default
#         false).  Since 1.3.
#
# Returns: Nothing on success
#          If no background operation is active on this device, DeviceNotActive
#
# Since: 1.1
##
{
  "command": "block-job-cancel",
  "data": {
    "device": "str",
    "*force": "bool"
  }
}

##
# @block-job-pause:
#
# Pause an active background block operation.
#
# This command returns immediately after marking the active background block
# operation for pausing.  It is an error to call this command if no
# operation is in progress.  Pausing an already paused job has no cumulative
# effect; a single block-job-resume command will resume the job.
#
# The operation will pause as soon as possible.  No event is emitted when
# the operation is actually paused.  Cancelling a paused job automatically
# resumes it.
#
# @device: The job identifier. This used to be a device name (hence
#          the name of the parameter), but since QEMU 2.7 it can have
#          other values.
#
# Returns: Nothing on success
#          If no background operation is active on this device, DeviceNotActive
#
# Since: 1.3
##
{
  "command": "block-job-pause",
  "data": {
    "device": "str"
  }
}

##
# @block-job-resume:
#
# Resume an active background block operation.
#
# This command returns immediately after resuming a paused background block
# operation.  It is an error to call this command if no operation is in
# progress.  Resuming an already running job is not an error.
#
# This command also clears the error status of the job.
#
# @device: The job identifier. This used to be a device name (hence
#          the name of the parameter), but since QEMU 2.7 it can have
#          other values.
#
# Returns: Nothing on success
#          If no background operation is active on this device, DeviceNotActive
#
# Since: 1.3
##
{
  "command": "block-job-resume",
  "data": {
    "device": "str"
  }
}

##
# @block-job-complete:
#
# Manually trigger completion of an active background block operation.  This
# is supported for drive mirroring, where it also switches the device to
# write to the target path only.  The ability to complete is signaled with
# a BLOCK_JOB_READY event.
#
# This command completes an active background block operation synchronously.
# The ordering of this command's return with the BLOCK_JOB_COMPLETED event
# is not defined.  Note that if an I/O error occurs during the processing of
# this command: 1) the command itself will fail; 2) the error will be processed
# according to the rerror/werror arguments that were specified when starting
# the operation.
#
# A cancelled or paused job cannot be completed.
#
# @device: The job identifier. This used to be a device name (hence
#          the name of the parameter), but since QEMU 2.7 it can have
#          other values.
#
# Returns: Nothing on success
#          If no background operation is active on this device, DeviceNotActive
#
# Since: 1.3
##
{
  "command": "block-job-complete",
  "data": {
    "device": "str"
  }
}

##
# @BlockdevDiscardOptions:
#
# Determines how to handle discard requests.
#
# @ignore:      Ignore the request
# @unmap:       Forward as an unmap request
#
# Since: 2.9
##
{
  "enum": "BlockdevDiscardOptions",
  "data": [
    "ignore",
    "unmap"
  ]
}

##
# @BlockdevDetectZeroesOptions:
#
# Describes the operation mode for the automatic conversion of plain
# zero writes by the OS to driver specific optimized zero write commands.
#
# @off:      Disabled (default)
# @on:       Enabled
# @unmap:    Enabled and even try to unmap blocks if possible. This requires
#            also that @BlockdevDiscardOptions is set to unmap for this device.
#
# Since: 2.1
##
{
  "enum": "BlockdevDetectZeroesOptions",
  "data": [
    "off",
    "on",
    "unmap"
  ]
}

##
# @BlockdevAioOptions:
#
# Selects the AIO backend to handle I/O requests
#
# @threads:     Use qemu's thread pool
# @native:      Use native AIO backend (only Linux and Windows)
#
# Since: 2.9
##
{
  "enum": "BlockdevAioOptions",
  "data": [
    "threads",
    "native"
  ]
}

##
# @BlockdevCacheOptions:
#
# Includes cache-related options for block devices
#
# @direct:      enables use of O_DIRECT (bypass the host page cache;
#               default: false)
# @no-flush:    ignore any flush requests for the device (default:
#               false)
#
# Since: 2.9
##
{
  "struct": "BlockdevCacheOptions",
  "data": {
    "*direct": "bool",
    "*no-flush": "bool"
  }
}

##
# @BlockdevDriver:
#
# Drivers that are supported in block device operations.
#
# @vxhs: Since 2.10
# @throttle: Since 2.11
#
# Since: 2.9
##
{
  "enum": "BlockdevDriver",
  "data": [
    "blkdebug",
    "blkverify",
    "bochs",
    "cloop",
    "dmg",
    "file",
    "ftp",
    "ftps",
    "gluster",
    "host_cdrom",
    "host_device",
    "http",
    "https",
    "iscsi",
    "luks",
    "nbd",
    "nfs",
    "null-aio",
    "null-co",
    "parallels",
    "qcow",
    "qcow2",
    "qed",
    "quorum",
    "raw",
    "rbd",
    "replication",
    "sheepdog",
    "ssh",
    "throttle",
    "vdi",
    "vhdx",
    "vmdk",
    "vpc",
    "vvfat",
    "vxhs"
  ]
}

##
# @BlockdevOptionsFile:
#
# Driver specific block device options for the file backend.
#
# @filename:    path to the image file
# @pr-manager:  the id for the object that will handle persistent reservations
#               for this device (default: none, forward the commands via SG_IO;
#               since 2.11)
# @aio:         AIO backend (default: threads) (since: 2.8)
# @locking:     whether to enable file locking. If set to 'auto', only enable
#               when Open File Descriptor (OFD) locking API is available
#               (default: auto, since 2.10)
#
# Since: 2.9
##
{
  "struct": "BlockdevOptionsFile",
  "data": {
    "filename": "str",
    "*pr-manager": "str",
    "*locking": "OnOffAuto",
    "*aio": "BlockdevAioOptions"
  }
}

##
# @BlockdevOptionsNull:
#
# Driver specific block device options for the null backend.
#
# @size:    size of the device in bytes.
# @latency-ns: emulated latency (in nanoseconds) in processing
#              requests. Default to zero which completes requests immediately.
#              (Since 2.4)
#
# Since: 2.9
##
{
  "struct": "BlockdevOptionsNull",
  "data": {
    "*size": "int",
    "*latency-ns": "uint64"
  }
}

##
# @BlockdevOptionsVVFAT:
#
# Driver specific block device options for the vvfat protocol.
#
# @dir:         directory to be exported as FAT image
# @fat-type:    FAT type: 12, 16 or 32
# @floppy:      whether to export a floppy image (true) or
#               partitioned hard disk (false; default)
# @label:       set the volume label, limited to 11 bytes. FAT16 and
#               FAT32 traditionally have some restrictions on labels, which are
#               ignored by most operating systems. Defaults to "QEMU VVFAT".
#               (since 2.4)
# @rw:          whether to allow write operations (default: false)
#
# Since: 2.9
##
{
  "struct": "BlockdevOptionsVVFAT",
  "data": {
    "dir": "str",
    "*fat-type": "int",
    "*floppy": "bool",
    "*label": "str",
    "*rw": "bool"
  }
}

##
# @BlockdevOptionsGenericFormat:
#
# Driver specific block device options for image format that have no option
# besides their data source.
#
# @file:        reference to or definition of the data source block device
#
# Since: 2.9
##
{
  "struct": "BlockdevOptionsGenericFormat",
  "data": {
    "file": "BlockdevRef"
  }
}

##
# @BlockdevOptionsLUKS:
#
# Driver specific block device options for LUKS.
#
# @key-secret: the ID of a QCryptoSecret object providing
#              the decryption key (since 2.6). Mandatory except when
#              doing a metadata-only probe of the image.
#
# Since: 2.9
##
{
  "struct": "BlockdevOptionsLUKS",
  "base": "BlockdevOptionsGenericFormat",
  "data": {
    "*key-secret": "str"
  }
}


##
# @BlockdevOptionsGenericCOWFormat:
#
# Driver specific block device options for image format that have no option
# besides their data source and an optional backing file.
#
# @backing:     reference to or definition of the backing file block
#               device, null disables the backing file entirely.
#               Defaults to the backing file stored the image file.
#
# Since: 2.9
##
{
  "struct": "BlockdevOptionsGenericCOWFormat",
  "base": "BlockdevOptionsGenericFormat",
  "data": {
    "*backing": "BlockdevRefOrNull"
  }
}

##
# @Qcow2OverlapCheckMode:
#
# General overlap check modes.
#
# @none:        Do not perform any checks
#
# @constant:    Perform only checks which can be done in constant time and
#               without reading anything from disk
#
# @cached:      Perform only checks which can be done without reading anything
#               from disk
#
# @all:         Perform all available overlap checks
#
# Since: 2.9
##
{
  "enum": "Qcow2OverlapCheckMode",
  "data": [
    "none",
    "constant",
    "cached",
    "all"
  ]
}

##
# @Qcow2OverlapCheckFlags:
#
# Structure of flags for each metadata structure. Setting a field to 'true'
# makes qemu guard that structure against unintended overwriting. The default
# value is chosen according to the template given.
#
# @template: Specifies a template mode which can be adjusted using the other
#            flags, defaults to 'cached'
#
# Since: 2.9
##
{
  "struct": "Qcow2OverlapCheckFlags",
  "data": {
    "*template": "Qcow2OverlapCheckMode",
    "*main-header": "bool",
    "*active-l1": "bool",
    "*active-l2": "bool",
    "*refcount-table": "bool",
    "*refcount-block": "bool",
    "*snapshot-table": "bool",
    "*inactive-l1": "bool",
    "*inactive-l2": "bool"
  }
}

##
# @Qcow2OverlapChecks:
#
# Specifies which metadata structures should be guarded against unintended
# overwriting.
#
# @flags:   set of flags for separate specification of each metadata structure
#           type
#
# @mode:    named mode which chooses a specific set of flags
#
# Since: 2.9
##
{
  "alternate": "Qcow2OverlapChecks",
  "data": {
    "flags": "Qcow2OverlapCheckFlags",
    "mode": "Qcow2OverlapCheckMode"
  }
}

##
# @BlockdevQcowEncryptionFormat:
#
# @aes: AES-CBC with plain64 initialization vectors
#
# Since: 2.10
##
{
  "enum": "BlockdevQcowEncryptionFormat",
  "data": [
    "aes"
  ]
}

##
# @BlockdevQcowEncryption:
#
# Since: 2.10
##
{
  "union": "BlockdevQcowEncryption",
  "base": {
    "format": "BlockdevQcowEncryptionFormat"
  },
  "discriminator": "format",
  "data": {
    "aes": "QCryptoBlockOptionsQCow"
  }
}

##
# @BlockdevOptionsQcow:
#
# Driver specific block device options for qcow.
#
# @encrypt:               Image decryption options. Mandatory for
#                         encrypted images, except when doing a metadata-only
#                         probe of the image.
#
# Since: 2.10
##
{
  "struct": "BlockdevOptionsQcow",
  "base": "BlockdevOptionsGenericCOWFormat",
  "data": {
    "*encrypt": "BlockdevQcowEncryption"
  }
}

##
# @BlockdevQcow2EncryptionFormat:
# @aes: AES-CBC with plain64 initialization venctors
#
# Since: 2.10
##
{
  "enum": "BlockdevQcow2EncryptionFormat",
  "data": [
    "aes",
    "luks"
  ]
}

##
# @BlockdevQcow2Encryption:
#
# Since: 2.10
##
{
  "union": "BlockdevQcow2Encryption",
  "base": {
    "format": "BlockdevQcow2EncryptionFormat"
  },
  "discriminator": "format",
  "data": {
    "aes": "QCryptoBlockOptionsQCow",
    "luks": "QCryptoBlockOptionsLUKS"
  }
}

##
# @BlockdevOptionsQcow2:
#
# Driver specific block device options for qcow2.
#
# @lazy-refcounts:        whether to enable the lazy refcounts
#                         feature (default is taken from the image file)
#
# @pass-discard-request:  whether discard requests to the qcow2
#                         device should be forwarded to the data source
#
# @pass-discard-snapshot: whether discard requests for the data source
#                         should be issued when a snapshot operation (e.g.
#                         deleting a snapshot) frees clusters in the qcow2 file
#
# @pass-discard-other:    whether discard requests for the data source
#                         should be issued on other occasions where a cluster
#                         gets freed
#
# @overlap-check:         which overlap checks to perform for writes
#                         to the image, defaults to 'cached' (since 2.2)
#
# @cache-size:            the maximum total size of the L2 table and
#                         refcount block caches in bytes (since 2.2)
#
# @l2-cache-size:         the maximum size of the L2 table cache in
#                         bytes (since 2.2)
#
# @refcount-cache-size:   the maximum size of the refcount block cache
#                         in bytes (since 2.2)
#
# @cache-clean-interval:  clean unused entries in the L2 and refcount
#                         caches. The interval is in seconds. The default value
#                         is 0 and it disables this feature (since 2.5)
# @encrypt:               Image decryption options. Mandatory for
#                         encrypted images, except when doing a metadata-only
#                         probe of the image. (since 2.10)
#
# Since: 2.9
##
{
  "struct": "BlockdevOptionsQcow2",
  "base": "BlockdevOptionsGenericCOWFormat",
  "data": {
    "*lazy-refcounts": "bool",
    "*pass-discard-request": "bool",
    "*pass-discard-snapshot": "bool",
    "*pass-discard-other": "bool",
    "*overlap-check": "Qcow2OverlapChecks",
    "*cache-size": "int",
    "*l2-cache-size": "int",
    "*refcount-cache-size": "int",
    "*cache-clean-interval": "int",
    "*encrypt": "BlockdevQcow2Encryption"
  }
}

##
# @BlockdevOptionsSsh:
#
# @server:              host address
#
# @path:                path to the image on the host
#
# @user:                user as which to connect, defaults to current
#                       local user name
#
# TODO: Expose the host_key_check option in QMP
#
# Since: 2.9
##
{
  "struct": "BlockdevOptionsSsh",
  "data": {
    "server": "InetSocketAddress",
    "path": "str",
    "*user": "str"
  }
}


##
# @BlkdebugEvent:
#
# Trigger events supported by blkdebug.
#
# @l1_shrink_write_table:      write zeros to the l1 table to shrink image.
#                              (since 2.11)
#
# @l1_shrink_free_l2_clusters: discard the l2 tables. (since 2.11)
#
# @cor_write: a write due to copy-on-read (since 2.11)
#
# Since: 2.9
##
{
  "enum": "BlkdebugEvent",
  "prefix": "BLKDBG",
  "data": [
    "l1_update",
    "l1_grow_alloc_table",
    "l1_grow_write_table",
    "l1_grow_activate_table",
    "l2_load",
    "l2_update",
    "l2_update_compressed",
    "l2_alloc_cow_read",
    "l2_alloc_write",
    "read_aio",
    "read_backing_aio",
    "read_compressed",
    "write_aio",
    "write_compressed",
    "vmstate_load",
    "vmstate_save",
    "cow_read",
    "cow_write",
    "reftable_load",
    "reftable_grow",
    "reftable_update",
    "refblock_load",
    "refblock_update",
    "refblock_update_part",
    "refblock_alloc",
    "refblock_alloc_hookup",
    "refblock_alloc_write",
    "refblock_alloc_write_blocks",
    "refblock_alloc_write_table",
    "refblock_alloc_switch_table",
    "cluster_alloc",
    "cluster_alloc_bytes",
    "cluster_free",
    "flush_to_os",
    "flush_to_disk",
    "pwritev_rmw_head",
    "pwritev_rmw_after_head",
    "pwritev_rmw_tail",
    "pwritev_rmw_after_tail",
    "pwritev",
    "pwritev_zero",
    "pwritev_done",
    "empty_image_prepare",
    "l1_shrink_write_table",
    "l1_shrink_free_l2_clusters",
    "cor_write"
  ]
}

##
# @BlkdebugInjectErrorOptions:
#
# Describes a single error injection for blkdebug.
#
# @event:       trigger event
#
# @state:       the state identifier blkdebug needs to be in to
#               actually trigger the event; defaults to "any"
#
# @errno:       error identifier (errno) to be returned; defaults to
#               EIO
#
# @sector:      specifies the sector index which has to be affected
#               in order to actually trigger the event; defaults to "any
#               sector"
#
# @once:        disables further events after this one has been
#               triggered; defaults to false
#
# @immediately: fail immediately; defaults to false
#
# Since: 2.9
##
{
  "struct": "BlkdebugInjectErrorOptions",
  "data": {
    "event": "BlkdebugEvent",
    "*state": "int",
    "*errno": "int",
    "*sector": "int",
    "*once": "bool",
    "*immediately": "bool"
  }
}

##
# @BlkdebugSetStateOptions:
#
# Describes a single state-change event for blkdebug.
#
# @event:       trigger event
#
# @state:       the current state identifier blkdebug needs to be in;
#               defaults to "any"
#
# @new_state:   the state identifier blkdebug is supposed to assume if
#               this event is triggered
#
# Since: 2.9
##
{
  "struct": "BlkdebugSetStateOptions",
  "data": {
    "event": "BlkdebugEvent",
    "*state": "int",
    "new_state": "int"
  }
}

##
# @BlockdevOptionsBlkdebug:
#
# Driver specific block device options for blkdebug.
#
# @image:           underlying raw block device (or image file)
#
# @config:          filename of the configuration file
#
# @align:           required alignment for requests in bytes, must be
#                   positive power of 2, or 0 for default
#
# @max-transfer:    maximum size for I/O transfers in bytes, must be
#                   positive multiple of @align and of the underlying
#                   file's request alignment (but need not be a power of
#                   2), or 0 for default (since 2.10)
#
# @opt-write-zero:  preferred alignment for write zero requests in bytes,
#                   must be positive multiple of @align and of the
#                   underlying file's request alignment (but need not be a
#                   power of 2), or 0 for default (since 2.10)
#
# @max-write-zero:  maximum size for write zero requests in bytes, must be
#                   positive multiple of @align, of @opt-write-zero, and of
#                   the underlying file's request alignment (but need not
#                   be a power of 2), or 0 for default (since 2.10)
#
# @opt-discard:     preferred alignment for discard requests in bytes, must
#                   be positive multiple of @align and of the underlying
#                   file's request alignment (but need not be a power of
#                   2), or 0 for default (since 2.10)
#
# @max-discard:     maximum size for discard requests in bytes, must be
#                   positive multiple of @align, of @opt-discard, and of
#                   the underlying file's request alignment (but need not
#                   be a power of 2), or 0 for default (since 2.10)
#
# @inject-error:    array of error injection descriptions
#
# @set-state:       array of state-change descriptions
#
# Since: 2.9
##
{
  "struct": "BlockdevOptionsBlkdebug",
  "data": {
    "image": "BlockdevRef",
    "*config": "str",
    "*align": "int",
    "*max-transfer": "int32",
    "*opt-write-zero": "int32",
    "*max-write-zero": "int32",
    "*opt-discard": "int32",
    "*max-discard": "int32",
    "*inject-error": [
      "BlkdebugInjectErrorOptions"
    ],
    "*set-state": [
      "BlkdebugSetStateOptions"
    ]
  }
}

##
# @BlockdevOptionsBlkverify:
#
# Driver specific block device options for blkverify.
#
# @test:    block device to be tested
#
# @raw:     raw image used for verification
#
# Since: 2.9
##
{
  "struct": "BlockdevOptionsBlkverify",
  "data": {
    "test": "BlockdevRef",
    "raw": "BlockdevRef"
  }
}

##
# @QuorumReadPattern:
#
# An enumeration of quorum read patterns.
#
# @quorum: read all the children and do a quorum vote on reads
#
# @fifo: read only from the first child that has not failed
#
# Since: 2.9
##
{
  "enum": "QuorumReadPattern",
  "data": [
    "quorum",
    "fifo"
  ]
}

##
# @BlockdevOptionsQuorum:
#
# Driver specific block device options for Quorum
#
# @blkverify:      true if the driver must print content mismatch
#                  set to false by default
#
# @children:       the children block devices to use
#
# @vote-threshold: the vote limit under which a read will fail
#
# @rewrite-corrupted: rewrite corrupted data when quorum is reached
#                     (Since 2.1)
#
# @read-pattern: choose read pattern and set to quorum by default
#                (Since 2.2)
#
# Since: 2.9
##
{
  "struct": "BlockdevOptionsQuorum",
  "data": {
    "*blkverify": "bool",
    "children": [
      "BlockdevRef"
    ],
    "vote-threshold": "int",
    "*rewrite-corrupted": "bool",
    "*read-pattern": "QuorumReadPattern"
  }
}

##
# @BlockdevOptionsGluster:
#
# Driver specific block device options for Gluster
#
# @volume:      name of gluster volume where VM image resides
#
# @path:        absolute path to image file in gluster volume
#
# @server:      gluster servers description
#
# @debug:       libgfapi log level (default '4' which is Error)
#               (Since 2.8)
#
# @logfile:     libgfapi log file (default /dev/stderr) (Since 2.8)
#
# Since: 2.9
##
{
  "struct": "BlockdevOptionsGluster",
  "data": {
    "volume": "str",
    "path": "str",
    "server": [
      "SocketAddress"
    ],
    "*debug": "int",
    "*logfile": "str"
  }
}

##
# @IscsiTransport:
#
# An enumeration of libiscsi transport types
#
# Since: 2.9
##
{
  "enum": "IscsiTransport",
  "data": [
    "tcp",
    "iser"
  ]
}

##
# @IscsiHeaderDigest:
#
# An enumeration of header digests supported by libiscsi
#
# Since: 2.9
##
{
  "enum": "IscsiHeaderDigest",
  "prefix": "QAPI_ISCSI_HEADER_DIGEST",
  "data": [
    "crc32c",
    "none",
    "crc32c-none",
    "none-crc32c"
  ]
}

##
# @BlockdevOptionsIscsi:
#
# @transport:       The iscsi transport type
#
# @portal:          The address of the iscsi portal
#
# @target:          The target iqn name
#
# @lun:             LUN to connect to. Defaults to 0.
#
# @user:            User name to log in with. If omitted, no CHAP
#                   authentication is performed.
#
# @password-secret: The ID of a QCryptoSecret object providing
#                   the password for the login. This option is required if
#                   @user is specified.
#
# @initiator-name:  The iqn name we want to identify to the target
#                   as. If this option is not specified, an initiator name is
#                   generated automatically.
#
# @header-digest:   The desired header digest. Defaults to
#                   none-crc32c.
#
# @timeout:         Timeout in seconds after which a request will
#                   timeout. 0 means no timeout and is the default.
#
# Driver specific block device options for iscsi
#
# Since: 2.9
##
{
  "struct": "BlockdevOptionsIscsi",
  "data": {
    "transport": "IscsiTransport",
    "portal": "str",
    "target": "str",
    "*lun": "int",
    "*user": "str",
    "*password-secret": "str",
    "*initiator-name": "str",
    "*header-digest": "IscsiHeaderDigest",
    "*timeout": "int"
  }
}


##
# @BlockdevOptionsRbd:
#
# @pool:               Ceph pool name.
#
# @image:              Image name in the Ceph pool.
#
# @conf:               path to Ceph configuration file.  Values
#                      in the configuration file will be overridden by
#                      options specified via QAPI.
#
# @snapshot:           Ceph snapshot name.
#
# @user:               Ceph id name.
#
# @server:             Monitor host address and port.  This maps
#                      to the "mon_host" Ceph option.
#
# Since: 2.9
##
{
  "struct": "BlockdevOptionsRbd",
  "data": {
    "pool": "str",
    "image": "str",
    "*conf": "str",
    "*snapshot": "str",
    "*user": "str",
    "*server": [
      "InetSocketAddressBase"
    ]
  }
}

##
# @BlockdevOptionsSheepdog:
#
# Driver specific block device options for sheepdog
#
# @vdi:         Virtual disk image name
# @server:      The Sheepdog server to connect to
# @snap-id:     Snapshot ID
# @tag:         Snapshot tag name
#
# Only one of @snap-id and @tag may be present.
#
# Since: 2.9
##
{
  "struct": "BlockdevOptionsSheepdog",
  "data": {
    "server": "SocketAddress",
    "vdi": "str",
    "*snap-id": "uint32",
    "*tag": "str"
  }
}

##
# @ReplicationMode:
#
# An enumeration of replication modes.
#
# @primary: Primary mode, the vm's state will be sent to secondary QEMU.
#
# @secondary: Secondary mode, receive the vm's state from primary QEMU.
#
# Since: 2.9
##
{
  "enum": "ReplicationMode",
  "data": [
    "primary",
    "secondary"
  ]
}

##
# @BlockdevOptionsReplication:
#
# Driver specific block device options for replication
#
# @mode: the replication mode
#
# @top-id: In secondary mode, node name or device ID of the root
#          node who owns the replication node chain. Must not be given in
#          primary mode.
#
# Since: 2.9
##
{
  "struct": "BlockdevOptionsReplication",
  "base": "BlockdevOptionsGenericFormat",
  "data": {
    "mode": "ReplicationMode",
    "*top-id": "str"
  }
}

##
# @NFSTransport:
#
# An enumeration of NFS transport types
#
# @inet:        TCP transport
#
# Since: 2.9
##
{
  "enum": "NFSTransport",
  "data": [
    "inet"
  ]
}

##
# @NFSServer:
#
# Captures the address of the socket
#
# @type:        transport type used for NFS (only TCP supported)
#
# @host:        host address for NFS server
#
# Since: 2.9
##
{
  "struct": "NFSServer",
  "data": {
    "type": "NFSTransport",
    "host": "str"
  }
}

##
# @BlockdevOptionsNfs:
#
# Driver specific block device option for NFS
#
# @server:                  host address
#
# @path:                    path of the image on the host
#
# @user:                    UID value to use when talking to the
#                           server (defaults to 65534 on Windows and getuid()
#                           on unix)
#
# @group:                   GID value to use when talking to the
#                           server (defaults to 65534 on Windows and getgid()
#                           in unix)
#
# @tcp-syn-count:           number of SYNs during the session
#                           establishment (defaults to libnfs default)
#
# @readahead-size:          set the readahead size in bytes (defaults
#                           to libnfs default)
#
# @page-cache-size:         set the pagecache size in bytes (defaults
#                           to libnfs default)
#
# @debug:                   set the NFS debug level (max 2) (defaults
#                           to libnfs default)
#
# Since: 2.9
##
{
  "struct": "BlockdevOptionsNfs",
  "data": {
    "server": "NFSServer",
    "path": "str",
    "*user": "int",
    "*group": "int",
    "*tcp-syn-count": "int",
    "*readahead-size": "int",
    "*page-cache-size": "int",
    "*debug": "int"
  }
}

##
# @BlockdevOptionsCurlBase:
#
# Driver specific block device options shared by all protocols supported by the
# curl backend.
#
# @url:                     URL of the image file
#
# @readahead:               Size of the read-ahead cache; must be a multiple of
#                           512 (defaults to 256 kB)
#
# @timeout:                 Timeout for connections, in seconds (defaults to 5)
#
# @username:                Username for authentication (defaults to none)
#
# @password-secret:         ID of a QCryptoSecret object providing a password
#                           for authentication (defaults to no password)
#
# @proxy-username:          Username for proxy authentication (defaults to none)
#
# @proxy-password-secret:   ID of a QCryptoSecret object providing a password
#                           for proxy authentication (defaults to no password)
#
# Since: 2.9
##
{
  "struct": "BlockdevOptionsCurlBase",
  "data": {
    "url": "str",
    "*readahead": "int",
    "*timeout": "int",
    "*username": "str",
    "*password-secret": "str",
    "*proxy-username": "str",
    "*proxy-password-secret": "str"
  }
}

##
# @BlockdevOptionsCurlHttp:
#
# Driver specific block device options for HTTP connections over the curl
# backend.  URLs must start with "http://".
#
# @cookie:      List of cookies to set; format is
#               "name1=content1; name2=content2;" as explained by
#               CURLOPT_COOKIE(3). Defaults to no cookies.
#
# @cookie-secret: ID of a QCryptoSecret object providing the cookie data in a
#                 secure way. See @cookie for the format. (since 2.10)
#
# Since: 2.9
##
{
  "struct": "BlockdevOptionsCurlHttp",
  "base": "BlockdevOptionsCurlBase",
  "data": {
    "*cookie": "str",
    "*cookie-secret": "str"
  }
}

##
# @BlockdevOptionsCurlHttps:
#
# Driver specific block device options for HTTPS connections over the curl
# backend.  URLs must start with "https://".
#
# @cookie:      List of cookies to set; format is
#               "name1=content1; name2=content2;" as explained by
#               CURLOPT_COOKIE(3). Defaults to no cookies.
#
# @sslverify:   Whether to verify the SSL certificate's validity (defaults to
#               true)
#
# @cookie-secret: ID of a QCryptoSecret object providing the cookie data in a
#                 secure way. See @cookie for the format. (since 2.10)
#
# Since: 2.9
##
{
  "struct": "BlockdevOptionsCurlHttps",
  "base": "BlockdevOptionsCurlBase",
  "data": {
    "*cookie": "str",
    "*sslverify": "bool",
    "*cookie-secret": "str"
  }
}

##
# @BlockdevOptionsCurlFtp:
#
# Driver specific block device options for FTP connections over the curl
# backend.  URLs must start with "ftp://".
#
# Since: 2.9
##
{
  "struct": "BlockdevOptionsCurlFtp",
  "base": "BlockdevOptionsCurlBase",
  "data": {}
}

##
# @BlockdevOptionsCurlFtps:
#
# Driver specific block device options for FTPS connections over the curl
# backend.  URLs must start with "ftps://".
#
# @sslverify:   Whether to verify the SSL certificate's validity (defaults to
#               true)
#
# Since: 2.9
##
{
  "struct": "BlockdevOptionsCurlFtps",
  "base": "BlockdevOptionsCurlBase",
  "data": {
    "*sslverify": "bool"
  }
}

##
# @BlockdevOptionsNbd:
#
# Driver specific block device options for NBD.
#
# @server:      NBD server address
#
# @export:      export name
#
# @tls-creds:   TLS credentials ID
#
# Since: 2.9
##
{
  "struct": "BlockdevOptionsNbd",
  "data": {
    "server": "SocketAddress",
    "*export": "str",
    "*tls-creds": "str"
  }
}

##
# @BlockdevOptionsRaw:
#
# Driver specific block device options for the raw driver.
#
# @offset:      position where the block device starts
# @size:        the assumed size of the device
#
# Since: 2.9
##
{
  "struct": "BlockdevOptionsRaw",
  "base": "BlockdevOptionsGenericFormat",
  "data": {
    "*offset": "int",
    "*size": "int"
  }
}

##
# @BlockdevOptionsVxHS:
#
# Driver specific block device options for VxHS
#
# @vdisk-id:    UUID of VxHS volume
# @server:      vxhs server IP, port
# @tls-creds:   TLS credentials ID
#
# Since: 2.10
##
{
  "struct": "BlockdevOptionsVxHS",
  "data": {
    "vdisk-id": "str",
    "server": "InetSocketAddressBase",
    "*tls-creds": "str"
  }
}

##
# @BlockdevOptionsThrottle:
#
# Driver specific block device options for the throttle driver
#
# @throttle-group:   the name of the throttle-group object to use. It
#                    must already exist.
# @file:             reference to or definition of the data source block device
# Since: 2.11
##
{
  "struct": "BlockdevOptionsThrottle",
  "data": {
    "throttle-group": "str",
    "file": "BlockdevRef"
  }
}

##
# @BlockdevOptions:
#
# Options for creating a block device.  Many options are available for all
# block devices, independent of the block driver:
#
# @driver:        block driver name
# @node-name:     the node name of the new node (Since 2.0).
#                 This option is required on the top level of blockdev-add.
# @discard:       discard-related options (default: ignore)
# @cache:         cache-related options
# @read-only:     whether the block device should be read-only (default: false).
#                 Note that some block drivers support only read-only access,
#                 either generally or in certain configurations. In this case,
#                 the default value does not work and the option must be
#                 specified explicitly.
# @detect-zeroes: detect and optimize zero writes (Since 2.1)
#                 (default: off)
# @force-share:   force share all permission on added nodes.
#                 Requires read-only=true. (Since 2.10)
#
# Remaining options are determined by the block driver.
#
# Since: 2.9
##
{
  "union": "BlockdevOptions",
  "base": {
    "driver": "BlockdevDriver",
    "*node-name": "str",
    "*discard": "BlockdevDiscardOptions",
    "*cache": "BlockdevCacheOptions",
    "*read-only": "bool",
    "*force-share": "bool",
    "*detect-zeroes": "BlockdevDetectZeroesOptions"
  },
  "discriminator": "driver",
  "data": {
    "blkdebug": "BlockdevOptionsBlkdebug",
    "blkverify": "BlockdevOptionsBlkverify",
    "bochs": "BlockdevOptionsGenericFormat",
    "cloop": "BlockdevOptionsGenericFormat",
    "dmg": "BlockdevOptionsGenericFormat",
    "file": "BlockdevOptionsFile",
    "ftp": "BlockdevOptionsCurlFtp",
    "ftps": "BlockdevOptionsCurlFtps",
    "gluster": "BlockdevOptionsGluster",
    "host_cdrom": "BlockdevOptionsFile",
    "host_device": "BlockdevOptionsFile",
    "http": "BlockdevOptionsCurlHttp",
    "https": "BlockdevOptionsCurlHttps",
    "iscsi": "BlockdevOptionsIscsi",
    "luks": "BlockdevOptionsLUKS",
    "nbd": "BlockdevOptionsNbd",
    "nfs": "BlockdevOptionsNfs",
    "null-aio": "BlockdevOptionsNull",
    "null-co": "BlockdevOptionsNull",
    "parallels": "BlockdevOptionsGenericFormat",
    "qcow2": "BlockdevOptionsQcow2",
    "qcow": "BlockdevOptionsQcow",
    "qed": "BlockdevOptionsGenericCOWFormat",
    "quorum": "BlockdevOptionsQuorum",
    "raw": "BlockdevOptionsRaw",
    "rbd": "BlockdevOptionsRbd",
    "replication": "BlockdevOptionsReplication",
    "sheepdog": "BlockdevOptionsSheepdog",
    "ssh": "BlockdevOptionsSsh",
    "throttle": "BlockdevOptionsThrottle",
    "vdi": "BlockdevOptionsGenericFormat",
    "vhdx": "BlockdevOptionsGenericFormat",
    "vmdk": "BlockdevOptionsGenericCOWFormat",
    "vpc": "BlockdevOptionsGenericFormat",
    "vvfat": "BlockdevOptionsVVFAT",
    "vxhs": "BlockdevOptionsVxHS"
  }
}

##
# @BlockdevRef:
#
# Reference to a block device.
#
# @definition:      defines a new block device inline
# @reference:       references the ID of an existing block device
#
# Since: 2.9
##
{
  "alternate": "BlockdevRef",
  "data": {
    "definition": "BlockdevOptions",
    "reference": "str"
  }
}

##
# @BlockdevRefOrNull:
#
# Reference to a block device.
#
# @definition:      defines a new block device inline
# @reference:       references the ID of an existing block device.
#                   An empty string means that no block device should
#                   be referenced.  Deprecated; use null instead.
# @null:            No block device should be referenced (since 2.10)
#
# Since: 2.9
##
{
  "alternate": "BlockdevRefOrNull",
  "data": {
    "definition": "BlockdevOptions",
    "reference": "str",
    "null": "null"
  }
}

##
# @blockdev-add:
#
# Creates a new block device. If the @id option is given at the top level, a
# BlockBackend will be created; otherwise, @node-name is mandatory at the top
# level and no BlockBackend will be created.
#
# Since: 2.9
#
# Example:
#
# 1.
# -> { "execute": "blockdev-add",
#      "arguments": {
#           "driver": "qcow2",
#           "node-name": "test1",
#           "file": {
#               "driver": "file",
#               "filename": "test.qcow2"
#            }
#       }
#     }
# <- { "return": {} }
#
# 2.
# -> { "execute": "blockdev-add",
#      "arguments": {
#           "driver": "qcow2",
#           "node-name": "node0",
#           "discard": "unmap",
#           "cache": {
#              "direct": true
#            },
#            "file": {
#              "driver": "file",
#              "filename": "/tmp/test.qcow2"
#            },
#            "backing": {
#               "driver": "raw",
#               "file": {
#                  "driver": "file",
#                  "filename": "/dev/fdset/4"
#                }
#            }
#        }
#      }
#
# <- { "return": {} }
#
##
{
  "command": "blockdev-add",
  "data": "BlockdevOptions",
  "boxed": true
}

##
# @blockdev-del:
#
# Deletes a block device that has been added using blockdev-add.
# The command will fail if the node is attached to a device or is
# otherwise being used.
#
# @node-name: Name of the graph node to delete.
#
# Since: 2.9
#
# Example:
#
# -> { "execute": "blockdev-add",
#      "arguments": {
#           "driver": "qcow2",
#           "node-name": "node0",
#           "file": {
#               "driver": "file",
#               "filename": "test.qcow2"
#           }
#      }
#    }
# <- { "return": {} }
#
# -> { "execute": "blockdev-del",
#      "arguments": { "node-name": "node0" }
#    }
# <- { "return": {} }
#
##
{
  "command": "blockdev-del",
  "data": {
    "node-name": "str"
  }
}

##
# @blockdev-open-tray:
#
# Opens a block device's tray. If there is a block driver state tree inserted as
# a medium, it will become inaccessible to the guest (but it will remain
# associated to the block device, so closing the tray will make it accessible
# again).
#
# If the tray was already open before, this will be a no-op.
#
# Once the tray opens, a DEVICE_TRAY_MOVED event is emitted. There are cases in
# which no such event will be generated, these include:
# - if the guest has locked the tray, @force is false and the guest does not
#   respond to the eject request
# - if the BlockBackend denoted by @device does not have a guest device attached
#   to it
# - if the guest device does not have an actual tray
#
# @device: Block device name (deprecated, use @id instead)
#
# @id:     The name or QOM path of the guest device (since: 2.8)
#
# @force:  if false (the default), an eject request will be sent to
#          the guest if it has locked the tray (and the tray will not be opened
#          immediately); if true, the tray will be opened regardless of whether
#          it is locked
#
# Since: 2.5
#
# Example:
#
# -> { "execute": "blockdev-open-tray",
#      "arguments": { "id": "ide0-1-0" } }
#
# <- { "timestamp": { "seconds": 1418751016,
#                     "microseconds": 716996 },
#      "event": "DEVICE_TRAY_MOVED",
#      "data": { "device": "ide1-cd0",
#                "id": "ide0-1-0",
#                "tray-open": true } }
#
# <- { "return": {} }
#
##
{
  "command": "blockdev-open-tray",
  "data": {
    "*device": "str",
    "*id": "str",
    "*force": "bool"
  }
}

##
# @blockdev-close-tray:
#
# Closes a block device's tray. If there is a block driver state tree associated
# with the block device (which is currently ejected), that tree will be loaded
# as the medium.
#
# If the tray was already closed before, this will be a no-op.
#
# @device:  Block device name (deprecated, use @id instead)
#
# @id:      The name or QOM path of the guest device (since: 2.8)
#
# Since: 2.5
#
# Example:
#
# -> { "execute": "blockdev-close-tray",
#      "arguments": { "id": "ide0-1-0" } }
#
# <- { "timestamp": { "seconds": 1418751345,
#                     "microseconds": 272147 },
#      "event": "DEVICE_TRAY_MOVED",
#      "data": { "device": "ide1-cd0",
#                "id": "ide0-1-0",
#                "tray-open": false } }
#
# <- { "return": {} }
#
##
{
  "command": "blockdev-close-tray",
  "data": {
    "*device": "str",
    "*id": "str"
  }
}

##
# @x-blockdev-remove-medium:
#
# Removes a medium (a block driver state tree) from a block device. That block
# device's tray must currently be open (unless there is no attached guest
# device).
#
# If the tray is open and there is no medium inserted, this will be a no-op.
#
# @device: Block device name (deprecated, use @id instead)
#
# @id:     The name or QOM path of the guest device (since: 2.8)
#
# Note: This command is still a work in progress and is considered experimental.
# Stay away from it unless you want to help with its development.
#
# Since: 2.5
#
# Example:
#
# -> { "execute": "x-blockdev-remove-medium",
#      "arguments": { "id": "ide0-1-0" } }
#
# <- { "error": { "class": "GenericError",
#                 "desc": "Tray of device 'ide0-1-0' is not open" } }
#
# -> { "execute": "blockdev-open-tray",
#      "arguments": { "id": "ide0-1-0" } }
#
# <- { "timestamp": { "seconds": 1418751627,
#                     "microseconds": 549958 },
#      "event": "DEVICE_TRAY_MOVED",
#      "data": { "device": "ide1-cd0",
#                "id": "ide0-1-0",
#                "tray-open": true } }
#
# <- { "return": {} }
#
# -> { "execute": "x-blockdev-remove-medium",
#      "arguments": { "id": "ide0-1-0" } }
#
# <- { "return": {} }
#
##
{
  "command": "x-blockdev-remove-medium",
  "data": {
    "*device": "str",
    "*id": "str"
  }
}

##
# @x-blockdev-insert-medium:
#
# Inserts a medium (a block driver state tree) into a block device. That block
# device's tray must currently be open (unless there is no attached guest
# device) and there must be no medium inserted already.
#
# @device:    Block device name (deprecated, use @id instead)
#
# @id:        The name or QOM path of the guest device (since: 2.8)
#
# @node-name: name of a node in the block driver state graph
#
# Note: This command is still a work in progress and is considered experimental.
# Stay away from it unless you want to help with its development.
#
# Since: 2.5
#
# Example:
#
# -> { "execute": "blockdev-add",
#      "arguments": {
#          "node-name": "node0",
#          "driver": "raw",
#          "file": { "driver": "file",
#                    "filename": "fedora.iso" } } }
# <- { "return": {} }
#
# -> { "execute": "x-blockdev-insert-medium",
#      "arguments": { "id": "ide0-1-0",
#                     "node-name": "node0" } }
#
# <- { "return": {} }
#
##
{
  "command": "x-blockdev-insert-medium",
  "data": {
    "*device": "str",
    "*id": "str",
    "node-name": "str"
  }
}


##
# @BlockdevChangeReadOnlyMode:
#
# Specifies the new read-only mode of a block device subject to the
# @blockdev-change-medium command.
#
# @retain:      Retains the current read-only mode
#
# @read-only:   Makes the device read-only
#
# @read-write:  Makes the device writable
#
# Since: 2.3
#
##
{
  "enum": "BlockdevChangeReadOnlyMode",
  "data": [
    "retain",
    "read-only",
    "read-write"
  ]
}


##
# @blockdev-change-medium:
#
# Changes the medium inserted into a block device by ejecting the current medium
# and loading a new image file which is inserted as the new medium (this command
# combines blockdev-open-tray, x-blockdev-remove-medium,
# x-blockdev-insert-medium and blockdev-close-tray).
#
# @device:          Block device name (deprecated, use @id instead)
#
# @id:              The name or QOM path of the guest device
#                   (since: 2.8)
#
# @filename:        filename of the new image to be loaded
#
# @format:          format to open the new image with (defaults to
#                   the probed format)
#
# @read-only-mode:  change the read-only mode of the device; defaults
#                   to 'retain'
#
# Since: 2.5
#
# Examples:
#
# 1. Change a removable medium
#
# -> { "execute": "blockdev-change-medium",
#      "arguments": { "id": "ide0-1-0",
#                     "filename": "/srv/images/Fedora-12-x86_64-DVD.iso",
#                     "format": "raw" } }
# <- { "return": {} }
#
# 2. Load a read-only medium into a writable drive
#
# -> { "execute": "blockdev-change-medium",
#      "arguments": { "id": "floppyA",
#                     "filename": "/srv/images/ro.img",
#                     "format": "raw",
#                     "read-only-mode": "retain" } }
#
# <- { "error":
#      { "class": "GenericError",
#        "desc": "Could not open '/srv/images/ro.img': Permission denied" } }
#
# -> { "execute": "blockdev-change-medium",
#      "arguments": { "id": "floppyA",
#                     "filename": "/srv/images/ro.img",
#                     "format": "raw",
#                     "read-only-mode": "read-only" } }
#
# <- { "return": {} }
#
##
{
  "command": "blockdev-change-medium",
  "data": {
    "*device": "str",
    "*id": "str",
    "filename": "str",
    "*format": "str",
    "*read-only-mode": "BlockdevChangeReadOnlyMode"
  }
}


##
# @BlockErrorAction:
#
# An enumeration of action that has been taken when a DISK I/O occurs
#
# @ignore: error has been ignored
#
# @report: error has been reported to the device
#
# @stop: error caused VM to be stopped
#
# Since: 2.1
##
{
  "enum": "BlockErrorAction",
  "data": [
    "ignore",
    "report",
    "stop"
  ]
}


##
# @BLOCK_IMAGE_CORRUPTED:
#
# Emitted when a disk image is being marked corrupt. The image can be
# identified by its device or node name. The 'device' field is always
# present for compatibility reasons, but it can be empty ("") if the
# image does not have a device name associated.
#
# @device: device name. This is always present for compatibility
#          reasons, but it can be empty ("") if the image does not
#          have a device name associated.
#
# @node-name: node name (Since: 2.4)
#
# @msg: informative message for human consumption, such as the kind of
#       corruption being detected. It should not be parsed by machine as it is
#       not guaranteed to be stable
#
# @offset: if the corruption resulted from an image access, this is
#          the host's access offset into the image
#
# @size: if the corruption resulted from an image access, this is
#        the access size
#
# @fatal: if set, the image is marked corrupt and therefore unusable after this
#        event and must be repaired (Since 2.2; before, every
#        BLOCK_IMAGE_CORRUPTED event was fatal)
#
# Note: If action is "stop", a STOP event will eventually follow the
#       BLOCK_IO_ERROR event.
#
# Example:
#
# <- { "event": "BLOCK_IMAGE_CORRUPTED",
#      "data": { "device": "ide0-hd0", "node-name": "node0",
#                "msg": "Prevented active L1 table overwrite", "offset": 196608,
#                "size": 65536 },
#      "timestamp": { "seconds": 1378126126, "microseconds": 966463 } }
#
# Since: 1.7
##
{
  "event": "BLOCK_IMAGE_CORRUPTED",
  "data": {
    "device": "str",
    "*node-name": "str",
    "msg": "str",
    "*offset": "int",
    "*size": "int",
    "fatal": "bool"
  }
}

##
# @BLOCK_IO_ERROR:
#
# Emitted when a disk I/O error occurs
#
# @device: device name. This is always present for compatibility
#          reasons, but it can be empty ("") if the image does not
#          have a device name associated.
#
# @node-name: node name. Note that errors may be reported for the root node
#             that is directly attached to a guest device rather than for the
#             node where the error occurred. (Since: 2.8)
#
# @operation: I/O operation
#
# @action: action that has been taken
#
# @nospace: true if I/O error was caused due to a no-space
#           condition. This key is only present if query-block's
#           io-status is present, please see query-block documentation
#           for more information (since: 2.2)
#
# @reason: human readable string describing the error cause.
#          (This field is a debugging aid for humans, it should not
#           be parsed by applications) (since: 2.2)
#
# Note: If action is "stop", a STOP event will eventually follow the
# BLOCK_IO_ERROR event
#
# Since: 0.13.0
#
# Example:
#
# <- { "event": "BLOCK_IO_ERROR",
#      "data": { "device": "ide0-hd1",
#                "node-name": "#block212",
#                "operation": "write",
#                "action": "stop" },
#      "timestamp": { "seconds": 1265044230, "microseconds": 450486 } }
#
##
{
  "event": "BLOCK_IO_ERROR",
  "data": {
    "device": "str",
    "node-name": "str",
    "operation": "IoOperationType",
    "action": "BlockErrorAction",
    "*nospace": "bool",
    "reason": "str"
  }
}

##
# @BLOCK_JOB_COMPLETED:
#
# Emitted when a block job has completed
#
# @type: job type
#
# @device: The job identifier. Originally the device name but other
#          values are allowed since QEMU 2.7
#
# @len: maximum progress value
#
# @offset: current progress value. On success this is equal to len.
#          On failure this is less than len
#
# @speed: rate limit, bytes per second
#
# @error: error message. Only present on failure. This field
#         contains a human-readable error message. There are no semantics
#         other than that streaming has failed and clients should not try to
#         interpret the error string
#
# Since: 1.1
#
# Example:
#
# <- { "event": "BLOCK_JOB_COMPLETED",
#      "data": { "type": "stream", "device": "virtio-disk0",
#                "len": 10737418240, "offset": 10737418240,
#                "speed": 0 },
#      "timestamp": { "seconds": 1267061043, "microseconds": 959568 } }
#
##
{
  "event": "BLOCK_JOB_COMPLETED",
  "data": {
    "type": "BlockJobType",
    "device": "str",
    "len": "int",
    "offset": "int",
    "speed": "int",
    "*error": "str"
  }
}

##
# @BLOCK_JOB_CANCELLED:
#
# Emitted when a block job has been cancelled
#
# @type: job type
#
# @device: The job identifier. Originally the device name but other
#          values are allowed since QEMU 2.7
#
# @len: maximum progress value
#
# @offset: current progress value. On success this is equal to len.
#          On failure this is less than len
#
# @speed: rate limit, bytes per second
#
# Since: 1.1
#
# Example:
#
# <- { "event": "BLOCK_JOB_CANCELLED",
#      "data": { "type": "stream", "device": "virtio-disk0",
#                "len": 10737418240, "offset": 134217728,
#                "speed": 0 },
#      "timestamp": { "seconds": 1267061043, "microseconds": 959568 } }
#
##
{
  "event": "BLOCK_JOB_CANCELLED",
  "data": {
    "type": "BlockJobType",
    "device": "str",
    "len": "int",
    "offset": "int",
    "speed": "int"
  }
}

##
# @BLOCK_JOB_ERROR:
#
# Emitted when a block job encounters an error
#
# @device: The job identifier. Originally the device name but other
#          values are allowed since QEMU 2.7
#
# @operation: I/O operation
#
# @action: action that has been taken
#
# Since: 1.3
#
# Example:
#
# <- { "event": "BLOCK_JOB_ERROR",
#      "data": { "device": "ide0-hd1",
#                "operation": "write",
#                "action": "stop" },
#      "timestamp": { "seconds": 1265044230, "microseconds": 450486 } }
#
##
{
  "event": "BLOCK_JOB_ERROR",
  "data": {
    "device": "str",
    "operation": "IoOperationType",
    "action": "BlockErrorAction"
  }
}

##
# @BLOCK_JOB_READY:
#
# Emitted when a block job is ready to complete
#
# @type: job type
#
# @device: The job identifier. Originally the device name but other
#          values are allowed since QEMU 2.7
#
# @len: maximum progress value
#
# @offset: current progress value. On success this is equal to len.
#          On failure this is less than len
#
# @speed: rate limit, bytes per second
#
# Note: The "ready to complete" status is always reset by a @BLOCK_JOB_ERROR
# event
#
# Since: 1.3
#
# Example:
#
# <- { "event": "BLOCK_JOB_READY",
#      "data": { "device": "drive0", "type": "mirror", "speed": 0,
#                "len": 2097152, "offset": 2097152 }
#      "timestamp": { "seconds": 1265044230, "microseconds": 450486 } }
#
##
{
  "event": "BLOCK_JOB_READY",
  "data": {
    "type": "BlockJobType",
    "device": "str",
    "len": "int",
    "offset": "int",
    "speed": "int"
  }
}

##
# @PreallocMode:
#
# Preallocation mode of QEMU image file
#
# @off: no preallocation
# @metadata: preallocate only for metadata
# @falloc: like @full preallocation but allocate disk space by
#          posix_fallocate() rather than writing zeros.
# @full: preallocate all data by writing zeros to device to ensure disk
#        space is really available. @full preallocation also sets up
#        metadata correctly.
#
# Since: 2.2
##
{
  "enum": "PreallocMode",
  "data": [
    "off",
    "metadata",
    "falloc",
    "full"
  ]
}

##
# @BLOCK_WRITE_THRESHOLD:
#
# Emitted when writes on block device reaches or exceeds the
# configured write threshold. For thin-provisioned devices, this
# means the device should be extended to avoid pausing for
# disk exhaustion.
# The event is one shot. Once triggered, it needs to be
# re-registered with another block-set-write-threshold command.
#
# @node-name: graph node name on which the threshold was exceeded.
#
# @amount-exceeded: amount of data which exceeded the threshold, in bytes.
#
# @write-threshold: last configured threshold, in bytes.
#
# Since: 2.3
##
{
  "event": "BLOCK_WRITE_THRESHOLD",
  "data": {
    "node-name": "str",
    "amount-exceeded": "uint64",
    "write-threshold": "uint64"
  }
}

##
# @block-set-write-threshold:
#
# Change the write threshold for a block drive. An event will be
# delivered if a write to this block drive crosses the configured
# threshold.  The threshold is an offset, thus must be
# non-negative. Default is no write threshold. Setting the threshold
# to zero disables it.
#
# This is useful to transparently resize thin-provisioned drives without
# the guest OS noticing.
#
# @node-name: graph node name on which the threshold must be set.
#
# @write-threshold: configured threshold for the block device, bytes.
#                   Use 0 to disable the threshold.
#
# Since: 2.3
#
# Example:
#
# -> { "execute": "block-set-write-threshold",
#      "arguments": { "node-name": "mydev",
#                     "write-threshold": 17179869184 } }
# <- { "return": {} }
#
##
{
  "command": "block-set-write-threshold",
  "data": {
    "node-name": "str",
    "write-threshold": "uint64"
  }
}

##
# @x-blockdev-change:
#
# Dynamically reconfigure the block driver state graph. It can be used
# to add, remove, insert or replace a graph node. Currently only the
# Quorum driver implements this feature to add or remove its child. This
# is useful to fix a broken quorum child.
#
# If @node is specified, it will be inserted under @parent. @child
# may not be specified in this case. If both @parent and @child are
# specified but @node is not, @child will be detached from @parent.
#
# @parent: the id or name of the parent node.
#
# @child: the name of a child under the given parent node.
#
# @node: the name of the node that will be added.
#
# Note: this command is experimental, and its API is not stable. It
# does not support all kinds of operations, all kinds of children, nor
# all block drivers.
#
# Warning: The data in a new quorum child MUST be consistent with that of
# the rest of the array.
#
# Since: 2.7
#
# Example:
#
# 1. Add a new node to a quorum
# -> { "execute": "blockdev-add",
#      "arguments": {
#          "driver": "raw",
#          "node-name": "new_node",
#          "file": { "driver": "file",
#                    "filename": "test.raw" } } }
# <- { "return": {} }
# -> { "execute": "x-blockdev-change",
#      "arguments": { "parent": "disk1",
#                     "node": "new_node" } }
# <- { "return": {} }
#
# 2. Delete a quorum's node
# -> { "execute": "x-blockdev-change",
#      "arguments": { "parent": "disk1",
#                     "child": "children.1" } }
# <- { "return": {} }
#
##
{
  "command": "x-blockdev-change",
  "data": {
    "parent": "str",
    "*child": "str",
    "*node": "str"
  }
}


##
# @BiosAtaTranslation:
#
# Policy that BIOS should use to interpret cylinder/head/sector
# addresses.  Note that Bochs BIOS and SeaBIOS will not actually
# translate logical CHS to physical; instead, they will use logical
# block addressing.
#
# @auto: If cylinder/heads/sizes are passed, choose between none and LBA
#        depending on the size of the disk.  If they are not passed,
#        choose none if QEMU can guess that the disk had 16 or fewer
#        heads, large if QEMU can guess that the disk had 131072 or
#        fewer tracks across all heads (i.e. cylinders*heads<131072),
#        otherwise LBA.
#
# @none: The physical disk geometry is equal to the logical geometry.
#
# @lba: Assume 63 sectors per track and one of 16, 32, 64, 128 or 255
#       heads (if fewer than 255 are enough to cover the whole disk
#       with 1024 cylinders/head).  The number of cylinders/head is
#       then computed based on the number of sectors and heads.
#
# @large: The number of cylinders per head is scaled down to 1024
#         by correspondingly scaling up the number of heads.
#
# @rechs: Same as @large, but first convert a 16-head geometry to
#         15-head, by proportionally scaling up the number of
#         cylinders/head.
#
# Since: 2.0
##
{
  "enum": "BiosAtaTranslation",
  "data": [
    "auto",
    "none",
    "lba",
    "large",
    "rechs"
  ]
}

##
# @FloppyDriveType:
#
# Type of Floppy drive to be emulated by the Floppy Disk Controller.
#
# @144:  1.44MB 3.5" drive
# @288:  2.88MB 3.5" drive
# @120:  1.2MB 5.25" drive
# @none: No drive connected
# @auto: Automatically determined by inserted media at boot
#
# Since: 2.6
##
{
  "enum": "FloppyDriveType",
  "data": [
    "144",
    "288",
    "120",
    "none",
    "auto"
  ]
}

##
# @BlockdevSnapshotInternal:
#
# @device: the device name or node-name of a root node to generate the snapshot
#          from
#
# @name: the name of the internal snapshot to be created
#
# Notes: In transaction, if @name is empty, or any snapshot matching @name
#        exists, the operation will fail. Only some image formats support it,
#        for example, qcow2, rbd, and sheepdog.
#
# Since: 1.7
##
{
  "struct": "BlockdevSnapshotInternal",
  "data": {
    "device": "str",
    "name": "str"
  }
}

##
# @blockdev-snapshot-internal-sync:
#
# Synchronously take an internal snapshot of a block device, when the
# format of the image used supports it. If the name is an empty
# string, or a snapshot with name already exists, the operation will
# fail.
#
# For the arguments, see the documentation of BlockdevSnapshotInternal.
#
# Returns: nothing on success
#
#          If @device is not a valid block device, GenericError
#
#          If any snapshot matching @name exists, or @name is empty,
#          GenericError
#
#          If the format of the image used does not support it,
#          BlockFormatFeatureNotSupported
#
# Since: 1.7
#
# Example:
#
# -> { "execute": "blockdev-snapshot-internal-sync",
#      "arguments": { "device": "ide-hd0",
#                     "name": "snapshot0" }
#    }
# <- { "return": {} }
#
##
{
  "command": "blockdev-snapshot-internal-sync",
  "data": "BlockdevSnapshotInternal"
}

##
# @blockdev-snapshot-delete-internal-sync:
#
# Synchronously delete an internal snapshot of a block device, when the format
# of the image used support it. The snapshot is identified by name or id or
# both. One of the name or id is required. Return SnapshotInfo for the
# successfully deleted snapshot.
#
# @device: the device name or node-name of a root node to delete the snapshot
#          from
#
# @id: optional the snapshot's ID to be deleted
#
# @name: optional the snapshot's name to be deleted
#
# Returns: SnapshotInfo on success
#          If @device is not a valid block device, GenericError
#          If snapshot not found, GenericError
#          If the format of the image used does not support it,
#          BlockFormatFeatureNotSupported
#          If @id and @name are both not specified, GenericError
#
# Since: 1.7
#
# Example:
#
# -> { "execute": "blockdev-snapshot-delete-internal-sync",
#      "arguments": { "device": "ide-hd0",
#                     "name": "snapshot0" }
#    }
# <- { "return": {
#                    "id": "1",
#                    "name": "snapshot0",
#                    "vm-state-size": 0,
#                    "date-sec": 1000012,
#                    "date-nsec": 10,
#                    "vm-clock-sec": 100,
#                    "vm-clock-nsec": 20
#      }
#    }
#
##
{
  "command": "blockdev-snapshot-delete-internal-sync",
  "data": {
    "device": "str",
    "*id": "str",
    "*name": "str"
  },
  "returns": "SnapshotInfo"
}

##
{
  "command": "eject",
  "data": {
    "*device": "str",
    "*id": "str",
    "*force": "bool"
  }
}

##
# @nbd-server-start:
#
# Start an NBD server listening on the given host and port.  Block
# devices can then be exported using @nbd-server-add.  The NBD
# server will present them as named exports; for example, another
# QEMU instance could refer to them as "nbd:HOST:PORT:exportname=NAME".
#
# @addr: Address on which to listen.
# @tls-creds: (optional) ID of the TLS credentials object. Since 2.6
#
# Returns: error if the server is already running.
#
# Since: 1.3.0
##
{
  "command": "nbd-server-start",
  "data": {
    "addr": "SocketAddressLegacy",
    "*tls-creds": "str"
  }
}

##
# @nbd-server-add:
#
# Export a block node to QEMU's embedded NBD server.
#
# @device: The device name or node name of the node to be exported
#
# @writable: Whether clients should be able to write to the device via the
#     NBD connection (default false).
#
# Returns: error if the device is already marked for export.
#
# Since: 1.3.0
##
{
  "command": "nbd-server-add",
  "data": {
    "device": "str",
    "*writable": "bool"
  }
}

##
# @nbd-server-stop:
#
# Stop QEMU's embedded NBD server, and unregister all devices previously
# added via @nbd-server-add.
#
# Since: 1.3.0
##
{
  "command": "nbd-server-stop"
}

##
# @DEVICE_TRAY_MOVED:
#
# Emitted whenever the tray of a removable device is moved by the guest or by
# HMP/QMP commands
#
# @device: Block device name. This is always present for compatibility
#          reasons, but it can be empty ("") if the image does not
#          have a device name associated.
#
# @id: The name or QOM path of the guest device (since 2.8)
#
# @tray-open: true if the tray has been opened or false if it has been closed
#
# Since: 1.1
#
# Example:
#
# <- { "event": "DEVICE_TRAY_MOVED",
#      "data": { "device": "ide1-cd0",
#                "id": "/machine/unattached/device[22]",
#                "tray-open": true
#      },
#      "timestamp": { "seconds": 1265044230, "microseconds": 450486 } }
#
##
{
  "event": "DEVICE_TRAY_MOVED",
  "data": {
    "device": "str",
    "id": "str",
    "tray-open": "bool"
  }
}

##
# @QuorumOpType:
#
# An enumeration of the quorum operation types
#
# @read: read operation
#
# @write: write operation
#
# @flush: flush operation
#
# Since: 2.6
##
{
  "enum": "QuorumOpType",
  "data": [
    "read",
    "write",
    "flush"
  ]
}

##
# @QUORUM_FAILURE:
#
# Emitted by the Quorum block driver if it fails to establish a quorum
#
# @reference: device name if defined else node name
#
# @sector-num: number of the first sector of the failed read operation
#
# @sectors-count: failed read operation sector count
#
# Note: This event is rate-limited.
#
# Since: 2.0
#
# Example:
#
# <- { "event": "QUORUM_FAILURE",
#      "data": { "reference": "usr1", "sector-num": 345435, "sectors-count": 5 },
#      "timestamp": { "seconds": 1344522075, "microseconds": 745528 } }
#
##
{
  "event": "QUORUM_FAILURE",
  "data": {
    "reference": "str",
    "sector-num": "int",
    "sectors-count": "int"
  }
}

##
# @QUORUM_REPORT_BAD:
#
# Emitted to report a corruption of a Quorum file
#
# @type: quorum operation type (Since 2.6)
#
# @error: error message. Only present on failure. This field
#         contains a human-readable error message. There are no semantics other
#         than that the block layer reported an error and clients should not
#         try to interpret the error string.
#
# @node-name: the graph node name of the block driver state
#
# @sector-num: number of the first sector of the failed read operation
#
# @sectors-count: failed read operation sector count
#
# Note: This event is rate-limited.
#
# Since: 2.0
#
# Example:
#
# 1. Read operation
#
# { "event": "QUORUM_REPORT_BAD",
#      "data": { "node-name": "node0", "sector-num": 345435, "sectors-count": 5,
#                "type": "read" },
#      "timestamp": { "seconds": 1344522075, "microseconds": 745528 } }
#
# 2. Flush operation
#
# { "event": "QUORUM_REPORT_BAD",
#      "data": { "node-name": "node0", "sector-num": 0, "sectors-count": 2097120,
#                "type": "flush", "error": "Broken pipe" },
#      "timestamp": { "seconds": 1456406829, "microseconds": 291763 } }
#
##
{
  "event": "QUORUM_REPORT_BAD",
  "data": {
    "type": "QuorumOpType",
    "*error": "str",
    "node-name": "str",
    "sector-num": "int",
    "sectors-count": "int"
  }
}


##
# @QapiErrorClass:
#
# QEMU error classes
#
# @GenericError: this is used for errors that don't require a specific error
#                class. This should be the default case for most errors
#
# @CommandNotFound: the requested command has not been found
#
# @DeviceNotActive: a device has failed to be become active
#
# @DeviceNotFound: the requested device has not been found
#
# @KVMMissingCap: the requested operation can't be fulfilled because a
#                 required KVM capability is missing
#
# Since: 1.2
##
{
  "enum": "QapiErrorClass",
  "data": [
    "GenericError",
    "CommandNotFound",
    "DeviceNotActive",
    "DeviceNotFound",
    "KVMMissingCap"
  ]
}

##
# @IoOperationType:
#
# An enumeration of the I/O operation types
#
# @read: read operation
#
# @write: write operation
#
# Since: 2.1
##
{
  "enum": "IoOperationType",
  "data": [
    "read",
    "write"
  ]
}

##
# @OnOffAuto:
#
# An enumeration of three options: on, off, and auto
#
# @auto: QEMU selects the value between on and off
#
# @on: Enabled
#
# @off: Disabled
#
# Since: 2.2
##
{
  "enum": "OnOffAuto",
  "data": [
    "auto",
    "on",
    "off"
  ]
}

##
# @OnOffSplit:
#
# An enumeration of three values: on, off, and split
#
# @on: Enabled
#
# @off: Disabled
#
# @split: Mixed
#
# Since: 2.6
##
{
  "enum": "OnOffSplit",
  "data": [
    "on",
    "off",
    "split"
  ]
}

##
# @String:
#
# A fat type wrapping 'str', to be embedded in lists.
#
# Since: 1.2
##
{
  "struct": "String",
  "data": {
    "str": "str"
  }
}

##
# @StrOrNull:
#
# This is a string value or the explicit lack of a string (null
# pointer in C).  Intended for cases when 'optional absent' already
# has a different meaning.
#
# @s: the string value
# @n: no string value
#
# Since: 2.10
##
{
  "alternate": "StrOrNull",
  "data": {
    "s": "str",
    "n": "null"
  }
}


##
# @NetworkAddressFamily:
#
# The network address family
#
# @ipv4: IPV4 family
#
# @ipv6: IPV6 family
#
# @unix: unix socket
#
# @vsock: vsock family (since 2.8)
#
# @unknown: otherwise
#
# Since: 2.1
##
{
  "enum": "NetworkAddressFamily",
  "data": [
    "ipv4",
    "ipv6",
    "unix",
    "vsock",
    "unknown"
  ]
}

##
# @InetSocketAddressBase:
#
# @host: host part of the address
# @port: port part of the address
##
{
  "struct": "InetSocketAddressBase",
  "data": {
    "host": "str",
    "port": "str"
  }
}

##
# @InetSocketAddress:
#
# Captures a socket address or address range in the Internet namespace.
#
# @numeric: true if the host/port are guaranteed to be numeric,
#           false if name resolution should be attempted. Defaults to false.
#           (Since 2.9)
#
# @to: If present, this is range of possible addresses, with port
#      between @port and @to.
#
# @ipv4: whether to accept IPv4 addresses, default try both IPv4 and IPv6
#
# @ipv6: whether to accept IPv6 addresses, default try both IPv4 and IPv6
#
# Since: 1.3
##
{
  "struct": "InetSocketAddress",
  "base": "InetSocketAddressBase",
  "data": {
    "*numeric": "bool",
    "*to": "uint16",
    "*ipv4": "bool",
    "*ipv6": "bool"
  }
}

##
# @UnixSocketAddress:
#
# Captures a socket address in the local ("Unix socket") namespace.
#
# @path: filesystem path to use
#
# Since: 1.3
##
{
  "struct": "UnixSocketAddress",
  "data": {
    "path": "str"
  }
}

##
# @VsockSocketAddress:
#
# Captures a socket address in the vsock namespace.
#
# @cid: unique host identifier
# @port: port
#
# Note: string types are used to allow for possible future hostname or
# service resolution support.
#
# Since: 2.8
##
{
  "struct": "VsockSocketAddress",
  "data": {
    "cid": "str",
    "port": "str"
  }
}

#
# Since: 1.3
##
{
  "union": "SocketAddressLegacy",
  "data": {
    "inet": "InetSocketAddress",
    "unix": "UnixSocketAddress",
    "vsock": "VsockSocketAddress",
    "fd": "String"
  }
}

##
# @SocketAddressType:
#
# Available SocketAddress types
#
# @inet:  Internet address
#
# @unix:  Unix domain socket
#
# Since: 2.9
##
{
  "enum": "SocketAddressType",
  "data": [
    "inet",
    "unix",
    "vsock",
    "fd"
  ]
}

##
# @SocketAddress:
#
# Captures the address of a socket, which could also be a named file
# descriptor
#
# @type:       Transport type
#
# Since: 2.9
##
{
  "union": "SocketAddress",
  "base": {
    "type": "SocketAddressType"
  },
  "discriminator": "type",
  "data": {
    "inet": "InetSocketAddress",
    "unix": "UnixSocketAddress",
    "vsock": "VsockSocketAddress",
    "fd": "String"
  }
}


##
# @ChardevInfo:
#
# Information about a character device.
#
# @label: the label of the character device
#
# @filename: the filename of the character device
#
# @frontend-open: shows whether the frontend device attached to this backend
#                 (eg. with the chardev=... option) is in open or closed state
#                 (since 2.1)
#
# Notes: @filename is encoded using the QEMU command line character device
#        encoding.  See the QEMU man page for details.
#
# Since: 0.14.0
##
{
  "struct": "ChardevInfo",
  "data": {
    "label": "str",
    "filename": "str",
    "frontend-open": "bool"
  }
}

##
# @query-chardev:
#
# Returns information about current character devices.
#
# Returns: a list of @ChardevInfo
#
# Since: 0.14.0
#
# Example:
#
# -> { "execute": "query-chardev" }
# <- {
#       "return": [
#          {
#             "label": "charchannel0",
#             "filename": "unix:/var/lib/libvirt/qemu/seabios.rhel6.agent,server",
#             "frontend-open": false
#          },
#          {
#             "label": "charmonitor",
#             "filename": "unix:/var/lib/libvirt/qemu/seabios.rhel6.monitor,server",
#             "frontend-open": true
#          },
#          {
#             "label": "charserial0",
#             "filename": "pty:/dev/pts/2",
#             "frontend-open": true
#          }
#       ]
#    }
#
##
{
  "command": "query-chardev",
  "returns": [
    "ChardevInfo"
  ]
}

##
# @ChardevBackendInfo:
#
# Information about a character device backend
#
# @name: The backend name
#
# Since: 2.0
##
{
  "struct": "ChardevBackendInfo",
  "data": {
    "name": "str"
  }
}

##
# @query-chardev-backends:
#
# Returns information about character device backends.
#
# Returns: a list of @ChardevBackendInfo
#
# Since: 2.0
#
# Example:
#
# -> { "execute": "query-chardev-backends" }
# <- {
#       "return":[
#          {
#             "name":"udp"
#          },
#          {
#             "name":"tcp"
#          },
#          {
#             "name":"unix"
#          },
#          {
#             "name":"spiceport"
#          }
#       ]
#    }
#
##
{
  "command": "query-chardev-backends",
  "returns": [
    "ChardevBackendInfo"
  ]
}

##
# @DataFormat:
#
# An enumeration of data format.
#
# @utf8: Data is a UTF-8 string (RFC 3629)
#
# @base64: Data is Base64 encoded binary (RFC 3548)
#
# Since: 1.4
##
{
  "enum": "DataFormat",
  "data": [
    "utf8",
    "base64"
  ]
}

##
# @ringbuf-write:
#
# Write to a ring buffer character device.
#
# @device: the ring buffer character device name
#
# @data: data to write
#
# @format: data encoding (default 'utf8').
#          - base64: data must be base64 encoded text.  Its binary
#            decoding gets written.
#          - utf8: data's UTF-8 encoding is written
#          - data itself is always Unicode regardless of format, like
#            any other string.
#
# Returns: Nothing on success
#
# Since: 1.4
#
# Example:
#
# -> { "execute": "ringbuf-write",
#      "arguments": { "device": "foo",
#                     "data": "abcdefgh",
#                     "format": "utf8" } }
# <- { "return": {} }
#
##
{
  "command": "ringbuf-write",
  "data": {
    "device": "str",
    "data": "str",
    "*format": "DataFormat"
  }
}

##
# @ringbuf-read:
#
# Read from a ring buffer character device.
#
# @device: the ring buffer character device name
#
# @size: how many bytes to read at most
#
# @format: data encoding (default 'utf8').
#          - base64: the data read is returned in base64 encoding.
#          - utf8: the data read is interpreted as UTF-8.
#            Bug: can screw up when the buffer contains invalid UTF-8
#            sequences, NUL characters, after the ring buffer lost
#            data, and when reading stops because the size limit is
#            reached.
#          - The return value is always Unicode regardless of format,
#            like any other string.
#
# Returns: data read from the device
#
# Since: 1.4
#
# Example:
#
# -> { "execute": "ringbuf-read",
#      "arguments": { "device": "foo",
#                     "size": 1000,
#                     "format": "utf8" } }
# <- { "return": "abcdefgh" }
#
##
{
  "command": "ringbuf-read",
  "data": {
    "device": "str",
    "size": "int",
    "*format": "DataFormat"
  },
  "returns": "str"
}

##
# @ChardevCommon:
#
# Configuration shared across all chardev backends
#
# @logfile: The name of a logfile to save output
# @logappend: true to append instead of truncate
#             (default to false to truncate)
#
# Since: 2.6
##
{
  "struct": "ChardevCommon",
  "data": {
    "*logfile": "str",
    "*logappend": "bool"
  }
}

##
# @ChardevFile:
#
# Configuration info for file chardevs.
#
# @in:  The name of the input file
# @out: The name of the output file
# @append: Open the file in append mode (default false to
#          truncate) (Since 2.6)
#
# Since: 1.4
##
{
  "struct": "ChardevFile",
  "data": {
    "*in": "str",
    "out": "str",
    "*append": "bool"
  },
  "base": "ChardevCommon"
}

##
# @ChardevHostdev:
#
# Configuration info for device and pipe chardevs.
#
# @device: The name of the special file for the device,
#          i.e. /dev/ttyS0 on Unix or COM1: on Windows
#
# Since: 1.4
##
{
  "struct": "ChardevHostdev",
  "data": {
    "device": "str"
  },
  "base": "ChardevCommon"
}

##
# @ChardevSocket:
#
# Configuration info for (stream) socket chardevs.
#
# @addr: socket address to listen on (server=true)
#        or connect to (server=false)
# @tls-creds: the ID of the TLS credentials object (since 2.6)
# @server: create server socket (default: true)
# @wait: wait for incoming connection on server
#        sockets (default: false).
# @nodelay: set TCP_NODELAY socket option (default: false)
# @telnet: enable telnet protocol on server
#          sockets (default: false)
# @tn3270: enable tn3270 protocol on server
#          sockets (default: false) (Since: 2.10)
# @reconnect: For a client socket, if a socket is disconnected,
#          then attempt a reconnect after the given number of seconds.
#          Setting this to zero disables this function. (default: 0)
#          (Since: 2.2)
#
# Since: 1.4
##
{
  "struct": "ChardevSocket",
  "data": {
    "addr": "SocketAddressLegacy",
    "*tls-creds": "str",
    "*server": "bool",
    "*wait": "bool",
    "*nodelay": "bool",
    "*telnet": "bool",
    "*tn3270": "bool",
    "*reconnect": "int"
  },
  "base": "ChardevCommon"
}

##
# @ChardevUdp:
#
# Configuration info for datagram socket chardevs.
#
# @remote: remote address
# @local: local address
#
# Since: 1.5
##
{
  "struct": "ChardevUdp",
  "data": {
    "remote": "SocketAddressLegacy",
    "*local": "SocketAddressLegacy"
  },
  "base": "ChardevCommon"
}

##
# @ChardevMux:
#
# Configuration info for mux chardevs.
#
# @chardev: name of the base chardev.
#
# Since: 1.5
##
{
  "struct": "ChardevMux",
  "data": {
    "chardev": "str"
  },
  "base": "ChardevCommon"
}

##
# @ChardevStdio:
#
# Configuration info for stdio chardevs.
#
# @signal: Allow signals (such as SIGINT triggered by ^C)
#          be delivered to qemu.  Default: true in -nographic mode,
#          false otherwise.
#
# Since: 1.5
##
{
  "struct": "ChardevStdio",
  "data": {
    "*signal": "bool"
  },
  "base": "ChardevCommon"
}


##
# @ChardevSpiceChannel:
#
# Configuration info for spice vm channel chardevs.
#
# @type: kind of channel (for example vdagent).
#
# Since: 1.5
##
{
  "struct": "ChardevSpiceChannel",
  "data": {
    "type": "str"
  },
  "base": "ChardevCommon"
}

##
# @ChardevSpicePort:
#
# Configuration info for spice port chardevs.
#
# @fqdn: name of the channel (see docs/spice-port-fqdn.txt)
#
# Since: 1.5
##
{
  "struct": "ChardevSpicePort",
  "data": {
    "fqdn": "str"
  },
  "base": "ChardevCommon"
}

##
# @ChardevVC:
#
# Configuration info for virtual console chardevs.
#
# @width:  console width,  in pixels
# @height: console height, in pixels
# @cols:   console width,  in chars
# @rows:   console height, in chars
#
# Since: 1.5
##
{
  "struct": "ChardevVC",
  "data": {
    "*width": "int",
    "*height": "int",
    "*cols": "int",
    "*rows": "int"
  },
  "base": "ChardevCommon"
}

##
# @ChardevRingbuf:
#
# Configuration info for ring buffer chardevs.
#
# @size: ring buffer size, must be power of two, default is 65536
#
# Since: 1.5
##
{
  "struct": "ChardevRingbuf",
  "data": {
    "*size": "int"
  },
  "base": "ChardevCommon"
}

##
# @ChardevBackend:
#
# Configuration info for the new chardev backend.
#
# Since: 1.4 (testdev since 2.2, wctablet since 2.9)
##
{
  "union": "ChardevBackend",
  "data": {
    "file": "ChardevFile",
    "serial": "ChardevHostdev",
    "parallel": "ChardevHostdev",
    "pipe": "ChardevHostdev",
    "socket": "ChardevSocket",
    "udp": "ChardevUdp",
    "pty": "ChardevCommon",
    "null": "ChardevCommon",
    "mux": "ChardevMux",
    "msmouse": "ChardevCommon",
    "wctablet": "ChardevCommon",
    "braille": "ChardevCommon",
    "testdev": "ChardevCommon",
    "stdio": "ChardevStdio",
    "console": "ChardevCommon",
    "spicevmc": "ChardevSpiceChannel",
    "spiceport": "ChardevSpicePort",
    "vc": "ChardevVC",
    "ringbuf": "ChardevRingbuf",
    "memory": "ChardevRingbuf"
  }
}

##
# @ChardevReturn:
#
# Return info about the chardev backend just created.
#
# @pty: name of the slave pseudoterminal device, present if
#       and only if a chardev of type 'pty' was created
#
# Since: 1.4
##
{
  "struct": "ChardevReturn",
  "data": {
    "*pty": "str"
  }
}

##
# @chardev-add:
#
# Add a character device backend
#
# @id: the chardev's ID, must be unique
# @backend: backend type and parameters
#
# Returns: ChardevReturn.
#
# Since: 1.4
#
# Example:
#
# -> { "execute" : "chardev-add",
#      "arguments" : { "id" : "foo",
#                      "backend" : { "type" : "null", "data" : {} } } }
# <- { "return": {} }
#
# -> { "execute" : "chardev-add",
#      "arguments" : { "id" : "bar",
#                      "backend" : { "type" : "file",
#                                    "data" : { "out" : "/tmp/bar.log" } } } }
# <- { "return": {} }
#
# -> { "execute" : "chardev-add",
#      "arguments" : { "id" : "baz",
#                      "backend" : { "type" : "pty", "data" : {} } } }
# <- { "return": { "pty" : "/dev/pty/42" } }
#
##
{
  "command": "chardev-add",
  "data": {
    "id": "str",
    "backend": "ChardevBackend"
  },
  "returns": "ChardevReturn"
}

##
# @chardev-change:
#
# Change a character device backend
#
# @id: the chardev's ID, must exist
# @backend: new backend type and parameters
#
# Returns: ChardevReturn.
#
# Since: 2.10
#
# Example:
#
# -> { "execute" : "chardev-change",
#      "arguments" : { "id" : "baz",
#                      "backend" : { "type" : "pty", "data" : {} } } }
# <- { "return": { "pty" : "/dev/pty/42" } }
#
# -> {"execute" : "chardev-change",
#     "arguments" : {
#         "id" : "charchannel2",
#         "backend" : {
#             "type" : "socket",
#             "data" : {
#                 "addr" : {
#                     "type" : "unix" ,
#                     "data" : {
#                         "path" : "/tmp/charchannel2.socket"
#                     }
#                  },
#                  "server" : true,
#                  "wait" : false }}}}
# <- {"return": {}}
#
##
{
  "command": "chardev-change",
  "data": {
    "id": "str",
    "backend": "ChardevBackend"
  },
  "returns": "ChardevReturn"
}

##
# @chardev-remove:
#
# Remove a character device backend
#
# @id: the chardev's ID, must exist and not be in use
#
# Returns: Nothing on success
#
# Since: 1.4
#
# Example:
#
# -> { "execute": "chardev-remove", "arguments": { "id" : "foo" } }
# <- { "return": {} }
#
##
{
  "command": "chardev-remove",
  "data": {
    "id": "str"
  }
}

##
# @chardev-send-break:
#
# Send a break to a character device
#
# @id: the chardev's ID, must exist
#
# Returns: Nothing on success
#
# Since: 2.10
#
# Example:
#
# -> { "execute": "chardev-send-break", "arguments": { "id" : "foo" } }
# <- { "return": {} }
#
##
{
  "command": "chardev-send-break",
  "data": {
    "id": "str"
  }
}

##
# @VSERPORT_CHANGE:
#
# Emitted when the guest opens or closes a virtio-serial port.
#
# @id: device identifier of the virtio-serial port
#
# @open: true if the guest has opened the virtio-serial port
#
# Since: 2.1
#
# Example:
#
# <- { "event": "VSERPORT_CHANGE",
#      "data": { "id": "channel0", "open": true },
#      "timestamp": { "seconds": 1401385907, "microseconds": 422329 } }
#
##
{
  "event": "VSERPORT_CHANGE",
  "data": {
    "id": "str",
    "open": "bool"
  }
}


##
# @QapiErrorClass:
#
# QEMU error classes
#
# @GenericError: this is used for errors that don't require a specific error
#                class. This should be the default case for most errors
#
# @CommandNotFound: the requested command has not been found
#
# @DeviceNotActive: a device has failed to be become active
#
# @DeviceNotFound: the requested device has not been found
#
# @KVMMissingCap: the requested operation can't be fulfilled because a
#                 required KVM capability is missing
#
# Since: 1.2
##
{
  "enum": "QapiErrorClass",
  "data": [
    "GenericError",
    "CommandNotFound",
    "DeviceNotActive",
    "DeviceNotFound",
    "KVMMissingCap"
  ]
}

##
# @IoOperationType:
#
# An enumeration of the I/O operation types
#
# @read: read operation
#
# @write: write operation
#
# Since: 2.1
##
{
  "enum": "IoOperationType",
  "data": [
    "read",
    "write"
  ]
}

##
# @OnOffAuto:
#
# An enumeration of three options: on, off, and auto
#
# @auto: QEMU selects the value between on and off
#
# @on: Enabled
#
# @off: Disabled
#
# Since: 2.2
##
{
  "enum": "OnOffAuto",
  "data": [
    "auto",
    "on",
    "off"
  ]
}

##
# @OnOffSplit:
#
# An enumeration of three values: on, off, and split
#
# @on: Enabled
#
# @off: Disabled
#
# @split: Mixed
#
# Since: 2.6
##
{
  "enum": "OnOffSplit",
  "data": [
    "on",
    "off",
    "split"
  ]
}

##
# @String:
#
# A fat type wrapping 'str', to be embedded in lists.
#
# Since: 1.2
##
{
  "struct": "String",
  "data": {
    "str": "str"
  }
}

##
# @StrOrNull:
#
# This is a string value or the explicit lack of a string (null
# pointer in C).  Intended for cases when 'optional absent' already
# has a different meaning.
#
# @s: the string value
# @n: no string value
#
# Since: 2.10
##
{
  "alternate": "StrOrNull",
  "data": {
    "s": "str",
    "n": "null"
  }
}


##
# @set_link:
#
# Sets the link status of a virtual network adapter.
#
# @name: the device name of the virtual network adapter
#
# @up: true to set the link status to be up
#
# Returns: Nothing on success
#          If @name is not a valid network device, DeviceNotFound
#
# Since: 0.14.0
#
# Notes: Not all network adapters support setting link status.  This command
#        will succeed even if the network adapter does not support link status
#        notification.
#
# Example:
#
# -> { "execute": "set_link",
#      "arguments": { "name": "e1000.0", "up": false } }
# <- { "return": {} }
#
##
{
  "command": "set_link",
  "data": {
    "name": "str",
    "up": "bool"
  }
}

##
# @netdev_add:
#
# Add a network backend.
#
# @type: the type of network backend.  Current valid values are 'user', 'tap',
#        'vde', 'socket', 'dump' and 'bridge'
#
# @id: the name of the new network backend
#
# Additional arguments depend on the type.
#
# TODO: This command effectively bypasses QAPI completely due to its
# "additional arguments" business.  It shouldn't have been added to
# the schema in this form.  It should be qapified properly, or
# replaced by a properly qapified command.
#
# Since: 0.14.0
#
# Returns: Nothing on success
#          If @type is not a valid network backend, DeviceNotFound
#
# Example:
#
# -> { "execute": "netdev_add",
#      "arguments": { "type": "user", "id": "netdev1",
#                     "dnssearch": "example.org" } }
# <- { "return": {} }
#
##
{
  "command": "netdev_add",
  "data": {
    "type": "str",
    "id": "str"
  },
  "gen": false
}                

##
# @netdev_del:
#
# Remove a network backend.
#
# @id: the name of the network backend to remove
#
# Returns: Nothing on success
#          If @id is not a valid network backend, DeviceNotFound
#
# Since: 0.14.0
#
# Example:
#
# -> { "execute": "netdev_del", "arguments": { "id": "netdev1" } }
# <- { "return": {} }
#
##
{
  "command": "netdev_del",
  "data": {
    "id": "str"
  }
}

##
# @NetdevNoneOptions:
#
# Use it alone to have zero network devices.
#
# Since: 1.2
##
{
  "struct": "NetdevNoneOptions",
  "data": {}
}

##
# @NetLegacyNicOptions:
#
# Create a new Network Interface Card.
#
# @netdev: id of -netdev to connect to
#
# @macaddr: MAC address
#
# @model: device model (e1000, rtl8139, virtio etc.)
#
# @addr: PCI device address
#
# @vectors: number of MSI-x vectors, 0 to disable MSI-X
#
# Since: 1.2
##
{
  "struct": "NetLegacyNicOptions",
  "data": {
    "*netdev": "str",
    "*macaddr": "str",
    "*model": "str",
    "*addr": "str",
    "*vectors": "uint32"
  }
}

##
# @NetdevUserOptions:
#
# Use the user mode network stack which requires no administrator privilege to
# run.
#
# @hostname: client hostname reported by the builtin DHCP server
#
# @restrict: isolate the guest from the host
#
# @ipv4: whether to support IPv4, default true for enabled
#        (since 2.6)
#
# @ipv6: whether to support IPv6, default true for enabled
#        (since 2.6)
#
# @ip: legacy parameter, use net= instead
#
# @net: IP network address that the guest will see, in the
#       form addr[/netmask] The netmask is optional, and can be
#       either in the form a.b.c.d or as a number of valid top-most
#       bits. Default is 10.0.2.0/24.
#
# @host: guest-visible address of the host
#
# @tftp: root directory of the built-in TFTP server
#
# @bootfile: BOOTP filename, for use with tftp=
#
# @dhcpstart: the first of the 16 IPs the built-in DHCP server can
#             assign
#
# @dns: guest-visible address of the virtual nameserver
#
# @dnssearch: list of DNS suffixes to search, passed as DHCP option
#             to the guest
#
# @ipv6-prefix: IPv6 network prefix (default is fec0::) (since
#               2.6). The network prefix is given in the usual
#               hexadecimal IPv6 address notation.
#
# @ipv6-prefixlen: IPv6 network prefix length (default is 64)
#                  (since 2.6)
#
# @ipv6-host: guest-visible IPv6 address of the host (since 2.6)
#
# @ipv6-dns: guest-visible IPv6 address of the virtual
#            nameserver (since 2.6)
#
# @smb: root directory of the built-in SMB server
#
# @smbserver: IP address of the built-in SMB server
#
# @hostfwd: redirect incoming TCP or UDP host connections to guest
#           endpoints
#
# @guestfwd: forward guest TCP connections
#
# Since: 1.2
##
{
  "struct": "NetdevUserOptions",
  "data": {
    "*hostname": "str",
    "*restrict": "bool",
    "*ipv4": "bool",
    "*ipv6": "bool",
    "*ip": "str",
    "*net": "str",
    "*host": "str",
    "*tftp": "str",
    "*bootfile": "str",
    "*dhcpstart": "str",
    "*dns": "str",
    "*dnssearch": [
      "String"
    ],
    "*ipv6-prefix": "str",
    "*ipv6-prefixlen": "int",
    "*ipv6-host": "str",
    "*ipv6-dns": "str",
    "*smb": "str",
    "*smbserver": "str",
    "*hostfwd": [
      "String"
    ],
    "*guestfwd": [
      "String"
    ]
  }
}

##
# @NetdevTapOptions:
#
# Connect the host TAP network interface name to the VLAN.
#
# @ifname: interface name
#
# @fd: file descriptor of an already opened tap
#
# @fds: multiple file descriptors of already opened multiqueue capable
# tap
#
# @script: script to initialize the interface
#
# @downscript: script to shut down the interface
#
# @br: bridge name (since 2.8)
#
# @helper: command to execute to configure bridge
#
# @sndbuf: send buffer limit. Understands [TGMKkb] suffixes.
#
# @vnet_hdr: enable the IFF_VNET_HDR flag on the tap interface
#
# @vhost: enable vhost-net network accelerator
#
# @vhostfd: file descriptor of an already opened vhost net device
#
# @vhostfds: file descriptors of multiple already opened vhost net
# devices
#
# @vhostforce: vhost on for non-MSIX virtio guests
#
# @queues: number of queues to be created for multiqueue capable tap
#
# @poll-us: maximum number of microseconds that could
# be spent on busy polling for tap (since 2.7)
#
# Since: 1.2
##
{
  "struct": "NetdevTapOptions",
  "data": {
    "*ifname": "str",
    "*fd": "str",
    "*fds": "str",
    "*script": "str",
    "*downscript": "str",
    "*br": "str",
    "*helper": "str",
    "*sndbuf": "size",
    "*vnet_hdr": "bool",
    "*vhost": "bool",
    "*vhostfd": "str",
    "*vhostfds": "str",
    "*vhostforce": "bool",
    "*queues": "uint32",
    "*poll-us": "uint32"
  }
}

##
# @NetdevSocketOptions:
#
# Connect the VLAN to a remote VLAN in another QEMU virtual machine using a TCP
# socket connection.
#
# @fd: file descriptor of an already opened socket
#
# @listen: port number, and optional hostname, to listen on
#
# @connect: port number, and optional hostname, to connect to
#
# @mcast: UDP multicast address and port number
#
# @localaddr: source address and port for multicast and udp packets
#
# @udp: UDP unicast address and port number
#
# Since: 1.2
##
{
  "struct": "NetdevSocketOptions",
  "data": {
    "*fd": "str",
    "*listen": "str",
    "*connect": "str",
    "*mcast": "str",
    "*localaddr": "str",
    "*udp": "str"
  }
}

##
# @NetdevL2TPv3Options:
#
# Connect the VLAN to Ethernet over L2TPv3 Static tunnel
#
# @src: source address
#
# @dst: destination address
#
# @srcport: source port - mandatory for udp, optional for ip
#
# @dstport: destination port - mandatory for udp, optional for ip
#
# @ipv6: force the use of ipv6
#
# @udp: use the udp version of l2tpv3 encapsulation
#
# @cookie64: use 64 bit coookies
#
# @counter: have sequence counter
#
# @pincounter: pin sequence counter to zero -
#              workaround for buggy implementations or
#              networks with packet reorder
#
# @txcookie: 32 or 64 bit transmit cookie
#
# @rxcookie: 32 or 64 bit receive cookie
#
# @txsession: 32 bit transmit session
#
# @rxsession: 32 bit receive session - if not specified
#             set to the same value as transmit
#
# @offset: additional offset - allows the insertion of
#          additional application-specific data before the packet payload
#
# Since: 2.1
##
{
  "struct": "NetdevL2TPv3Options",
  "data": {
    "src": "str",
    "dst": "str",
    "*srcport": "str",
    "*dstport": "str",
    "*ipv6": "bool",
    "*udp": "bool",
    "*cookie64": "bool",
    "*counter": "bool",
    "*pincounter": "bool",
    "*txcookie": "uint64",
    "*rxcookie": "uint64",
    "txsession": "uint32",
    "*rxsession": "uint32",
    "*offset": "uint32"
  }
}

##
# @NetdevVdeOptions:
#
# Connect the VLAN to a vde switch running on the host.
#
# @sock: socket path
#
# @port: port number
#
# @group: group owner of socket
#
# @mode: permissions for socket
#
# Since: 1.2
##
{
  "struct": "NetdevVdeOptions",
  "data": {
    "*sock": "str",
    "*port": "uint16",
    "*group": "str",
    "*mode": "uint16"
  }
}

##
# @NetdevDumpOptions:
#
# Dump VLAN network traffic to a file.
#
# @len: per-packet size limit (64k default). Understands [TGMKkb]
# suffixes.
#
# @file: dump file path (default is qemu-vlan0.pcap)
#
# Since: 1.2
##
{
  "struct": "NetdevDumpOptions",
  "data": {
    "*len": "size",
    "*file": "str"
  }
}

##
# @NetdevBridgeOptions:
#
# Connect a host TAP network interface to a host bridge device.
#
# @br: bridge name
#
# @helper: command to execute to configure bridge
#
# Since: 1.2
##
{
  "struct": "NetdevBridgeOptions",
  "data": {
    "*br": "str",
    "*helper": "str"
  }
}

##
# @NetdevHubPortOptions:
#
# Connect two or more net clients through a software hub.
#
# @hubid: hub identifier number
#
# Since: 1.2
##
{
  "struct": "NetdevHubPortOptions",
  "data": {
    "hubid": "int32"
  }
}

##
# @NetdevNetmapOptions:
#
# Connect a client to a netmap-enabled NIC or to a VALE switch port
#
# @ifname: Either the name of an existing network interface supported by
#          netmap, or the name of a VALE port (created on the fly).
#          A VALE port name is in the form 'valeXXX:YYY', where XXX and
#          YYY are non-negative integers. XXX identifies a switch and
#          YYY identifies a port of the switch. VALE ports having the
#          same XXX are therefore connected to the same switch.
#
# @devname: path of the netmap device (default: '/dev/netmap').
#
# Since: 2.0
##
{
  "struct": "NetdevNetmapOptions",
  "data": {
    "ifname": "str",
    "*devname": "str"
  }
}

##
# @NetdevVhostUserOptions:
#
# Vhost-user network backend
#
# @chardev: name of a unix socket chardev
#
# @vhostforce: vhost on for non-MSIX virtio guests (default: false).
#
# @queues: number of queues to be created for multiqueue vhost-user
#          (default: 1) (Since 2.5)
#
# Since: 2.1
##
{
  "struct": "NetdevVhostUserOptions",
  "data": {
    "chardev": "str",
    "*vhostforce": "bool",
    "*queues": "int"
  }
}

##
# @NetClientDriver:
#
# Available netdev drivers.
#
# Since: 2.7
##
{
  "enum": "NetClientDriver",
  "data": [
    "none",
    "nic",
    "user",
    "tap",
    "l2tpv3",
    "socket",
    "vde",
    "dump",
    "bridge",
    "hubport",
    "netmap",
    "vhost-user"
  ]
}

##
# @Netdev:
#
# Captures the configuration of a network device.
#
# @id: identifier for monitor commands.
#
# @type: Specify the driver used for interpreting remaining arguments.
#
# Since: 1.2
#
# 'l2tpv3' - since 2.1
##
{
  "union": "Netdev",
  "base": {
    "id": "str",
    "type": "NetClientDriver"
  },
  "discriminator": "type",
  "data": {
    "none": "NetdevNoneOptions",
    "nic": "NetLegacyNicOptions",
    "user": "NetdevUserOptions",
    "tap": "NetdevTapOptions",
    "l2tpv3": "NetdevL2TPv3Options",
    "socket": "NetdevSocketOptions",
    "vde": "NetdevVdeOptions",
    "dump": "NetdevDumpOptions",
    "bridge": "NetdevBridgeOptions",
    "hubport": "NetdevHubPortOptions",
    "netmap": "NetdevNetmapOptions",
    "vhost-user": "NetdevVhostUserOptions"
  }
}

##
# @NetLegacy:
#
# Captures the configuration of a network device; legacy.
#
# @vlan: vlan number
#
# @id: identifier for monitor commands
#
# @name: identifier for monitor commands, ignored if @id is present
#
# @opts: device type specific properties (legacy)
#
# Since: 1.2
##
{
  "struct": "NetLegacy",
  "data": {
    "*vlan": "int32",
    "*id": "str",
    "*name": "str",
    "opts": "NetLegacyOptions"
  }
}

##
# @NetLegacyOptionsType:
#
# Since: 1.2
##
{
  "enum": "NetLegacyOptionsType",
  "data": [
    "none",
    "nic",
    "user",
    "tap",
    "l2tpv3",
    "socket",
    "vde",
    "dump",
    "bridge",
    "netmap",
    "vhost-user"
  ]
}

##
# @NetLegacyOptions:
#
# Like Netdev, but for use only by the legacy command line options
#
# Since: 1.2
##
{
  "union": "NetLegacyOptions",
  "base": {
    "type": "NetLegacyOptionsType"
  },
  "discriminator": "type",
  "data": {
    "none": "NetdevNoneOptions",
    "nic": "NetLegacyNicOptions",
    "user": "NetdevUserOptions",
    "tap": "NetdevTapOptions",
    "l2tpv3": "NetdevL2TPv3Options",
    "socket": "NetdevSocketOptions",
    "vde": "NetdevVdeOptions",
    "dump": "NetdevDumpOptions",
    "bridge": "NetdevBridgeOptions",
    "netmap": "NetdevNetmapOptions",
    "vhost-user": "NetdevVhostUserOptions"
  }
}

##
# @NetFilterDirection:
#
# Indicates whether a netfilter is attached to a netdev's transmit queue or
# receive queue or both.
#
# @all: the filter is attached both to the receive and the transmit
#       queue of the netdev (default).
#
# @rx: the filter is attached to the receive queue of the netdev,
#      where it will receive packets sent to the netdev.
#
# @tx: the filter is attached to the transmit queue of the netdev,
#      where it will receive packets sent by the netdev.
#
# Since: 2.5
##
{
  "enum": "NetFilterDirection",
  "data": [
    "all",
    "rx",
    "tx"
  ]
}

##
# @RxState:
#
# Packets receiving state
#
# @normal: filter assigned packets according to the mac-table
#
# @none: don't receive any assigned packet
#
# @all: receive all assigned packets
#
# Since: 1.6
##
{
  "enum": "RxState",
  "data": [
    "normal",
    "none",
    "all"
  ]
}

##
# @RxFilterInfo:
#
# Rx-filter information for a NIC.
#
# @name: net client name
#
# @promiscuous: whether promiscuous mode is enabled
#
# @multicast: multicast receive state
#
# @unicast: unicast receive state
#
# @vlan: vlan receive state (Since 2.0)
#
# @broadcast-allowed: whether to receive broadcast
#
# @multicast-overflow: multicast table is overflowed or not
#
# @unicast-overflow: unicast table is overflowed or not
#
# @main-mac: the main macaddr string
#
# @vlan-table: a list of active vlan id
#
# @unicast-table: a list of unicast macaddr string
#
# @multicast-table: a list of multicast macaddr string
#
# Since: 1.6
##
{
  "struct": "RxFilterInfo",
  "data": {
    "name": "str",
    "promiscuous": "bool",
    "multicast": "RxState",
    "unicast": "RxState",
    "vlan": "RxState",
    "broadcast-allowed": "bool",
    "multicast-overflow": "bool",
    "unicast-overflow": "bool",
    "main-mac": "str",
    "vlan-table": [
      "int"
    ],
    "unicast-table": [
      "str"
    ],
    "multicast-table": [
      "str"
    ]
  }
}

##
# @query-rx-filter:
#
# Return rx-filter information for all NICs (or for the given NIC).
#
# @name: net client name
#
# Returns: list of @RxFilterInfo for all NICs (or for the given NIC).
#          Returns an error if the given @name doesn't exist, or given
#          NIC doesn't support rx-filter querying, or given net client
#          isn't a NIC.
#
# Since: 1.6
#
# Example:
#
# -> { "execute": "query-rx-filter", "arguments": { "name": "vnet0" } }
# <- { "return": [
#         {
#             "promiscuous": true,
#             "name": "vnet0",
#             "main-mac": "52:54:00:12:34:56",
#             "unicast": "normal",
#             "vlan": "normal",
#             "vlan-table": [
#                 4,
#                 0
#             ],
#             "unicast-table": [
#             ],
#             "multicast": "normal",
#             "multicast-overflow": false,
#             "unicast-overflow": false,
#             "multicast-table": [
#                 "01:00:5e:00:00:01",
#                 "33:33:00:00:00:01",
#                 "33:33:ff:12:34:56"
#             ],
#             "broadcast-allowed": false
#         }
#       ]
#    }
#
##
{
  "command": "query-rx-filter",
  "data": {
    "*name": "str"
  },
  "returns": [
    "RxFilterInfo"
  ]
}

##
# @NIC_RX_FILTER_CHANGED:
#
# Emitted once until the 'query-rx-filter' command is executed, the first event
# will always be emitted
#
# @name: net client name
#
# @path: device path
#
# Since: 1.6
#
# Example:
#
# <- { "event": "NIC_RX_FILTER_CHANGED",
#      "data": { "name": "vnet0",
#                "path": "/machine/peripheral/vnet0/virtio-backend" },
#      "timestamp": { "seconds": 1368697518, "microseconds": 326866 } }
#    }
#
##
{
  "event": "NIC_RX_FILTER_CHANGED",
  "data": {
    "*name": "str",
    "path": "str"
  }
}


##
# @RockerSwitch:
#
# Rocker switch information.
#
# @name: switch name
#
# @id: switch ID
#
# @ports: number of front-panel ports
#
# Since: 2.4
##
{
  "struct": "RockerSwitch",
  "data": {
    "name": "str",
    "id": "uint64",
    "ports": "uint32"
  }
}

##
# @query-rocker:
#
# Return rocker switch information.
#
# Returns: @Rocker information
#
# Since: 2.4
#
# Example:
#
# -> { "execute": "query-rocker", "arguments": { "name": "sw1" } }
# <- { "return": {"name": "sw1", "ports": 2, "id": 1327446905938}}
#
##
{
  "command": "query-rocker",
  "data": {
    "name": "str"
  },
  "returns": "RockerSwitch"
}

##
# @RockerPortDuplex:
#
# An eumeration of port duplex states.
#
# @half: half duplex
#
# @full: full duplex
#
# Since: 2.4
##
{
  "enum": "RockerPortDuplex",
  "data": [
    "half",
    "full"
  ]
}

##
# @RockerPortAutoneg:
#
# An eumeration of port autoneg states.
#
# @off: autoneg is off
#
# @on: autoneg is on
#
# Since: 2.4
##
{
  "enum": "RockerPortAutoneg",
  "data": [
    "off",
    "on"
  ]
}

##
# @RockerPort:
#
# Rocker switch port information.
#
# @name: port name
#
# @enabled: port is enabled for I/O
#
# @link-up: physical link is UP on port
#
# @speed: port link speed in Mbps
#
# @duplex: port link duplex
#
# @autoneg: port link autoneg
#
# Since: 2.4
##
{
  "struct": "RockerPort",
  "data": {
    "name": "str",
    "enabled": "bool",
    "link-up": "bool",
    "speed": "uint32",
    "duplex": "RockerPortDuplex",
    "autoneg": "RockerPortAutoneg"
  }
}

##
# @query-rocker-ports:
#
# Return rocker switch port information.
#
# Returns: a list of @RockerPort information
#
# Since: 2.4
#
# Example:
#
# -> { "execute": "query-rocker-ports", "arguments": { "name": "sw1" } }
# <- { "return": [ {"duplex": "full", "enabled": true, "name": "sw1.1",
#                   "autoneg": "off", "link-up": true, "speed": 10000},
#                  {"duplex": "full", "enabled": true, "name": "sw1.2",
#                   "autoneg": "off", "link-up": true, "speed": 10000}
#    ]}
#
##
{
  "command": "query-rocker-ports",
  "data": {
    "name": "str"
  },
  "returns": [
    "RockerPort"
  ]
}

##
# @RockerOfDpaFlowKey:
#
# Rocker switch OF-DPA flow key
#
# @priority: key priority, 0 being lowest priority
#
# @tbl-id: flow table ID
#
# @in-pport: physical input port
#
# @tunnel-id: tunnel ID
#
# @vlan-id: VLAN ID
#
# @eth-type: Ethernet header type
#
# @eth-src: Ethernet header source MAC address
#
# @eth-dst: Ethernet header destination MAC address
#
# @ip-proto: IP Header protocol field
#
# @ip-tos: IP header TOS field
#
# @ip-dst: IP header destination address
#
# Note: optional members may or may not appear in the flow key
# depending if they're relevant to the flow key.
#
# Since: 2.4
##
{
  "struct": "RockerOfDpaFlowKey",
  "data": {
    "priority": "uint32",
    "tbl-id": "uint32",
    "*in-pport": "uint32",
    "*tunnel-id": "uint32",
    "*vlan-id": "uint16",
    "*eth-type": "uint16",
    "*eth-src": "str",
    "*eth-dst": "str",
    "*ip-proto": "uint8",
    "*ip-tos": "uint8",
    "*ip-dst": "str"
  }
}

##
# @RockerOfDpaFlowMask:
#
# Rocker switch OF-DPA flow mask
#
# @in-pport: physical input port
#
# @tunnel-id: tunnel ID
#
# @vlan-id: VLAN ID
#
# @eth-src: Ethernet header source MAC address
#
# @eth-dst: Ethernet header destination MAC address
#
# @ip-proto: IP Header protocol field
#
# @ip-tos: IP header TOS field
#
# Note: optional members may or may not appear in the flow mask
# depending if they're relevant to the flow mask.
#
# Since: 2.4
##
{
  "struct": "RockerOfDpaFlowMask",
  "data": {
    "*in-pport": "uint32",
    "*tunnel-id": "uint32",
    "*vlan-id": "uint16",
    "*eth-src": "str",
    "*eth-dst": "str",
    "*ip-proto": "uint8",
    "*ip-tos": "uint8"
  }
}

##
# @RockerOfDpaFlowAction:
#
# Rocker switch OF-DPA flow action
#
# @goto-tbl: next table ID
#
# @group-id: group ID
#
# @tunnel-lport: tunnel logical port ID
#
# @vlan-id: VLAN ID
#
# @new-vlan-id: new VLAN ID
#
# @out-pport: physical output port
#
# Note: optional members may or may not appear in the flow action
# depending if they're relevant to the flow action.
#
# Since: 2.4
##
{
  "struct": "RockerOfDpaFlowAction",
  "data": {
    "*goto-tbl": "uint32",
    "*group-id": "uint32",
    "*tunnel-lport": "uint32",
    "*vlan-id": "uint16",
    "*new-vlan-id": "uint16",
    "*out-pport": "uint32"
  }
}

##
# @RockerOfDpaFlow:
#
# Rocker switch OF-DPA flow
#
# @cookie: flow unique cookie ID
#
# @hits: count of matches (hits) on flow
#
# @key: flow key
#
# @mask: flow mask
#
# @action: flow action
#
# Since: 2.4
##
{
  "struct": "RockerOfDpaFlow",
  "data": {
    "cookie": "uint64",
    "hits": "uint64",
    "key": "RockerOfDpaFlowKey",
    "mask": "RockerOfDpaFlowMask",
    "action": "RockerOfDpaFlowAction"
  }
}

##
# @query-rocker-of-dpa-flows:
#
# Return rocker OF-DPA flow information.
#
# @name: switch name
#
# @tbl-id: flow table ID.  If tbl-id is not specified, returns
# flow information for all tables.
#
# Returns: rocker OF-DPA flow information
#
# Since: 2.4
#
# Example:
#
# -> { "execute": "query-rocker-of-dpa-flows",
#      "arguments": { "name": "sw1" } }
# <- { "return": [ {"key": {"in-pport": 0, "priority": 1, "tbl-id": 0},
#                   "hits": 138,
#                   "cookie": 0,
#                   "action": {"goto-tbl": 10},
#                   "mask": {"in-pport": 4294901760}
#                  },
#                  {...more...},
#    ]}
#
##
{
  "command": "query-rocker-of-dpa-flows",
  "data": {
    "name": "str",
    "*tbl-id": "uint32"
  },
  "returns": [
    "RockerOfDpaFlow"
  ]
}

##
# @RockerOfDpaGroup:
#
# Rocker switch OF-DPA group
#
# @id: group unique ID
#
# @type: group type
#
# @vlan-id: VLAN ID
#
# @pport: physical port number
#
# @index: group index, unique with group type
#
# @out-pport: output physical port number
#
# @group-id: next group ID
#
# @set-vlan-id: VLAN ID to set
#
# @pop-vlan: pop VLAN headr from packet
#
# @group-ids: list of next group IDs
#
# @set-eth-src: set source MAC address in Ethernet header
#
# @set-eth-dst: set destination MAC address in Ethernet header
#
# @ttl-check: perform TTL check
#
# Note: optional members may or may not appear in the group depending
# if they're relevant to the group type.
#
# Since: 2.4
##
{
  "struct": "RockerOfDpaGroup",
  "data": {
    "id": "uint32",
    "type": "uint8",
    "*vlan-id": "uint16",
    "*pport": "uint32",
    "*index": "uint32",
    "*out-pport": "uint32",
    "*group-id": "uint32",
    "*set-vlan-id": "uint16",
    "*pop-vlan": "uint8",
    "*group-ids": [
      "uint32"
    ],
    "*set-eth-src": "str",
    "*set-eth-dst": "str",
    "*ttl-check": "uint8"
  }
}

##
# @query-rocker-of-dpa-groups:
#
# Return rocker OF-DPA group information.
#
# @name: switch name
#
# @type: group type.  If type is not specified, returns
# group information for all group types.
#
# Returns: rocker OF-DPA group information
#
# Since: 2.4
#
# Example:
#
# -> { "execute": "query-rocker-of-dpa-groups",
#      "arguments": { "name": "sw1" } }
# <- { "return": [ {"type": 0, "out-pport": 2,
#                   "pport": 2, "vlan-id": 3841,
#                   "pop-vlan": 1, "id": 251723778},
#                  {"type": 0, "out-pport": 0,
#                   "pport": 0, "vlan-id": 3841,
#                   "pop-vlan": 1, "id": 251723776},
#                  {"type": 0, "out-pport": 1,
#                   "pport": 1, "vlan-id": 3840,
#                   "pop-vlan": 1, "id": 251658241},
#                  {"type": 0, "out-pport": 0,
#                   "pport": 0, "vlan-id": 3840,
#                   "pop-vlan": 1, "id": 251658240}
#    ]}
#
##
{
  "command": "query-rocker-of-dpa-groups",
  "data": {
    "name": "str",
    "*type": "uint8"
  },
  "returns": [
    "RockerOfDpaGroup"
  ]
}


##
# @TpmModel:
#
# An enumeration of TPM models
#
# @tpm-tis: TPM TIS model
#
# Since: 1.5
##
{
  "enum": "TpmModel",
  "data": [
    "tpm-tis"
  ]
}

##
# @query-tpm-models:
#
# Return a list of supported TPM models
#
# Returns: a list of TpmModel
#
# Since: 1.5
#
# Example:
#
# -> { "execute": "query-tpm-models" }
# <- { "return": [ "tpm-tis" ] }
#
##
{
  "command": "query-tpm-models",
  "returns": [
    "TpmModel"
  ]
}

##
# @TpmType:
#
# An enumeration of TPM types
#
# @passthrough: TPM passthrough type
# @emulator: Software Emulator TPM type
#            Since: 2.11
#
# Since: 1.5
##
{
  "enum": "TpmType",
  "data": [
    "passthrough",
    "emulator"
  ]
}

##
# @query-tpm-types:
#
# Return a list of supported TPM types
#
# Returns: a list of TpmType
#
# Since: 1.5
#
# Example:
#
# -> { "execute": "query-tpm-types" }
# <- { "return": [ "passthrough", "emulator" ] }
#
##
{
  "command": "query-tpm-types",
  "returns": [
    "TpmType"
  ]
}

##
# @TPMPassthroughOptions:
#
# Information about the TPM passthrough type
#
# @path: string describing the path used for accessing the TPM device
#
# @cancel-path: string showing the TPM's sysfs cancel file
#               for cancellation of TPM commands while they are executing
#
# Since: 1.5
##
{
  "struct": "TPMPassthroughOptions",
  "data": {
    "*path": "str",
    "*cancel-path": "str"
  }
}

##
# @TPMEmulatorOptions:
#
# Information about the TPM emulator type
#
# @chardev: Name of a unix socket chardev
#
# Since: 2.11
##
{
  "struct": "TPMEmulatorOptions",
  "data": {
    "chardev": "str"
  }
}

##
# @TpmTypeOptions:
#
# A union referencing different TPM backend types' configuration options
#
# @type: 'passthrough' The configuration options for the TPM passthrough type
#        'emulator' The configuration options for TPM emulator backend type
#
# Since: 1.5
##
{
  "union": "TpmTypeOptions",
  "data": {
    "passthrough": "TPMPassthroughOptions",
    "emulator": "TPMEmulatorOptions"
  }
}

##
# @TPMInfo:
#
# Information about the TPM
#
# @id: The Id of the TPM
#
# @model: The TPM frontend model
#
# @options: The TPM (backend) type configuration options
#
# Since: 1.5
##
{
  "struct": "TPMInfo",
  "data": {
    "id": "str",
    "model": "TpmModel",
    "options": "TpmTypeOptions"
  }
}

##
# @query-tpm:
#
# Return information about the TPM device
#
# Returns: @TPMInfo on success
#
# Since: 1.5
#
# Example:
#
# -> { "execute": "query-tpm" }
# <- { "return":
#      [
#        { "model": "tpm-tis",
#          "options":
#            { "type": "passthrough",
#              "data":
#                { "cancel-path": "/sys/class/misc/tpm0/device/cancel",
#                  "path": "/dev/tpm0"
#                }
#            },
#          "id": "tpm0"
#        }
#      ]
#    }
#
##
{
  "command": "query-tpm",
  "returns": [
    "TPMInfo"
  ]
}


##
# @QapiErrorClass:
#
# QEMU error classes
#
# @GenericError: this is used for errors that don't require a specific error
#                class. This should be the default case for most errors
#
# @CommandNotFound: the requested command has not been found
#
# @DeviceNotActive: a device has failed to be become active
#
# @DeviceNotFound: the requested device has not been found
#
# @KVMMissingCap: the requested operation can't be fulfilled because a
#                 required KVM capability is missing
#
# Since: 1.2
##
{
  "enum": "QapiErrorClass",
  "data": [
    "GenericError",
    "CommandNotFound",
    "DeviceNotActive",
    "DeviceNotFound",
    "KVMMissingCap"
  ]
}

##
# @IoOperationType:
#
# An enumeration of the I/O operation types
#
# @read: read operation
#
# @write: write operation
#
# Since: 2.1
##
{
  "enum": "IoOperationType",
  "data": [
    "read",
    "write"
  ]
}

##
# @OnOffAuto:
#
# An enumeration of three options: on, off, and auto
#
# @auto: QEMU selects the value between on and off
#
# @on: Enabled
#
# @off: Disabled
#
# Since: 2.2
##
{
  "enum": "OnOffAuto",
  "data": [
    "auto",
    "on",
    "off"
  ]
}

##
# @OnOffSplit:
#
# An enumeration of three values: on, off, and split
#
# @on: Enabled
#
# @off: Disabled
#
# @split: Mixed
#
# Since: 2.6
##
{
  "enum": "OnOffSplit",
  "data": [
    "on",
    "off",
    "split"
  ]
}

##
# @String:
#
# A fat type wrapping 'str', to be embedded in lists.
#
# Since: 1.2
##
{
  "struct": "String",
  "data": {
    "str": "str"
  }
}

##
# @StrOrNull:
#
# This is a string value or the explicit lack of a string (null
# pointer in C).  Intended for cases when 'optional absent' already
# has a different meaning.
#
# @s: the string value
# @n: no string value
#
# Since: 2.10
##
{
  "alternate": "StrOrNull",
  "data": {
    "s": "str",
    "n": "null"
  }
}


##
# @NetworkAddressFamily:
#
# The network address family
#
# @ipv4: IPV4 family
#
# @ipv6: IPV6 family
#
# @unix: unix socket
#
# @vsock: vsock family (since 2.8)
#
# @unknown: otherwise
#
# Since: 2.1
##
{
  "enum": "NetworkAddressFamily",
  "data": [
    "ipv4",
    "ipv6",
    "unix",
    "vsock",
    "unknown"
  ]
}

##
# @InetSocketAddressBase:
#
# @host: host part of the address
# @port: port part of the address
##
{
  "struct": "InetSocketAddressBase",
  "data": {
    "host": "str",
    "port": "str"
  }
}

##
# @InetSocketAddress:
#
# Captures a socket address or address range in the Internet namespace.
#
# @numeric: true if the host/port are guaranteed to be numeric,
#           false if name resolution should be attempted. Defaults to false.
#           (Since 2.9)
#
# @to: If present, this is range of possible addresses, with port
#      between @port and @to.
#
# @ipv4: whether to accept IPv4 addresses, default try both IPv4 and IPv6
#
# @ipv6: whether to accept IPv6 addresses, default try both IPv4 and IPv6
#
# Since: 1.3
##
{
  "struct": "InetSocketAddress",
  "base": "InetSocketAddressBase",
  "data": {
    "*numeric": "bool",
    "*to": "uint16",
    "*ipv4": "bool",
    "*ipv6": "bool"
  }
}

##
# @UnixSocketAddress:
#
# Captures a socket address in the local ("Unix socket") namespace.
#
# @path: filesystem path to use
#
# Since: 1.3
##
{
  "struct": "UnixSocketAddress",
  "data": {
    "path": "str"
  }
}

##
# @VsockSocketAddress:
#
# Captures a socket address in the vsock namespace.
#
# @cid: unique host identifier
# @port: port
#
# Note: string types are used to allow for possible future hostname or
# service resolution support.
#
# Since: 2.8
##
{
  "struct": "VsockSocketAddress",
  "data": {
    "cid": "str",
    "port": "str"
  }
}

#
# Since: 1.3
##
{
  "union": "SocketAddressLegacy",
  "data": {
    "inet": "InetSocketAddress",
    "unix": "UnixSocketAddress",
    "vsock": "VsockSocketAddress",
    "fd": "String"
  }
}

##
# @SocketAddressType:
#
# Available SocketAddress types
#
# @inet:  Internet address
#
# @unix:  Unix domain socket
#
# Since: 2.9
##
{
  "enum": "SocketAddressType",
  "data": [
    "inet",
    "unix",
    "vsock",
    "fd"
  ]
}

##
# @SocketAddress:
#
# Captures the address of a socket, which could also be a named file
# descriptor
#
# @type:       Transport type
#
# Since: 2.9
##
{
  "union": "SocketAddress",
  "base": {
    "type": "SocketAddressType"
  },
  "discriminator": "type",
  "data": {
    "inet": "InetSocketAddress",
    "unix": "UnixSocketAddress",
    "vsock": "VsockSocketAddress",
    "fd": "String"
  }
}


##
# @set_password:
#
# Sets the password of a remote display session.
#
# @protocol: `vnc' to modify the VNC server password
#            `spice' to modify the Spice server password
#
# @password: the new password
#
# @connected: how to handle existing clients when changing the
#                       password.  If nothing is specified, defaults to `keep'
#                       `fail' to fail the command if clients are connected
#                       `disconnect' to disconnect existing clients
#                       `keep' to maintain existing clients
#
# Returns: Nothing on success
#          If Spice is not enabled, DeviceNotFound
#
# Since: 0.14.0
#
# Example:
#
# -> { "execute": "set_password", "arguments": { "protocol": "vnc",
#                                                "password": "secret" } }
# <- { "return": {} }
#
##
{
  "command": "set_password",
  "data": {
    "protocol": "str",
    "password": "str",
    "*connected": "str"
  }
}

##
# @expire_password:
#
# Expire the password of a remote display server.
#
# @protocol: the name of the remote display protocol `vnc' or `spice'
#
# @time: when to expire the password.
#        `now' to expire the password immediately
#        `never' to cancel password expiration
#        `+INT' where INT is the number of seconds from now (integer)
#        `INT' where INT is the absolute time in seconds
#
# Returns: Nothing on success
#          If @protocol is `spice' and Spice is not active, DeviceNotFound
#
# Since: 0.14.0
#
# Notes: Time is relative to the server and currently there is no way to
#        coordinate server time with client time.  It is not recommended to
#        use the absolute time version of the @time parameter unless you're
#        sure you are on the same machine as the QEMU instance.
#
# Example:
#
# -> { "execute": "expire_password", "arguments": { "protocol": "vnc",
#                                                   "time": "+60" } }
# <- { "return": {} }
#
##
{
  "command": "expire_password",
  "data": {
    "protocol": "str",
    "time": "str"
  }
}

##
# @screendump:
#
# Write a PPM of the VGA screen to a file.
#
# @filename: the path of a new PPM file to store the image
#
# Returns: Nothing on success
#
# Since: 0.14.0
#
# Example:
#
# -> { "execute": "screendump",
#      "arguments": { "filename": "/tmp/image" } }
# <- { "return": {} }
#
##
{
  "command": "screendump",
  "data": {
    "filename": "str"
  }
}

##
# @SpiceBasicInfo:
#
# The basic information for SPICE network connection
#
# @host: IP address
#
# @port: port number
#
# @family: address family
#
# Since: 2.1
##
{
  "struct": "SpiceBasicInfo",
  "data": {
    "host": "str",
    "port": "str",
    "family": "NetworkAddressFamily"
  }
}

##
# @SpiceServerInfo:
#
# Information about a SPICE server
#
# @auth: authentication method
#
# Since: 2.1
##
{
  "struct": "SpiceServerInfo",
  "base": "SpiceBasicInfo",
  "data": {
    "*auth": "str"
  }
}

##
# @SpiceChannel:
#
# Information about a SPICE client channel.
#
# @connection-id: SPICE connection id number.  All channels with the same id
#                 belong to the same SPICE session.
#
# @channel-type: SPICE channel type number.  "1" is the main control
#                channel, filter for this one if you want to track spice
#                sessions only
#
# @channel-id: SPICE channel ID number.  Usually "0", might be different when
#              multiple channels of the same type exist, such as multiple
#              display channels in a multihead setup
#
# @tls: true if the channel is encrypted, false otherwise.
#
# Since: 0.14.0
##
{
  "struct": "SpiceChannel",
  "base": "SpiceBasicInfo",
  "data": {
    "connection-id": "int",
    "channel-type": "int",
    "channel-id": "int",
    "tls": "bool"
  }
}

##
# @SpiceQueryMouseMode:
#
# An enumeration of Spice mouse states.
#
# @client: Mouse cursor position is determined by the client.
#
# @server: Mouse cursor position is determined by the server.
#
# @unknown: No information is available about mouse mode used by
#           the spice server.
#
# Note: spice/enums.h has a SpiceMouseMode already, hence the name.
#
# Since: 1.1
##
{
  "enum": "SpiceQueryMouseMode",
  "data": [
    "client",
    "server",
    "unknown"
  ]
}

##
# @SpiceInfo:
#
# Information about the SPICE session.
#
# @enabled: true if the SPICE server is enabled, false otherwise
#
# @migrated: true if the last guest migration completed and spice
#            migration had completed as well. false otherwise. (since 1.4)
#
# @host: The hostname the SPICE server is bound to.  This depends on
#        the name resolution on the host and may be an IP address.
#
# @port: The SPICE server's port number.
#
# @compiled-version: SPICE server version.
#
# @tls-port: The SPICE server's TLS port number.
#
# @auth: the current authentication type used by the server
#        'none'  if no authentication is being used
#        'spice' uses SASL or direct TLS authentication, depending on command
#                line options
#
# @mouse-mode: The mode in which the mouse cursor is displayed currently. Can
#              be determined by the client or the server, or unknown if spice
#              server doesn't provide this information. (since: 1.1)
#
# @channels: a list of @SpiceChannel for each active spice channel
#
# Since: 0.14.0
##
{
  "struct": "SpiceInfo",
  "data": {
    "enabled": "bool",
    "migrated": "bool",
    "*host": "str",
    "*port": "int",
    "*tls-port": "int",
    "*auth": "str",
    "*compiled-version": "str",
    "mouse-mode": "SpiceQueryMouseMode",
    "*channels": [
      "SpiceChannel"
    ]
  }
}

##
# @query-spice:
#
# Returns information about the current SPICE server
#
# Returns: @SpiceInfo
#
# Since: 0.14.0
#
# Example:
#
# -> { "execute": "query-spice" }
# <- { "return": {
#          "enabled": true,
#          "auth": "spice",
#          "port": 5920,
#          "tls-port": 5921,
#          "host": "0.0.0.0",
#          "channels": [
#             {
#                "port": "54924",
#                "family": "ipv4",
#                "channel-type": 1,
#                "connection-id": 1804289383,
#                "host": "127.0.0.1",
#                "channel-id": 0,
#                "tls": true
#             },
#             {
#                "port": "36710",
#                "family": "ipv4",
#                "channel-type": 4,
#                "connection-id": 1804289383,
#                "host": "127.0.0.1",
#                "channel-id": 0,
#                "tls": false
#             },
#             [ ... more channels follow ... ]
#          ]
#       }
#    }
#
##
{
  "command": "query-spice",
  "returns": "SpiceInfo"
}

##
# @SPICE_CONNECTED:
#
# Emitted when a SPICE client establishes a connection
#
# @server: server information
#
# @client: client information
#
# Since: 0.14.0
#
# Example:
#
# <- { "timestamp": {"seconds": 1290688046, "microseconds": 388707},
#      "event": "SPICE_CONNECTED",
#      "data": {
#        "server": { "port": "5920", "family": "ipv4", "host": "127.0.0.1"},
#        "client": {"port": "52873", "family": "ipv4", "host": "127.0.0.1"}
#    }}
#
##
{
  "event": "SPICE_CONNECTED",
  "data": {
    "server": "SpiceBasicInfo",
    "client": "SpiceBasicInfo"
  }
}

##
# @SPICE_INITIALIZED:
#
# Emitted after initial handshake and authentication takes place (if any)
# and the SPICE channel is up and running
#
# @server: server information
#
# @client: client information
#
# Since: 0.14.0
#
# Example:
#
# <- { "timestamp": {"seconds": 1290688046, "microseconds": 417172},
#      "event": "SPICE_INITIALIZED",
#      "data": {"server": {"auth": "spice", "port": "5921",
#                          "family": "ipv4", "host": "127.0.0.1"},
#               "client": {"port": "49004", "family": "ipv4", "channel-type": 3,
#                          "connection-id": 1804289383, "host": "127.0.0.1",
#                          "channel-id": 0, "tls": true}
#    }}
#
##
{
  "event": "SPICE_INITIALIZED",
  "data": {
    "server": "SpiceServerInfo",
    "client": "SpiceChannel"
  }
}

##
# @SPICE_DISCONNECTED:
#
# Emitted when the SPICE connection is closed
#
# @server: server information
#
# @client: client information
#
# Since: 0.14.0
#
# Example:
#
# <- { "timestamp": {"seconds": 1290688046, "microseconds": 388707},
#      "event": "SPICE_DISCONNECTED",
#      "data": {
#        "server": { "port": "5920", "family": "ipv4", "host": "127.0.0.1"},
#        "client": {"port": "52873", "family": "ipv4", "host": "127.0.0.1"}
#    }}
#
##
{
  "event": "SPICE_DISCONNECTED",
  "data": {
    "server": "SpiceBasicInfo",
    "client": "SpiceBasicInfo"
  }
}

##
# @SPICE_MIGRATE_COMPLETED:
#
# Emitted when SPICE migration has completed
#
# Since: 1.3
#
# Example:
#
# <- { "timestamp": {"seconds": 1290688046, "microseconds": 417172},
#      "event": "SPICE_MIGRATE_COMPLETED" }
#
##
{
  "event": "SPICE_MIGRATE_COMPLETED"
}

##
# @VncBasicInfo:
#
# The basic information for vnc network connection
#
# @host: IP address
#
# @service: The service name of the vnc port. This may depend on the host
#           system's service database so symbolic names should not be relied
#           on.
#
# @family: address family
#
# @websocket: true in case the socket is a websocket (since 2.3).
#
# Since: 2.1
##
{
  "struct": "VncBasicInfo",
  "data": {
    "host": "str",
    "service": "str",
    "family": "NetworkAddressFamily",
    "websocket": "bool"
  }
}

##
# @VncServerInfo:
#
# The network connection information for server
#
# @auth: authentication method used for
#        the plain (non-websocket) VNC server
#
# Since: 2.1
##
{
  "struct": "VncServerInfo",
  "base": "VncBasicInfo",
  "data": {
    "*auth": "str"
  }
}

##
# @VncClientInfo:
#
# Information about a connected VNC client.
#
# @x509_dname: If x509 authentication is in use, the Distinguished
#              Name of the client.
#
# @sasl_username: If SASL authentication is in use, the SASL username
#                 used for authentication.
#
# Since: 0.14.0
##
{
  "struct": "VncClientInfo",
  "base": "VncBasicInfo",
  "data": {
    "*x509_dname": "str",
    "*sasl_username": "str"
  }
}

##
# @VncInfo:
#
# Information about the VNC session.
#
# @enabled: true if the VNC server is enabled, false otherwise
#
# @host: The hostname the VNC server is bound to.  This depends on
#        the name resolution on the host and may be an IP address.
#
# @family: 'ipv6' if the host is listening for IPv6 connections
#                    'ipv4' if the host is listening for IPv4 connections
#                    'unix' if the host is listening on a unix domain socket
#                    'unknown' otherwise
#
# @service: The service name of the server's port.  This may depends
#           on the host system's service database so symbolic names should not
#           be relied on.
#
# @auth: the current authentication type used by the server
#        'none' if no authentication is being used
#        'vnc' if VNC authentication is being used
#        'vencrypt+plain' if VEncrypt is used with plain text authentication
#        'vencrypt+tls+none' if VEncrypt is used with TLS and no authentication
#        'vencrypt+tls+vnc' if VEncrypt is used with TLS and VNC authentication
#        'vencrypt+tls+plain' if VEncrypt is used with TLS and plain text auth
#        'vencrypt+x509+none' if VEncrypt is used with x509 and no auth
#        'vencrypt+x509+vnc' if VEncrypt is used with x509 and VNC auth
#        'vencrypt+x509+plain' if VEncrypt is used with x509 and plain text auth
#        'vencrypt+tls+sasl' if VEncrypt is used with TLS and SASL auth
#        'vencrypt+x509+sasl' if VEncrypt is used with x509 and SASL auth
#
# @clients: a list of @VncClientInfo of all currently connected clients
#
# Since: 0.14.0
##
{
  "struct": "VncInfo",
  "data": {
    "enabled": "bool",
    "*host": "str",
    "*family": "NetworkAddressFamily",
    "*service": "str",
    "*auth": "str",
    "*clients": [
      "VncClientInfo"
    ]
  }
}

##
# @VncPrimaryAuth:
#
# vnc primary authentication method.
#
# Since: 2.3
##
{
  "enum": "VncPrimaryAuth",
  "data": [
    "none",
    "vnc",
    "ra2",
    "ra2ne",
    "tight",
    "ultra",
    "tls",
    "vencrypt",
    "sasl"
  ]
}

##
# @VncVencryptSubAuth:
#
# vnc sub authentication method with vencrypt.
#
# Since: 2.3
##
{
  "enum": "VncVencryptSubAuth",
  "data": [
    "plain",
    "tls-none",
    "x509-none",
    "tls-vnc",
    "x509-vnc",
    "tls-plain",
    "x509-plain",
    "tls-sasl",
    "x509-sasl"
  ]
}


##
# @VncServerInfo2:
#
# The network connection information for server
#
# @auth: The current authentication type used by the servers
#
# @vencrypt: The vencrypt sub authentication type used by the
#            servers, only specified in case auth == vencrypt.
#
# Since: 2.9
##
{
  "struct": "VncServerInfo2",
  "base": "VncBasicInfo",
  "data": {
    "auth": "VncPrimaryAuth",
    "*vencrypt": "VncVencryptSubAuth"
  }
}


##
# @VncInfo2:
#
# Information about a vnc server
#
# @id: vnc server name.
#
# @server: A list of @VncBasincInfo describing all listening sockets.
#          The list can be empty (in case the vnc server is disabled).
#          It also may have multiple entries: normal + websocket,
#          possibly also ipv4 + ipv6 in the future.
#
# @clients: A list of @VncClientInfo of all currently connected clients.
#           The list can be empty, for obvious reasons.
#
# @auth: The current authentication type used by the non-websockets servers
#
# @vencrypt: The vencrypt authentication type used by the servers,
#            only specified in case auth == vencrypt.
#
# @display: The display device the vnc server is linked to.
#
# Since: 2.3
##
{
  "struct": "VncInfo2",
  "data": {
    "id": "str",
    "server": [
      "VncServerInfo2"
    ],
    "clients": [
      "VncClientInfo"
    ],
    "auth": "VncPrimaryAuth",
    "*vencrypt": "VncVencryptSubAuth",
    "*display": "str"
  }
}

##
# @query-vnc:
#
# Returns information about the current VNC server
#
# Returns: @VncInfo
#
# Since: 0.14.0
#
# Example:
#
# -> { "execute": "query-vnc" }
# <- { "return": {
#          "enabled":true,
#          "host":"0.0.0.0",
#          "service":"50402",
#          "auth":"vnc",
#          "family":"ipv4",
#          "clients":[
#             {
#                "host":"127.0.0.1",
#                "service":"50401",
#                "family":"ipv4"
#             }
#          ]
#       }
#    }
#
##
{
  "command": "query-vnc",
  "returns": "VncInfo"
}

##
# @query-vnc-servers:
#
# Returns a list of vnc servers.  The list can be empty.
#
# Returns: a list of @VncInfo2
#
# Since: 2.3
##
{
  "command": "query-vnc-servers",
  "returns": [
    "VncInfo2"
  ]
}

##
# @change-vnc-password:
#
# Change the VNC server password.
#
# @password:  the new password to use with VNC authentication
#
# Since: 1.1
#
# Notes:  An empty password in this command will set the password to the empty
#         string.  Existing clients are unaffected by executing this command.
##
{
  "command": "change-vnc-password",
  "data": {
    "password": "str"
  }
}

##
# @VNC_CONNECTED:
#
# Emitted when a VNC client establishes a connection
#
# @server: server information
#
# @client: client information
#
# Note: This event is emitted before any authentication takes place, thus
# the authentication ID is not provided
#
# Since: 0.13.0
#
# Example:
#
# <- { "event": "VNC_CONNECTED",
#      "data": {
#            "server": { "auth": "sasl", "family": "ipv4",
#                        "service": "5901", "host": "0.0.0.0" },
#            "client": { "family": "ipv4", "service": "58425",
#                        "host": "127.0.0.1" } },
#      "timestamp": { "seconds": 1262976601, "microseconds": 975795 } }
#
##
{
  "event": "VNC_CONNECTED",
  "data": {
    "server": "VncServerInfo",
    "client": "VncBasicInfo"
  }
}

##
# @VNC_INITIALIZED:
#
# Emitted after authentication takes place (if any) and the VNC session is
# made active
#
# @server: server information
#
# @client: client information
#
# Since: 0.13.0
#
# Example:
#
# <-  { "event": "VNC_INITIALIZED",
#       "data": {
#            "server": { "auth": "sasl", "family": "ipv4",
#                        "service": "5901", "host": "0.0.0.0"},
#            "client": { "family": "ipv4", "service": "46089",
#                        "host": "127.0.0.1", "sasl_username": "luiz" } },
#       "timestamp": { "seconds": 1263475302, "microseconds": 150772 } }
#
##
{
  "event": "VNC_INITIALIZED",
  "data": {
    "server": "VncServerInfo",
    "client": "VncClientInfo"
  }
}

##
# @VNC_DISCONNECTED:
#
# Emitted when the connection is closed
#
# @server: server information
#
# @client: client information
#
# Since: 0.13.0
#
# Example:
#
# <- { "event": "VNC_DISCONNECTED",
#      "data": {
#            "server": { "auth": "sasl", "family": "ipv4",
#                        "service": "5901", "host": "0.0.0.0" },
#            "client": { "family": "ipv4", "service": "58425",
#                        "host": "127.0.0.1", "sasl_username": "luiz" } },
#      "timestamp": { "seconds": 1262976601, "microseconds": 975795 } }
#
##
{
  "event": "VNC_DISCONNECTED",
  "data": {
    "server": "VncServerInfo",
    "client": "VncClientInfo"
  }
}

##
# @MouseInfo:
#
# Information about a mouse device.
#
# @name: the name of the mouse device
#
# @index: the index of the mouse device
#
# @current: true if this device is currently receiving mouse events
#
# @absolute: true if this device supports absolute coordinates as input
#
# Since: 0.14.0
##
{
  "struct": "MouseInfo",
  "data": {
    "name": "str",
    "index": "int",
    "current": "bool",
    "absolute": "bool"
  }
}

##
# @query-mice:
#
# Returns information about each active mouse device
#
# Returns: a list of @MouseInfo for each device
#
# Since: 0.14.0
#
# Example:
#
# -> { "execute": "query-mice" }
# <- { "return": [
#          {
#             "name":"QEMU Microsoft Mouse",
#             "index":0,
#             "current":false,
#             "absolute":false
#          },
#          {
#             "name":"QEMU PS/2 Mouse",
#             "index":1,
#             "current":true,
#             "absolute":true
#          }
#       ]
#    }
#
##
{
  "command": "query-mice",
  "returns": [
    "MouseInfo"
  ]
}

##
# @QKeyCode:
#
# An enumeration of key name.
#
# This is used by the @send-key command.
#
# @unmapped: since 2.0
# @pause: since 2.0
# @ro: since 2.4
# @kp_comma: since 2.4
# @kp_equals: since 2.6
# @power: since 2.6
# @hiragana: since 2.9
# @henkan: since 2.9
# @yen: since 2.9
#
# @sleep: since 2.10
# @wake: since 2.10
# @audionext: since 2.10
# @audioprev: since 2.10
# @audiostop: since 2.10
# @audioplay: since 2.10
# @audiomute: since 2.10
# @volumeup: since 2.10
# @volumedown: since 2.10
# @mediaselect: since 2.10
# @mail: since 2.10
# @calculator: since 2.10
# @computer: since 2.10
# @ac_home: since 2.10
# @ac_back: since 2.10
# @ac_forward: since 2.10
# @ac_refresh: since 2.10
# @ac_bookmarks: since 2.10
# altgr, altgr_r: dropped in 2.10
#
# 'sysrq' was mistakenly added to hack around the fact that
# the ps2 driver was not generating correct scancodes sequences
# when 'alt+print' was pressed. This flaw is now fixed and the
# 'sysrq' key serves no further purpose. Any further use of
# 'sysrq' will be transparently changed to 'print', so they
# are effectively synonyms.
#
# Since: 1.3.0
#
##
{
  "enum": "QKeyCode",
  "data": [
    "unmapped",
    "shift",
    "shift_r",
    "alt",
    "alt_r",
    "ctrl",
    "ctrl_r",
    "menu",
    "esc",
    "1",
    "2",
    "3",
    "4",
    "5",
    "6",
    "7",
    "8",
    "9",
    "0",
    "minus",
    "equal",
    "backspace",
    "tab",
    "q",
    "w",
    "e",
    "r",
    "t",
    "y",
    "u",
    "i",
    "o",
    "p",
    "bracket_left",
    "bracket_right",
    "ret",
    "a",
    "s",
    "d",
    "f",
    "g",
    "h",
    "j",
    "k",
    "l",
    "semicolon",
    "apostrophe",
    "grave_accent",
    "backslash",
    "z",
    "x",
    "c",
    "v",
    "b",
    "n",
    "m",
    "comma",
    "dot",
    "slash",
    "asterisk",
    "spc",
    "caps_lock",
    "f1",
    "f2",
    "f3",
    "f4",
    "f5",
    "f6",
    "f7",
    "f8",
    "f9",
    "f10",
    "num_lock",
    "scroll_lock",
    "kp_divide",
    "kp_multiply",
    "kp_subtract",
    "kp_add",
    "kp_enter",
    "kp_decimal",
    "sysrq",
    "kp_0",
    "kp_1",
    "kp_2",
    "kp_3",
    "kp_4",
    "kp_5",
    "kp_6",
    "kp_7",
    "kp_8",
    "kp_9",
    "less",
    "f11",
    "f12",
    "print",
    "home",
    "pgup",
    "pgdn",
    "end",
    "left",
    "up",
    "down",
    "right",
    "insert",
    "delete",
    "stop",
    "again",
    "props",
    "undo",
    "front",
    "copy",
    "open",
    "paste",
    "find",
    "cut",
    "lf",
    "help",
    "meta_l",
    "meta_r",
    "compose",
    "pause",
    "ro",
    "hiragana",
    "henkan",
    "yen",
    "kp_comma",
    "kp_equals",
    "power",
    "sleep",
    "wake",
    "audionext",
    "audioprev",
    "audiostop",
    "audioplay",
    "audiomute",
    "volumeup",
    "volumedown",
    "mediaselect",
    "mail",
    "calculator",
    "computer",
    "ac_home",
    "ac_back",
    "ac_forward",
    "ac_refresh",
    "ac_bookmarks"
  ]
}

##
# @KeyValue:
#
# Represents a keyboard key.
#
# Since: 1.3.0
##
{
  "union": "KeyValue",
  "data": {
    "number": "int",
    "qcode": "QKeyCode"
  }
}

##
# @send-key:
#
# Send keys to guest.
#
# @keys: An array of @KeyValue elements. All @KeyValues in this array are
#        simultaneously sent to the guest. A @KeyValue.number value is sent
#        directly to the guest, while @KeyValue.qcode must be a valid
#        @QKeyCode value
#
# @hold-time: time to delay key up events, milliseconds. Defaults
#             to 100
#
# Returns: Nothing on success
#          If key is unknown or redundant, InvalidParameter
#
# Since: 1.3.0
#
# Example:
#
# -> { "execute": "send-key",
#      "arguments": { "keys": [ { "type": "qcode", "data": "ctrl" },
#                               { "type": "qcode", "data": "alt" },
#                               { "type": "qcode", "data": "delete" } ] } }
# <- { "return": {} }
#
##
{
  "command": "send-key",
  "data": {
    "keys": [
      "KeyValue"
    ],
    "*hold-time": "int"
  }
}

##
# @InputButton:
#
# Button of a pointer input device (mouse, tablet).
#
# @side: front side button of a 5-button mouse (since 2.9)
#
# @extra: rear side button of a 5-button mouse (since 2.9)
#
# Since: 2.0
##
{
  "enum": "InputButton",
  "data": [
    "left",
    "middle",
    "right",
    "wheel-up",
    "wheel-down",
    "side",
    "extra"
  ]
}

##
# @InputAxis:
#
# Position axis of a pointer input device (mouse, tablet).
#
# Since: 2.0
##
{
  "enum": "InputAxis",
  "data": [
    "x",
    "y"
  ]
}

##
# @InputKeyEvent:
#
# Keyboard input event.
#
# @key:    Which key this event is for.
# @down:   True for key-down and false for key-up events.
#
# Since: 2.0
##
{
  "struct": "InputKeyEvent",
  "data": {
    "key": "KeyValue",
    "down": "bool"
  }
}

##
# @InputBtnEvent:
#
# Pointer button input event.
#
# @button: Which button this event is for.
# @down:   True for key-down and false for key-up events.
#
# Since: 2.0
##
{
  "struct": "InputBtnEvent",
  "data": {
    "button": "InputButton",
    "down": "bool"
  }
}

##
# @InputMoveEvent:
#
# Pointer motion input event.
#
# @axis:   Which axis is referenced by @value.
# @value:  Pointer position.  For absolute coordinates the
#          valid range is 0 -> 0x7ffff
#
# Since: 2.0
##
{
  "struct": "InputMoveEvent",
  "data": {
    "axis": "InputAxis",
    "value": "int"
  }
}

##
# @InputEvent:
#
# Input event union.
#
# @type: the input type, one of:
#  - 'key': Input event of Keyboard
#  - 'btn': Input event of pointer buttons
#  - 'rel': Input event of relative pointer motion
#  - 'abs': Input event of absolute pointer motion
#
# Since: 2.0
##
{
  "union": "InputEvent",
  "data": {
    "key": "InputKeyEvent",
    "btn": "InputBtnEvent",
    "rel": "InputMoveEvent",
    "abs": "InputMoveEvent"
  }
}

##
# @input-send-event:
#
# Send input event(s) to guest.
#
# @device: display device to send event(s) to.
# @head: head to send event(s) to, in case the
#        display device supports multiple scanouts.
# @events: List of InputEvent union.
#
# Returns: Nothing on success.
#
# The @device and @head parameters can be used to send the input event
# to specific input devices in case (a) multiple input devices of the
# same kind are added to the virtual machine and (b) you have
# configured input routing (see docs/multiseat.txt) for those input
# devices.  The parameters work exactly like the device and head
# properties of input devices.  If @device is missing, only devices
# that have no input routing config are admissible.  If @device is
# specified, both input devices with and without input routing config
# are admissible, but devices with input routing config take
# precedence.
#
# Since: 2.6
#
# Note: The consoles are visible in the qom tree, under
# /backend/console[$index]. They have a device link and head property,
# so it is possible to map which console belongs to which device and
# display.
#
# Example:
#
# 1. Press left mouse button.
#
# -> { "execute": "input-send-event",
#     "arguments": { "device": "video0",
#                    "events": [ { "type": "btn",
#                    "data" : { "down": true, "button": "left" } } ] } }
# <- { "return": {} }
#
# -> { "execute": "input-send-event",
#     "arguments": { "device": "video0",
#                    "events": [ { "type": "btn",
#                    "data" : { "down": false, "button": "left" } } ] } }
# <- { "return": {} }
#
# 2. Press ctrl-alt-del.
#
# -> { "execute": "input-send-event",
#      "arguments": { "events": [
#         { "type": "key", "data" : { "down": true,
#           "key": {"type": "qcode", "data": "ctrl" } } },
#         { "type": "key", "data" : { "down": true,
#           "key": {"type": "qcode", "data": "alt" } } },
#         { "type": "key", "data" : { "down": true,
#           "key": {"type": "qcode", "data": "delete" } } } ] } }
# <- { "return": {} }
#
# 3. Move mouse pointer to absolute coordinates (20000, 400).
#
# -> { "execute": "input-send-event" ,
#   "arguments": { "events": [
#                { "type": "abs", "data" : { "axis": "x", "value" : 20000 } },
#                { "type": "abs", "data" : { "axis": "y", "value" : 400 } } ] } }
# <- { "return": {} }
#
##
{
  "command": "input-send-event",
  "data": {
    "*device": "str",
    "*head": "int",
    "events": [
      "InputEvent"
    ]
  }
}


##
# @QapiErrorClass:
#
# QEMU error classes
#
# @GenericError: this is used for errors that don't require a specific error
#                class. This should be the default case for most errors
#
# @CommandNotFound: the requested command has not been found
#
# @DeviceNotActive: a device has failed to be become active
#
# @DeviceNotFound: the requested device has not been found
#
# @KVMMissingCap: the requested operation can't be fulfilled because a
#                 required KVM capability is missing
#
# Since: 1.2
##
{
  "enum": "QapiErrorClass",
  "data": [
    "GenericError",
    "CommandNotFound",
    "DeviceNotActive",
    "DeviceNotFound",
    "KVMMissingCap"
  ]
}

##
# @IoOperationType:
#
# An enumeration of the I/O operation types
#
# @read: read operation
#
# @write: write operation
#
# Since: 2.1
##
{
  "enum": "IoOperationType",
  "data": [
    "read",
    "write"
  ]
}

##
# @OnOffAuto:
#
# An enumeration of three options: on, off, and auto
#
# @auto: QEMU selects the value between on and off
#
# @on: Enabled
#
# @off: Disabled
#
# Since: 2.2
##
{
  "enum": "OnOffAuto",
  "data": [
    "auto",
    "on",
    "off"
  ]
}

##
# @OnOffSplit:
#
# An enumeration of three values: on, off, and split
#
# @on: Enabled
#
# @off: Disabled
#
# @split: Mixed
#
# Since: 2.6
##
{
  "enum": "OnOffSplit",
  "data": [
    "on",
    "off",
    "split"
  ]
}

##
# @String:
#
# A fat type wrapping 'str', to be embedded in lists.
#
# Since: 1.2
##
{
  "struct": "String",
  "data": {
    "str": "str"
  }
}

##
# @StrOrNull:
#
# This is a string value or the explicit lack of a string (null
# pointer in C).  Intended for cases when 'optional absent' already
# has a different meaning.
#
# @s: the string value
# @n: no string value
#
# Since: 2.10
##
{
  "alternate": "StrOrNull",
  "data": {
    "s": "str",
    "n": "null"
  }
}


##
# @MigrationStats:
#
# Detailed migration status.
#
# @transferred: amount of bytes already transferred to the target VM
#
# @remaining: amount of bytes remaining to be transferred to the target VM
#
# @total: total amount of bytes involved in the migration process
#
# @duplicate: number of duplicate (zero) pages (since 1.2)
#
# @skipped: number of skipped zero pages (since 1.5)
#
# @normal: number of normal pages (since 1.2)
#
# @normal-bytes: number of normal bytes sent (since 1.2)
#
# @dirty-pages-rate: number of pages dirtied by second by the
#        guest (since 1.3)
#
# @mbps: throughput in megabits/sec. (since 1.6)
#
# @dirty-sync-count: number of times that dirty ram was synchronized (since 2.1)
#
# @postcopy-requests: The number of page requests received from the destination
#        (since 2.7)
#
# @page-size: The number of bytes per page for the various page-based
#        statistics (since 2.10)
#
# Since: 0.14.0
##
{
  "struct": "MigrationStats",
  "data": {
    "transferred": "int",
    "remaining": "int",
    "total": "int",
    "duplicate": "int",
    "skipped": "int",
    "normal": "int",
    "normal-bytes": "int",
    "dirty-pages-rate": "int",
    "mbps": "number",
    "dirty-sync-count": "int",
    "postcopy-requests": "int",
    "page-size": "int"
  }
}

##
# @XBZRLECacheStats:
#
# Detailed XBZRLE migration cache statistics
#
# @cache-size: XBZRLE cache size
#
# @bytes: amount of bytes already transferred to the target VM
#
# @pages: amount of pages transferred to the target VM
#
# @cache-miss: number of cache miss
#
# @cache-miss-rate: rate of cache miss (since 2.1)
#
# @overflow: number of overflows
#
# Since: 1.2
##
{
  "struct": "XBZRLECacheStats",
  "data": {
    "cache-size": "int",
    "bytes": "int",
    "pages": "int",
    "cache-miss": "int",
    "cache-miss-rate": "number",
    "overflow": "int"
  }
}

##
# @MigrationStatus:
#
# An enumeration of migration status.
#
# @none: no migration has ever happened.
#
# @setup: migration process has been initiated.
#
# @cancelling: in the process of cancelling migration.
#
# @cancelled: cancelling migration is finished.
#
# @active: in the process of doing migration.
#
# @postcopy-active: like active, but now in postcopy mode. (since 2.5)
#
# @completed: migration is finished.
#
# @failed: some error occurred during migration process.
#
# @colo: VM is in the process of fault tolerance, VM can not get into this
#        state unless colo capability is enabled for migration. (since 2.8)
#
# @pre-switchover: Paused before device serialisation. (since 2.11)
#
# @device: During device serialisation when pause-before-switchover is enabled
#        (since 2.11)
#
# Since: 2.3
#
##
{
  "enum": "MigrationStatus",
  "data": [
    "none",
    "setup",
    "cancelling",
    "cancelled",
    "active",
    "postcopy-active",
    "completed",
    "failed",
    "colo",
    "pre-switchover",
    "device"
  ]
}

##
# @MigrationInfo:
#
# Information about current migration process.
#
# @status: @MigrationStatus describing the current migration status.
#          If this field is not returned, no migration process
#          has been initiated
#
# @ram: @MigrationStats containing detailed migration
#       status, only returned if status is 'active' or
#       'completed'(since 1.2)
#
# @disk: @MigrationStats containing detailed disk migration
#        status, only returned if status is 'active' and it is a block
#        migration
#
# @xbzrle-cache: @XBZRLECacheStats containing detailed XBZRLE
#                migration statistics, only returned if XBZRLE feature is on and
#                status is 'active' or 'completed' (since 1.2)
#
# @total-time: total amount of milliseconds since migration started.
#        If migration has ended, it returns the total migration
#        time. (since 1.2)
#
# @downtime: only present when migration finishes correctly
#        total downtime in milliseconds for the guest.
#        (since 1.3)
#
# @expected-downtime: only present while migration is active
#        expected downtime in milliseconds for the guest in last walk
#        of the dirty bitmap. (since 1.3)
#
# @setup-time: amount of setup time in milliseconds _before_ the
#        iterations begin but _after_ the QMP command is issued. This is designed
#        to provide an accounting of any activities (such as RDMA pinning) which
#        may be expensive, but do not actually occur during the iterative
#        migration rounds themselves. (since 1.6)
#
# @cpu-throttle-percentage: percentage of time guest cpus are being
#        throttled during auto-converge. This is only present when auto-converge
#        has started throttling guest cpus. (Since 2.7)
#
# @error-desc: the human readable error description string, when
#              @status is 'failed'. Clients should not attempt to parse the
#              error strings. (Since 2.7)
#
# Since: 0.14.0
##
{
  "struct": "MigrationInfo",
  "data": {
    "*status": "MigrationStatus",
    "*ram": "MigrationStats",
    "*disk": "MigrationStats",
    "*xbzrle-cache": "XBZRLECacheStats",
    "*total-time": "int",
    "*expected-downtime": "int",
    "*downtime": "int",
    "*setup-time": "int",
    "*cpu-throttle-percentage": "int",
    "*error-desc": "str"
  }
}

##
# @query-migrate:
#
# Returns information about current migration process. If migration
# is active there will be another json-object with RAM migration
# status and if block migration is active another one with block
# migration status.
#
# Returns: @MigrationInfo
#
# Since: 0.14.0
#
# Example:
#
# 1. Before the first migration
#
# -> { "execute": "query-migrate" }
# <- { "return": {} }
#
# 2. Migration is done and has succeeded
#
# -> { "execute": "query-migrate" }
# <- { "return": {
#         "status": "completed",
#         "ram":{
#           "transferred":123,
#           "remaining":123,
#           "total":246,
#           "total-time":12345,
#           "setup-time":12345,
#           "downtime":12345,
#           "duplicate":123,
#           "normal":123,
#           "normal-bytes":123456,
#           "dirty-sync-count":15
#         }
#      }
#    }
#
# 3. Migration is done and has failed
#
# -> { "execute": "query-migrate" }
# <- { "return": { "status": "failed" } }
#
# 4. Migration is being performed and is not a block migration:
#
# -> { "execute": "query-migrate" }
# <- {
#       "return":{
#          "status":"active",
#          "ram":{
#             "transferred":123,
#             "remaining":123,
#             "total":246,
#             "total-time":12345,
#             "setup-time":12345,
#             "expected-downtime":12345,
#             "duplicate":123,
#             "normal":123,
#             "normal-bytes":123456,
#             "dirty-sync-count":15
#          }
#       }
#    }
#
# 5. Migration is being performed and is a block migration:
#
# -> { "execute": "query-migrate" }
# <- {
#       "return":{
#          "status":"active",
#          "ram":{
#             "total":1057024,
#             "remaining":1053304,
#             "transferred":3720,
#             "total-time":12345,
#             "setup-time":12345,
#             "expected-downtime":12345,
#             "duplicate":123,
#             "normal":123,
#             "normal-bytes":123456,
#             "dirty-sync-count":15
#          },
#          "disk":{
#             "total":20971520,
#             "remaining":20880384,
#             "transferred":91136
#          }
#       }
#    }
#
# 6. Migration is being performed and XBZRLE is active:
#
# -> { "execute": "query-migrate" }
# <- {
#       "return":{
#          "status":"active",
#          "capabilities" : [ { "capability": "xbzrle", "state" : true } ],
#          "ram":{
#             "total":1057024,
#             "remaining":1053304,
#             "transferred":3720,
#             "total-time":12345,
#             "setup-time":12345,
#             "expected-downtime":12345,
#             "duplicate":10,
#             "normal":3333,
#             "normal-bytes":3412992,
#             "dirty-sync-count":15
#          },
#          "xbzrle-cache":{
#             "cache-size":67108864,
#             "bytes":20971520,
#             "pages":2444343,
#             "cache-miss":2244,
#             "cache-miss-rate":0.123,
#             "overflow":34434
#          }
#       }
#    }
#
##
{
  "command": "query-migrate",
  "returns": "MigrationInfo"
}

##
# @MigrationCapability:
#
# Migration capabilities enumeration
#
# @xbzrle: Migration supports xbzrle (Xor Based Zero Run Length Encoding).
#          This feature allows us to minimize migration traffic for certain work
#          loads, by sending compressed difference of the pages
#
# @rdma-pin-all: Controls whether or not the entire VM memory footprint is
#          mlock()'d on demand or all at once. Refer to docs/rdma.txt for usage.
#          Disabled by default. (since 2.0)
#
# @zero-blocks: During storage migration encode blocks of zeroes efficiently. This
#          essentially saves 1MB of zeroes per block on the wire. Enabling requires
#          source and target VM to support this feature. To enable it is sufficient
#          to enable the capability on the source VM. The feature is disabled by
#          default. (since 1.6)
#
# @compress: Use multiple compression threads to accelerate live migration.
#          This feature can help to reduce the migration traffic, by sending
#          compressed pages. Please note that if compress and xbzrle are both
#          on, compress only takes effect in the ram bulk stage, after that,
#          it will be disabled and only xbzrle takes effect, this can help to
#          minimize migration traffic. The feature is disabled by default.
#          (since 2.4 )
#
# @events: generate events for each migration state change
#          (since 2.4 )
#
# @auto-converge: If enabled, QEMU will automatically throttle down the guest
#          to speed up convergence of RAM migration. (since 1.6)
#
# @postcopy-ram: Start executing on the migration target before all of RAM has
#          been migrated, pulling the remaining pages along as needed. NOTE: If
#          the migration fails during postcopy the VM will fail.  (since 2.6)
#
# @x-colo: If enabled, migration will never end, and the state of the VM on the
#        primary side will be migrated continuously to the VM on secondary
#        side, this process is called COarse-Grain LOck Stepping (COLO) for
#        Non-stop Service. (since 2.8)
#
# @release-ram: if enabled, qemu will free the migrated ram pages on the source
#        during postcopy-ram migration. (since 2.9)
#
# @block: If enabled, QEMU will also migrate the contents of all block
#          devices.  Default is disabled.  A possible alternative uses
#          mirror jobs to a builtin NBD server on the destination, which
#          offers more flexibility.
#          (Since 2.10)
#
# @return-path: If enabled, migration will use the return path even
#               for precopy. (since 2.10)
#
# @pause-before-switchover: Pause outgoing migration before serialising device
#          state and before disabling block IO (since 2.11)
#
# @x-multifd: Use more than one fd for migration (since 2.11)
#
# Since: 1.2
##
{
  "enum": "MigrationCapability",
  "data": [
    "xbzrle",
    "rdma-pin-all",
    "auto-converge",
    "zero-blocks",
    "compress",
    "events",
    "postcopy-ram",
    "x-colo",
    "release-ram",
    "block",
    "return-path",
    "pause-before-switchover",
    "x-multifd"
  ]
}

##
# @MigrationCapabilityStatus:
#
# Migration capability information
#
# @capability: capability enum
#
# @state: capability state bool
#
# Since: 1.2
##
{
  "struct": "MigrationCapabilityStatus",
  "data": {
    "capability": "MigrationCapability",
    "state": "bool"
  }
}

##
# @migrate-set-capabilities:
#
# Enable/Disable the following migration capabilities (like xbzrle)
#
# @capabilities: json array of capability modifications to make
#
# Since: 1.2
#
# Example:
#
# -> { "execute": "migrate-set-capabilities" , "arguments":
#      { "capabilities": [ { "capability": "xbzrle", "state": true } ] } }
#
##
{
  "command": "migrate-set-capabilities",
  "data": {
    "capabilities": [
      "MigrationCapabilityStatus"
    ]
  }
}

##
# @query-migrate-capabilities:
#
# Returns information about the current migration capabilities status
#
# Returns: @MigrationCapabilitiesStatus
#
# Since: 1.2
#
# Example:
#
# -> { "execute": "query-migrate-capabilities" }
# <- { "return": [
#       {"state": false, "capability": "xbzrle"},
#       {"state": false, "capability": "rdma-pin-all"},
#       {"state": false, "capability": "auto-converge"},
#       {"state": false, "capability": "zero-blocks"},
#       {"state": false, "capability": "compress"},
#       {"state": true, "capability": "events"},
#       {"state": false, "capability": "postcopy-ram"},
#       {"state": false, "capability": "x-colo"}
#    ]}
#
##
{
  "command": "query-migrate-capabilities",
  "returns": [
    "MigrationCapabilityStatus"
  ]
}

##
# @MigrationParameter:
#
# Migration parameters enumeration
#
# @compress-level: Set the compression level to be used in live migration,
#          the compression level is an integer between 0 and 9, where 0 means
#          no compression, 1 means the best compression speed, and 9 means best
#          compression ratio which will consume more CPU.
#
# @compress-threads: Set compression thread count to be used in live migration,
#          the compression thread count is an integer between 1 and 255.
#
# @decompress-threads: Set decompression thread count to be used in live
#          migration, the decompression thread count is an integer between 1
#          and 255. Usually, decompression is at least 4 times as fast as
#          compression, so set the decompress-threads to the number about 1/4
#          of compress-threads is adequate.
#
# @cpu-throttle-initial: Initial percentage of time guest cpus are throttled
#                        when migration auto-converge is activated. The
#                        default value is 20. (Since 2.7)
#
# @cpu-throttle-increment: throttle percentage increase each time
#                          auto-converge detects that migration is not making
#                          progress. The default value is 10. (Since 2.7)
#
# @tls-creds: ID of the 'tls-creds' object that provides credentials for
#             establishing a TLS connection over the migration data channel.
#             On the outgoing side of the migration, the credentials must
#             be for a 'client' endpoint, while for the incoming side the
#             credentials must be for a 'server' endpoint. Setting this
#             will enable TLS for all migrations. The default is unset,
#             resulting in unsecured migration at the QEMU level. (Since 2.7)
#
# @tls-hostname: hostname of the target host for the migration. This is
#                required when using x509 based TLS credentials and the
#                migration URI does not already include a hostname. For
#                example if using fd: or exec: based migration, the
#                hostname must be provided so that the server's x509
#                certificate identity can be validated. (Since 2.7)
#
# @max-bandwidth: to set maximum speed for migration. maximum speed in
#                 bytes per second. (Since 2.8)
#
# @downtime-limit: set maximum tolerated downtime for migration. maximum
#                  downtime in milliseconds (Since 2.8)
#
# @x-checkpoint-delay: The delay time (in ms) between two COLO checkpoints in
#          periodic mode. (Since 2.8)
#
# @block-incremental: Affects how much storage is migrated when the
# 	block migration capability is enabled.  When false, the entire
# 	storage backing chain is migrated into a flattened image at
# 	the destination; when true, only the active qcow2 layer is
# 	migrated and the destination must already have access to the
# 	same backing chain as was used on the source.  (since 2.10)
#
# @x-multifd-channels: Number of channels used to migrate data in
#                     parallel. This is the same number that the
#                     number of sockets used for migration.  The
#                     default value is 2 (since 2.11)
#
# @x-multifd-page-count: Number of pages sent together to a thread.
#                        The default value is 16 (since 2.11)
#
# @xbzrle-cache-size: cache size to be used by XBZRLE migration.  It
#                     needs to be a multiple of the target page size
#                     and a power of 2
#                     (Since 2.11)
#
# Since: 2.4
##
{
  "enum": "MigrationParameter",
  "data": [
    "compress-level",
    "compress-threads",
    "decompress-threads",
    "cpu-throttle-initial",
    "cpu-throttle-increment",
    "tls-creds",
    "tls-hostname",
    "max-bandwidth",
    "downtime-limit",
    "x-checkpoint-delay",
    "block-incremental",
    "x-multifd-channels",
    "x-multifd-page-count",
    "xbzrle-cache-size"
  ]
}

##
# @MigrateSetParameters:
#
# @compress-level: compression level
#
# @compress-threads: compression thread count
#
# @decompress-threads: decompression thread count
#
# @cpu-throttle-initial: Initial percentage of time guest cpus are
#                        throttled when migration auto-converge is activated.
#                        The default value is 20. (Since 2.7)
#
# @cpu-throttle-increment: throttle percentage increase each time
#                          auto-converge detects that migration is not making
#                          progress. The default value is 10. (Since 2.7)
#
# @tls-creds: ID of the 'tls-creds' object that provides credentials
#             for establishing a TLS connection over the migration data
#             channel. On the outgoing side of the migration, the credentials
#             must be for a 'client' endpoint, while for the incoming side the
#             credentials must be for a 'server' endpoint. Setting this
#             to a non-empty string enables TLS for all migrations.
#             An empty string means that QEMU will use plain text mode for
#             migration, rather than TLS (Since 2.9)
#             Previously (since 2.7), this was reported by omitting
#             tls-creds instead.
#
# @tls-hostname: hostname of the target host for the migration. This
#                is required when using x509 based TLS credentials and the
#                migration URI does not already include a hostname. For
#                example if using fd: or exec: based migration, the
#                hostname must be provided so that the server's x509
#                certificate identity can be validated. (Since 2.7)
#                An empty string means that QEMU will use the hostname
#                associated with the migration URI, if any. (Since 2.9)
#                Previously (since 2.7), this was reported by omitting
#                tls-hostname instead.
#
# @max-bandwidth: to set maximum speed for migration. maximum speed in
#                 bytes per second. (Since 2.8)
#
# @downtime-limit: set maximum tolerated downtime for migration. maximum
#                  downtime in milliseconds (Since 2.8)
#
# @x-checkpoint-delay: the delay time between two COLO checkpoints. (Since 2.8)
#
# @block-incremental: Affects how much storage is migrated when the
# 	block migration capability is enabled.  When false, the entire
# 	storage backing chain is migrated into a flattened image at
# 	the destination; when true, only the active qcow2 layer is
# 	migrated and the destination must already have access to the
# 	same backing chain as was used on the source.  (since 2.10)
#
# @x-multifd-channels: Number of channels used to migrate data in
#                     parallel. This is the same number that the
#                     number of sockets used for migration.  The
#                     default value is 2 (since 2.11)
#
# @x-multifd-page-count: Number of pages sent together to a thread.
#                        The default value is 16 (since 2.11)
#
# @xbzrle-cache-size: cache size to be used by XBZRLE migration.  It
#                     needs to be a multiple of the target page size
#                     and a power of 2
#                     (Since 2.11)
# Since: 2.4
##
# TODO either fuse back into MigrationParameters, or make
# MigrationParameters members mandatory
{
  "struct": "MigrateSetParameters",
  "data": {
    "*compress-level": "int",
    "*compress-threads": "int",
    "*decompress-threads": "int",
    "*cpu-throttle-initial": "int",
    "*cpu-throttle-increment": "int",
    "*tls-creds": "StrOrNull",
    "*tls-hostname": "StrOrNull",
    "*max-bandwidth": "int",
    "*downtime-limit": "int",
    "*x-checkpoint-delay": "int",
    "*block-incremental": "bool",
    "*x-multifd-channels": "int",
    "*x-multifd-page-count": "int",
    "*xbzrle-cache-size": "size"
  }
}

##
# @migrate-set-parameters:
#
# Set various migration parameters.
#
# Since: 2.4
#
# Example:
#
# -> { "execute": "migrate-set-parameters" ,
#      "arguments": { "compress-level": 1 } }
#
##
{
  "command": "migrate-set-parameters",
  "boxed": true,
  "data": "MigrateSetParameters"
}

##
# @MigrationParameters:
#
# The optional members aren't actually optional.
#
# @compress-level: compression level
#
# @compress-threads: compression thread count
#
# @decompress-threads: decompression thread count
#
# @cpu-throttle-initial: Initial percentage of time guest cpus are
#                        throttled when migration auto-converge is activated.
#                        (Since 2.7)
#
# @cpu-throttle-increment: throttle percentage increase each time
#                          auto-converge detects that migration is not making
#                          progress. (Since 2.7)
#
# @tls-creds: ID of the 'tls-creds' object that provides credentials
#             for establishing a TLS connection over the migration data
#             channel. On the outgoing side of the migration, the credentials
#             must be for a 'client' endpoint, while for the incoming side the
#             credentials must be for a 'server' endpoint.
#             An empty string means that QEMU will use plain text mode for
#             migration, rather than TLS (Since 2.7)
#             Note: 2.8 reports this by omitting tls-creds instead.
#
# @tls-hostname: hostname of the target host for the migration. This
#                is required when using x509 based TLS credentials and the
#                migration URI does not already include a hostname. For
#                example if using fd: or exec: based migration, the
#                hostname must be provided so that the server's x509
#                certificate identity can be validated. (Since 2.7)
#                An empty string means that QEMU will use the hostname
#                associated with the migration URI, if any. (Since 2.9)
#                Note: 2.8 reports this by omitting tls-hostname instead.
#
# @max-bandwidth: to set maximum speed for migration. maximum speed in
#                 bytes per second. (Since 2.8)
#
# @downtime-limit: set maximum tolerated downtime for migration. maximum
#                  downtime in milliseconds (Since 2.8)
#
# @x-checkpoint-delay: the delay time between two COLO checkpoints. (Since 2.8)
#
# @block-incremental: Affects how much storage is migrated when the
# 	block migration capability is enabled.  When false, the entire
# 	storage backing chain is migrated into a flattened image at
# 	the destination; when true, only the active qcow2 layer is
# 	migrated and the destination must already have access to the
# 	same backing chain as was used on the source.  (since 2.10)
#
# @x-multifd-channels: Number of channels used to migrate data in
#                     parallel. This is the same number that the
#                     number of sockets used for migration.
#                     The default value is 2 (since 2.11)
#
# @x-multifd-page-count: Number of pages sent together to a thread.
#                        The default value is 16 (since 2.11)
#
# @xbzrle-cache-size: cache size to be used by XBZRLE migration.  It
#                     needs to be a multiple of the target page size
#                     and a power of 2
#                     (Since 2.11)
# Since: 2.4
##
{
  "struct": "MigrationParameters",
  "data": {
    "*compress-level": "int",
    "*compress-threads": "int",
    "*decompress-threads": "int",
    "*cpu-throttle-initial": "int",
    "*cpu-throttle-increment": "int",
    "*tls-creds": "str",
    "*tls-hostname": "str",
    "*max-bandwidth": "int",
    "*downtime-limit": "int",
    "*x-checkpoint-delay": "int",
    "*block-incremental": "bool",
    "*x-multifd-channels": "int",
    "*x-multifd-page-count": "int",
    "*xbzrle-cache-size": "size"
  }
}

##
# @query-migrate-parameters:
#
# Returns information about the current migration parameters
#
# Returns: @MigrationParameters
#
# Since: 2.4
#
# Example:
#
# -> { "execute": "query-migrate-parameters" }
# <- { "return": {
#          "decompress-threads": 2,
#          "cpu-throttle-increment": 10,
#          "compress-threads": 8,
#          "compress-level": 1,
#          "cpu-throttle-initial": 20,
#          "max-bandwidth": 33554432,
#          "downtime-limit": 300
#       }
#    }
#
##
{
  "command": "query-migrate-parameters",
  "returns": "MigrationParameters"
}

##
# @client_migrate_info:
#
# Set migration information for remote display.  This makes the server
# ask the client to automatically reconnect using the new parameters
# once migration finished successfully.  Only implemented for SPICE.
#
# @protocol:     must be "spice"
# @hostname:     migration target hostname
# @port:         spice tcp port for plaintext channels
# @tls-port:     spice tcp port for tls-secured channels
# @cert-subject: server certificate subject
#
# Since: 0.14.0
#
# Example:
#
# -> { "execute": "client_migrate_info",
#      "arguments": { "protocol": "spice",
#                     "hostname": "virt42.lab.kraxel.org",
#                     "port": 1234 } }
# <- { "return": {} }
#
##
{
  "command": "client_migrate_info",
  "data": {
    "protocol": "str",
    "hostname": "str",
    "*port": "int",
    "*tls-port": "int",
    "*cert-subject": "str"
  }
}

##
# @migrate-start-postcopy:
#
# Followup to a migration command to switch the migration to postcopy mode.
# The postcopy-ram capability must be set before the original migration
# command.
#
# Since: 2.5
#
# Example:
#
# -> { "execute": "migrate-start-postcopy" }
# <- { "return": {} }
#
##
{
  "command": "migrate-start-postcopy"
}

##
# @MIGRATION:
#
# Emitted when a migration event happens
#
# @status: @MigrationStatus describing the current migration status.
#
# Since: 2.4
#
# Example:
#
# <- {"timestamp": {"seconds": 1432121972, "microseconds": 744001},
#     "event": "MIGRATION",
#     "data": {"status": "completed"} }
#
##
{
  "event": "MIGRATION",
  "data": {
    "status": "MigrationStatus"
  }
}

##
# @MIGRATION_PASS:
#
# Emitted from the source side of a migration at the start of each pass
# (when it syncs the dirty bitmap)
#
# @pass: An incrementing count (starting at 1 on the first pass)
#
# Since: 2.6
#
# Example:
#
# { "timestamp": {"seconds": 1449669631, "microseconds": 239225},
#   "event": "MIGRATION_PASS", "data": {"pass": 2} }
#
##
{
  "event": "MIGRATION_PASS",
  "data": {
    "pass": "int"
  }
}

##
# @COLOMessage:
#
# The message transmission between Primary side and Secondary side.
#
# @checkpoint-ready: Secondary VM (SVM) is ready for checkpointing
#
# @checkpoint-request: Primary VM (PVM) tells SVM to prepare for checkpointing
#
# @checkpoint-reply: SVM gets PVM's checkpoint request
#
# @vmstate-send: VM's state will be sent by PVM.
#
# @vmstate-size: The total size of VMstate.
#
# @vmstate-received: VM's state has been received by SVM.
#
# @vmstate-loaded: VM's state has been loaded by SVM.
#
# Since: 2.8
##
{
  "enum": "COLOMessage",
  "data": [
    "checkpoint-ready",
    "checkpoint-request",
    "checkpoint-reply",
    "vmstate-send",
    "vmstate-size",
    "vmstate-received",
    "vmstate-loaded"
  ]
}

##
# @COLOMode:
#
# The colo mode
#
# @unknown: unknown mode
#
# @primary: master side
#
# @secondary: slave side
#
# Since: 2.8
##
{
  "enum": "COLOMode",
  "data": [
    "unknown",
    "primary",
    "secondary"
  ]
}

##
# @FailoverStatus:
#
# An enumeration of COLO failover status
#
# @none: no failover has ever happened
#
# @require: got failover requirement but not handled
#
# @active: in the process of doing failover
#
# @completed: finish the process of failover
#
# @relaunch: restart the failover process, from 'none' -> 'completed' (Since 2.9)
#
# Since: 2.8
##
{
  "enum": "FailoverStatus",
  "data": [
    "none",
    "require",
    "active",
    "completed",
    "relaunch"
  ]
}

##
# @x-colo-lost-heartbeat:
#
# Tell qemu that heartbeat is lost, request it to do takeover procedures.
# If this command is sent to the PVM, the Primary side will exit COLO mode.
# If sent to the Secondary, the Secondary side will run failover work,
# then takes over server operation to become the service VM.
#
# Since: 2.8
#
# Example:
#
# -> { "execute": "x-colo-lost-heartbeat" }
# <- { "return": {} }
#
##
{
  "command": "x-colo-lost-heartbeat"
}

##
# @migrate_cancel:
#
# Cancel the current executing migration process.
#
# Returns: nothing on success
#
# Notes: This command succeeds even if there is no migration process running.
#
# Since: 0.14.0
#
# Example:
#
# -> { "execute": "migrate_cancel" }
# <- { "return": {} }
#
##
{
  "command": "migrate_cancel"
}

##
{
  "command": "migrate-continue",
  "data": {
    "state": "MigrationStatus"
  }
}

##
# @migrate_set_downtime:
#
# Set maximum tolerated downtime for migration.
#
# @value: maximum downtime in seconds
#
# Returns: nothing on success
#
# Notes: This command is deprecated in favor of 'migrate-set-parameters'
#
# Since: 0.14.0
#
# Example:
#
# -> { "execute": "migrate_set_downtime", "arguments": { "value": 0.1 } }
# <- { "return": {} }
#
##
{
  "command": "migrate_set_downtime",
  "data": {
    "value": "number"
  }
}

##
# @migrate_set_speed:
#
# Set maximum speed for migration.
#
# @value: maximum speed in bytes per second.
#
# Returns: nothing on success
#
# Notes: This command is deprecated in favor of 'migrate-set-parameters'
#
# Since: 0.14.0
#
# Example:
#
# -> { "execute": "migrate_set_speed", "arguments": { "value": 1024 } }
# <- { "return": {} }
#
##
{
  "command": "migrate_set_speed",
  "data": {
    "value": "int"
  }
}

##
# @migrate-set-cache-size:
#
# Set cache size to be used by XBZRLE migration
#
# @value: cache size in bytes
#
# The size will be rounded down to the nearest power of 2.
# The cache size can be modified before and during ongoing migration
#
# Returns: nothing on success
#
# Notes: This command is deprecated in favor of 'migrate-set-parameters'
#
# Since: 1.2
#
# Example:
#
# -> { "execute": "migrate-set-cache-size",
#      "arguments": { "value": 536870912 } }
# <- { "return": {} }
#
##
{
  "command": "migrate-set-cache-size",
  "data": {
    "value": "int"
  }
}

##
# @query-migrate-cache-size:
#
# Query migration XBZRLE cache size
#
# Returns: XBZRLE cache size in bytes
#
# Notes: This command is deprecated in favor of 'query-migrate-parameters'
#
# Since: 1.2
#
# Example:
#
# -> { "execute": "query-migrate-cache-size" }
# <- { "return": 67108864 }
#
##
{
  "command": "query-migrate-cache-size",
  "returns": "int"
}

##
# @migrate:
#
# Migrates the current running guest to another Virtual Machine.
#
# @uri: the Uniform Resource Identifier of the destination VM
#
# @blk: do block migration (full disk copy)
#
# @inc: incremental disk copy migration
#
# @detach: this argument exists only for compatibility reasons and
#          is ignored by QEMU
#
# Returns: nothing on success
#
# Since: 0.14.0
#
# Notes:
#
# 1. The 'query-migrate' command should be used to check migration's progress
#    and final result (this information is provided by the 'status' member)
#
# 2. All boolean arguments default to false
#
# 3. The user Monitor's "detach" argument is invalid in QMP and should not
#    be used
#
# Example:
#
# -> { "execute": "migrate", "arguments": { "uri": "tcp:0:4446" } }
# <- { "return": {} }
#
##
{
  "command": "migrate",
  "data": {
    "uri": "str",
    "*blk": "bool",
    "*inc": "bool",
    "*detach": "bool"
  }
}

##
# @migrate-incoming:
#
# Start an incoming migration, the qemu must have been started
# with -incoming defer
#
# @uri: The Uniform Resource Identifier identifying the source or
#       address to listen on
#
# Returns: nothing on success
#
# Since: 2.3
#
# Notes:
#
# 1. It's a bad idea to use a string for the uri, but it needs to stay
#    compatible with -incoming and the format of the uri is already exposed
#    above libvirt.
#
# 2. QEMU must be started with -incoming defer to allow migrate-incoming to
#    be used.
#
# 3. The uri format is the same as for -incoming
#
# Example:
#
# -> { "execute": "migrate-incoming",
#      "arguments": { "uri": "tcp::4446" } }
# <- { "return": {} }
#
##
{
  "command": "migrate-incoming",
  "data": {
    "uri": "str"
  }
}

##
# @xen-save-devices-state:
#
# Save the state of all devices to file. The RAM and the block devices
# of the VM are not saved by this command.
#
# @filename: the file to save the state of the devices to as binary
# data. See xen-save-devices-state.txt for a description of the binary
# format.
#
# @live: Optional argument to ask QEMU to treat this command as part of a live
# migration. Default to true. (since 2.11)
#
# Returns: Nothing on success
#
# Since: 1.1
#
# Example:
#
# -> { "execute": "xen-save-devices-state",
#      "arguments": { "filename": "/tmp/save" } }
# <- { "return": {} }
#
##
{
  "command": "xen-save-devices-state",
  "data": {
    "filename": "str",
    "*live": "bool"
  }
}

##
# @xen-set-replication:
#
# Enable or disable replication.
#
# @enable: true to enable, false to disable.
#
# @primary: true for primary or false for secondary.
#
# @failover: true to do failover, false to stop. but cannot be
#            specified if 'enable' is true. default value is false.
#
# Returns: nothing.
#
# Example:
#
# -> { "execute": "xen-set-replication",
#      "arguments": {"enable": true, "primary": false} }
# <- { "return": {} }
#
# Since: 2.9
##
{
  "command": "xen-set-replication",
  "data": {
    "enable": "bool",
    "primary": "bool",
    "*failover": "bool"
  }
}

##
# @ReplicationStatus:
#
# The result format for 'query-xen-replication-status'.
#
# @error: true if an error happened, false if replication is normal.
#
# @desc: the human readable error description string, when
#        @error is 'true'.
#
# Since: 2.9
##
{
  "struct": "ReplicationStatus",
  "data": {
    "error": "bool",
    "*desc": "str"
  }
}

##
# @query-xen-replication-status:
#
# Query replication status while the vm is running.
#
# Returns: A @ReplicationResult object showing the status.
#
# Example:
#
# -> { "execute": "query-xen-replication-status" }
# <- { "return": { "error": false } }
#
# Since: 2.9
##
{
  "command": "query-xen-replication-status",
  "returns": "ReplicationStatus"
}

##
# @xen-colo-do-checkpoint:
#
# Xen uses this command to notify replication to trigger a checkpoint.
#
# Returns: nothing.
#
# Example:
#
# -> { "execute": "xen-colo-do-checkpoint" }
# <- { "return": {} }
#
# Since: 2.9
##
{
  "command": "xen-colo-do-checkpoint"
}


##
# @QapiErrorClass:
#
# QEMU error classes
#
# @GenericError: this is used for errors that don't require a specific error
#                class. This should be the default case for most errors
#
# @CommandNotFound: the requested command has not been found
#
# @DeviceNotActive: a device has failed to be become active
#
# @DeviceNotFound: the requested device has not been found
#
# @KVMMissingCap: the requested operation can't be fulfilled because a
#                 required KVM capability is missing
#
# Since: 1.2
##
{
  "enum": "QapiErrorClass",
  "data": [
    "GenericError",
    "CommandNotFound",
    "DeviceNotActive",
    "DeviceNotFound",
    "KVMMissingCap"
  ]
}

##
# @IoOperationType:
#
# An enumeration of the I/O operation types
#
# @read: read operation
#
# @write: write operation
#
# Since: 2.1
##
{
  "enum": "IoOperationType",
  "data": [
    "read",
    "write"
  ]
}

##
# @OnOffAuto:
#
# An enumeration of three options: on, off, and auto
#
# @auto: QEMU selects the value between on and off
#
# @on: Enabled
#
# @off: Disabled
#
# Since: 2.2
##
{
  "enum": "OnOffAuto",
  "data": [
    "auto",
    "on",
    "off"
  ]
}

##
# @OnOffSplit:
#
# An enumeration of three values: on, off, and split
#
# @on: Enabled
#
# @off: Disabled
#
# @split: Mixed
#
# Since: 2.6
##
{
  "enum": "OnOffSplit",
  "data": [
    "on",
    "off",
    "split"
  ]
}

##
# @String:
#
# A fat type wrapping 'str', to be embedded in lists.
#
# Since: 1.2
##
{
  "struct": "String",
  "data": {
    "str": "str"
  }
}

##
# @StrOrNull:
#
# This is a string value or the explicit lack of a string (null
# pointer in C).  Intended for cases when 'optional absent' already
# has a different meaning.
#
# @s: the string value
# @n: no string value
#
# Since: 2.10
##
{
  "alternate": "StrOrNull",
  "data": {
    "s": "str",
    "n": "null"
  }
}


##
# @QCryptoTLSCredsEndpoint:
#
# The type of network endpoint that will be using the credentials.
# Most types of credential require different setup / structures
# depending on whether they will be used in a server versus a
# client.
#
# @client: the network endpoint is acting as the client
#
# @server: the network endpoint is acting as the server
#
# Since: 2.5
##
{
  "enum": "QCryptoTLSCredsEndpoint",
  "prefix": "QCRYPTO_TLS_CREDS_ENDPOINT",
  "data": [
    "client",
    "server"
  ]
}


##
# @QCryptoSecretFormat:
#
# The data format that the secret is provided in
#
# @raw: raw bytes. When encoded in JSON only valid UTF-8 sequences can be used
# @base64: arbitrary base64 encoded binary data
# Since: 2.6
##
{
  "enum": "QCryptoSecretFormat",
  "prefix": "QCRYPTO_SECRET_FORMAT",
  "data": [
    "raw",
    "base64"
  ]
}


##
# @QCryptoHashAlgorithm:
#
# The supported algorithms for computing content digests
#
# @md5: MD5. Should not be used in any new code, legacy compat only
# @sha1: SHA-1. Should not be used in any new code, legacy compat only
# @sha224: SHA-224. (since 2.7)
# @sha256: SHA-256. Current recommended strong hash.
# @sha384: SHA-384. (since 2.7)
# @sha512: SHA-512. (since 2.7)
# @ripemd160: RIPEMD-160. (since 2.7)
# Since: 2.6
##
{
  "enum": "QCryptoHashAlgorithm",
  "prefix": "QCRYPTO_HASH_ALG",
  "data": [
    "md5",
    "sha1",
    "sha224",
    "sha256",
    "sha384",
    "sha512",
    "ripemd160"
  ]
}


##
# @QCryptoCipherAlgorithm:
#
# The supported algorithms for content encryption ciphers
#
# @aes-128: AES with 128 bit / 16 byte keys
# @aes-192: AES with 192 bit / 24 byte keys
# @aes-256: AES with 256 bit / 32 byte keys
# @des-rfb: RFB specific variant of single DES. Do not use except in VNC.
# @3des: 3DES(EDE) with 192 bit / 24 byte keys (since 2.9)
# @cast5-128: Cast5 with 128 bit / 16 byte keys
# @serpent-128: Serpent with 128 bit / 16 byte keys
# @serpent-192: Serpent with 192 bit / 24 byte keys
# @serpent-256: Serpent with 256 bit / 32 byte keys
# @twofish-128: Twofish with 128 bit / 16 byte keys
# @twofish-192: Twofish with 192 bit / 24 byte keys
# @twofish-256: Twofish with 256 bit / 32 byte keys
# Since: 2.6
##
{
  "enum": "QCryptoCipherAlgorithm",
  "prefix": "QCRYPTO_CIPHER_ALG",
  "data": [
    "aes-128",
    "aes-192",
    "aes-256",
    "des-rfb",
    "3des",
    "cast5-128",
    "serpent-128",
    "serpent-192",
    "serpent-256",
    "twofish-128",
    "twofish-192",
    "twofish-256"
  ]
}


##
# @QCryptoCipherMode:
#
# The supported modes for content encryption ciphers
#
# @ecb: Electronic Code Book
# @cbc: Cipher Block Chaining
# @xts: XEX with tweaked code book and ciphertext stealing
# @ctr: Counter (Since 2.8)
# Since: 2.6
##
{
  "enum": "QCryptoCipherMode",
  "prefix": "QCRYPTO_CIPHER_MODE",
  "data": [
    "ecb",
    "cbc",
    "xts",
    "ctr"
  ]
}


##
# @QCryptoIVGenAlgorithm:
#
# The supported algorithms for generating initialization
# vectors for full disk encryption. The 'plain' generator
# should not be used for disks with sector numbers larger
# than 2^32, except where compatibility with pre-existing
# Linux dm-crypt volumes is required.
#
# @plain: 64-bit sector number truncated to 32-bits
# @plain64: 64-bit sector number
# @essiv: 64-bit sector number encrypted with a hash of the encryption key
# Since: 2.6
##
{
  "enum": "QCryptoIVGenAlgorithm",
  "prefix": "QCRYPTO_IVGEN_ALG",
  "data": [
    "plain",
    "plain64",
    "essiv"
  ]
}

##
# @QCryptoBlockFormat:
#
# The supported full disk encryption formats
#
# @qcow: QCow/QCow2 built-in AES-CBC encryption. Use only
#        for liberating data from old images.
# @luks: LUKS encryption format. Recommended for new images
#
# Since: 2.6
##
{
  "enum": "QCryptoBlockFormat",
  "data": [
    "qcow",
    "luks"
  ]
}

##
# @QCryptoBlockOptionsBase:
#
# The common options that apply to all full disk
# encryption formats
#
# @format: the encryption format
#
# Since: 2.6
##
{
  "struct": "QCryptoBlockOptionsBase",
  "data": {
    "format": "QCryptoBlockFormat"
  }
}

##
# @QCryptoBlockOptionsQCow:
#
# The options that apply to QCow/QCow2 AES-CBC encryption format
#
# @key-secret: the ID of a QCryptoSecret object providing the
#              decryption key. Mandatory except when probing image for
#              metadata only.
#
# Since: 2.6
##
{
  "struct": "QCryptoBlockOptionsQCow",
  "data": {
    "*key-secret": "str"
  }
}

##
# @QCryptoBlockOptionsLUKS:
#
# The options that apply to LUKS encryption format
#
# @key-secret: the ID of a QCryptoSecret object providing the
#              decryption key. Mandatory except when probing image for
#              metadata only.
# Since: 2.6
##
{
  "struct": "QCryptoBlockOptionsLUKS",
  "data": {
    "*key-secret": "str"
  }
}


##
# @QCryptoBlockCreateOptionsLUKS:
#
# The options that apply to LUKS encryption format initialization
#
# @cipher-alg: the cipher algorithm for data encryption
#              Currently defaults to 'aes'.
# @cipher-mode: the cipher mode for data encryption
#               Currently defaults to 'cbc'
# @ivgen-alg: the initialization vector generator
#             Currently defaults to 'essiv'
# @ivgen-hash-alg: the initialization vector generator hash
#                  Currently defaults to 'sha256'
# @hash-alg: the master key hash algorithm
#            Currently defaults to 'sha256'
# @iter-time: number of milliseconds to spend in
#             PBKDF passphrase processing. Currently defaults
#             to 2000. (since 2.8)
# Since: 2.6
##
{
  "struct": "QCryptoBlockCreateOptionsLUKS",
  "base": "QCryptoBlockOptionsLUKS",
  "data": {
    "*cipher-alg": "QCryptoCipherAlgorithm",
    "*cipher-mode": "QCryptoCipherMode",
    "*ivgen-alg": "QCryptoIVGenAlgorithm",
    "*ivgen-hash-alg": "QCryptoHashAlgorithm",
    "*hash-alg": "QCryptoHashAlgorithm",
    "*iter-time": "int"
  }
}


##
# @QCryptoBlockOpenOptions:
#
# The options that are available for all encryption formats
# when opening an existing volume
#
# Since: 2.6
##
{
  "union": "QCryptoBlockOpenOptions",
  "base": "QCryptoBlockOptionsBase",
  "discriminator": "format",
  "data": {
    "qcow": "QCryptoBlockOptionsQCow",
    "luks": "QCryptoBlockOptionsLUKS"
  }
}


##
# @QCryptoBlockCreateOptions:
#
# The options that are available for all encryption formats
# when initializing a new volume
#
# Since: 2.6
##
{
  "union": "QCryptoBlockCreateOptions",
  "base": "QCryptoBlockOptionsBase",
  "discriminator": "format",
  "data": {
    "qcow": "QCryptoBlockOptionsQCow",
    "luks": "QCryptoBlockCreateOptionsLUKS"
  }
}


##
# @QCryptoBlockInfoBase:
#
# The common information that applies to all full disk
# encryption formats
#
# @format: the encryption format
#
# Since: 2.7
##
{
  "struct": "QCryptoBlockInfoBase",
  "data": {
    "format": "QCryptoBlockFormat"
  }
}


##
# @QCryptoBlockInfoLUKSSlot:
#
# Information about the LUKS block encryption key
# slot options
#
# @active: whether the key slot is currently in use
# @key-offset: offset to the key material in bytes
# @iters: number of PBKDF2 iterations for key material
# @stripes: number of stripes for splitting key material
#
# Since: 2.7
##
{
  "struct": "QCryptoBlockInfoLUKSSlot",
  "data": {
    "active": "bool",
    "*iters": "int",
    "*stripes": "int",
    "key-offset": "int"
  }
}


##
# @QCryptoBlockInfoLUKS:
#
# Information about the LUKS block encryption options
#
# @cipher-alg: the cipher algorithm for data encryption
# @cipher-mode: the cipher mode for data encryption
# @ivgen-alg: the initialization vector generator
# @ivgen-hash-alg: the initialization vector generator hash
# @hash-alg: the master key hash algorithm
# @payload-offset: offset to the payload data in bytes
# @master-key-iters: number of PBKDF2 iterations for key material
# @uuid: unique identifier for the volume
# @slots: information about each key slot
#
# Since: 2.7
##
{
  "struct": "QCryptoBlockInfoLUKS",
  "data": {
    "cipher-alg": "QCryptoCipherAlgorithm",
    "cipher-mode": "QCryptoCipherMode",
    "ivgen-alg": "QCryptoIVGenAlgorithm",
    "*ivgen-hash-alg": "QCryptoHashAlgorithm",
    "hash-alg": "QCryptoHashAlgorithm",
    "payload-offset": "int",
    "master-key-iters": "int",
    "uuid": "str",
    "slots": [
      "QCryptoBlockInfoLUKSSlot"
    ]
  }
}

##
# @QCryptoBlockInfoQCow:
#
# Information about the QCow block encryption options
#
# Since: 2.7
##
{
  "struct": "QCryptoBlockInfoQCow",
  "data": {}
}


##
# @QCryptoBlockInfo:
#
# Information about the block encryption options
#
# Since: 2.7
##
{
  "union": "QCryptoBlockInfo",
  "base": "QCryptoBlockInfoBase",
  "discriminator": "format",
  "data": {
    "qcow": "QCryptoBlockInfoQCow",
    "luks": "QCryptoBlockInfoLUKS"
  }
}


##
# @QapiErrorClass:
#
# QEMU error classes
#
# @GenericError: this is used for errors that don't require a specific error
#                class. This should be the default case for most errors
#
# @CommandNotFound: the requested command has not been found
#
# @DeviceNotActive: a device has failed to be become active
#
# @DeviceNotFound: the requested device has not been found
#
# @KVMMissingCap: the requested operation can't be fulfilled because a
#                 required KVM capability is missing
#
# Since: 1.2
##
{
  "enum": "QapiErrorClass",
  "data": [
    "GenericError",
    "CommandNotFound",
    "DeviceNotActive",
    "DeviceNotFound",
    "KVMMissingCap"
  ]
}

##
# @IoOperationType:
#
# An enumeration of the I/O operation types
#
# @read: read operation
#
# @write: write operation
#
# Since: 2.1
##
{
  "enum": "IoOperationType",
  "data": [
    "read",
    "write"
  ]
}

##
# @OnOffAuto:
#
# An enumeration of three options: on, off, and auto
#
# @auto: QEMU selects the value between on and off
#
# @on: Enabled
#
# @off: Disabled
#
# Since: 2.2
##
{
  "enum": "OnOffAuto",
  "data": [
    "auto",
    "on",
    "off"
  ]
}

##
# @OnOffSplit:
#
# An enumeration of three values: on, off, and split
#
# @on: Enabled
#
# @off: Disabled
#
# @split: Mixed
#
# Since: 2.6
##
{
  "enum": "OnOffSplit",
  "data": [
    "on",
    "off",
    "split"
  ]
}

##
# @String:
#
# A fat type wrapping 'str', to be embedded in lists.
#
# Since: 1.2
##
{
  "struct": "String",
  "data": {
    "str": "str"
  }
}

##
# @StrOrNull:
#
# This is a string value or the explicit lack of a string (null
# pointer in C).  Intended for cases when 'optional absent' already
# has a different meaning.
#
# @s: the string value
# @n: no string value
#
# Since: 2.10
##
{
  "alternate": "StrOrNull",
  "data": {
    "s": "str",
    "n": "null"
  }
}


##
# @NetworkAddressFamily:
#
# The network address family
#
# @ipv4: IPV4 family
#
# @ipv6: IPV6 family
#
# @unix: unix socket
#
# @vsock: vsock family (since 2.8)
#
# @unknown: otherwise
#
# Since: 2.1
##
{
  "enum": "NetworkAddressFamily",
  "data": [
    "ipv4",
    "ipv6",
    "unix",
    "vsock",
    "unknown"
  ]
}

##
# @InetSocketAddressBase:
#
# @host: host part of the address
# @port: port part of the address
##
{
  "struct": "InetSocketAddressBase",
  "data": {
    "host": "str",
    "port": "str"
  }
}

##
# @InetSocketAddress:
#
# Captures a socket address or address range in the Internet namespace.
#
# @numeric: true if the host/port are guaranteed to be numeric,
#           false if name resolution should be attempted. Defaults to false.
#           (Since 2.9)
#
# @to: If present, this is range of possible addresses, with port
#      between @port and @to.
#
# @ipv4: whether to accept IPv4 addresses, default try both IPv4 and IPv6
#
# @ipv6: whether to accept IPv6 addresses, default try both IPv4 and IPv6
#
# Since: 1.3
##
{
  "struct": "InetSocketAddress",
  "base": "InetSocketAddressBase",
  "data": {
    "*numeric": "bool",
    "*to": "uint16",
    "*ipv4": "bool",
    "*ipv6": "bool"
  }
}

##
# @UnixSocketAddress:
#
# Captures a socket address in the local ("Unix socket") namespace.
#
# @path: filesystem path to use
#
# Since: 1.3
##
{
  "struct": "UnixSocketAddress",
  "data": {
    "path": "str"
  }
}

##
# @VsockSocketAddress:
#
# Captures a socket address in the vsock namespace.
#
# @cid: unique host identifier
# @port: port
#
# Note: string types are used to allow for possible future hostname or
# service resolution support.
#
# Since: 2.8
##
{
  "struct": "VsockSocketAddress",
  "data": {
    "cid": "str",
    "port": "str"
  }
}

#
# Since: 1.3
##
{
  "union": "SocketAddressLegacy",
  "data": {
    "inet": "InetSocketAddress",
    "unix": "UnixSocketAddress",
    "vsock": "VsockSocketAddress",
    "fd": "String"
  }
}

##
# @SocketAddressType:
#
# Available SocketAddress types
#
# @inet:  Internet address
#
# @unix:  Unix domain socket
#
# Since: 2.9
##
{
  "enum": "SocketAddressType",
  "data": [
    "inet",
    "unix",
    "vsock",
    "fd"
  ]
}

##
# @SocketAddress:
#
# Captures the address of a socket, which could also be a named file
# descriptor
#
# @type:       Transport type
#
# Since: 2.9
##
{
  "union": "SocketAddress",
  "base": {
    "type": "SocketAddressType"
  },
  "discriminator": "type",
  "data": {
    "inet": "InetSocketAddress",
    "unix": "UnixSocketAddress",
    "vsock": "VsockSocketAddress",
    "fd": "String"
  }
}


##
# @SnapshotInfo:
#
# @id: unique snapshot id
#
# @name: user chosen name
#
# @vm-state-size: size of the VM state
#
# @date-sec: UTC date of the snapshot in seconds
#
# @date-nsec: fractional part in nano seconds to be used with date-sec
#
# @vm-clock-sec: VM clock relative to boot in seconds
#
# @vm-clock-nsec: fractional part in nano seconds to be used with vm-clock-sec
#
# Since: 1.3
#
##
{
  "struct": "SnapshotInfo",
  "data": {
    "id": "str",
    "name": "str",
    "vm-state-size": "int",
    "date-sec": "int",
    "date-nsec": "int",
    "vm-clock-sec": "int",
    "vm-clock-nsec": "int"
  }
}

##
# @ImageInfoSpecificQCow2EncryptionBase:
#
# @format: The encryption format
#
# Since: 2.10
##
{
  "struct": "ImageInfoSpecificQCow2EncryptionBase",
  "data": {
    "format": "BlockdevQcow2EncryptionFormat"
  }
}

##
# @ImageInfoSpecificQCow2Encryption:
#
# Since: 2.10
##
{
  "union": "ImageInfoSpecificQCow2Encryption",
  "base": "ImageInfoSpecificQCow2EncryptionBase",
  "discriminator": "format",
  "data": {
    "aes": "QCryptoBlockInfoQCow",
    "luks": "QCryptoBlockInfoLUKS"
  }
}

##
# @ImageInfoSpecificQCow2:
#
# @compat: compatibility level
#
# @lazy-refcounts: on or off; only valid for compat >= 1.1
#
# @corrupt: true if the image has been marked corrupt; only valid for
#           compat >= 1.1 (since 2.2)
#
# @refcount-bits: width of a refcount entry in bits (since 2.3)
#
# @encrypt: details about encryption parameters; only set if image
#           is encrypted (since 2.10)
#
# Since: 1.7
##
{
  "struct": "ImageInfoSpecificQCow2",
  "data": {
    "compat": "str",
    "*lazy-refcounts": "bool",
    "*corrupt": "bool",
    "refcount-bits": "int",
    "*encrypt": "ImageInfoSpecificQCow2Encryption"
  }
}

##
# @ImageInfoSpecificVmdk:
#
# @create-type: The create type of VMDK image
#
# @cid: Content id of image
#
# @parent-cid: Parent VMDK image's cid
#
# @extents: List of extent files
#
# Since: 1.7
##
{
  "struct": "ImageInfoSpecificVmdk",
  "data": {
    "create-type": "str",
    "cid": "int",
    "parent-cid": "int",
    "extents": [
      "ImageInfo"
    ]
  }
}

##
# @ImageInfoSpecific:
#
# A discriminated record of image format specific information structures.
#
# Since: 1.7
##
{
  "union": "ImageInfoSpecific",
  "data": {
    "qcow2": "ImageInfoSpecificQCow2",
    "vmdk": "ImageInfoSpecificVmdk",
    "luks": "QCryptoBlockInfoLUKS"
  }
}

##
# @ImageInfo:
#
# Information about a QEMU image file
#
# @filename: name of the image file
#
# @format: format of the image file
#
# @virtual-size: maximum capacity in bytes of the image
#
# @actual-size: actual size on disk in bytes of the image
#
# @dirty-flag: true if image is not cleanly closed
#
# @cluster-size: size of a cluster in bytes
#
# @encrypted: true if the image is encrypted
#
# @compressed: true if the image is compressed (Since 1.7)
#
# @backing-filename: name of the backing file
#
# @full-backing-filename: full path of the backing file
#
# @backing-filename-format: the format of the backing file
#
# @snapshots: list of VM snapshots
#
# @backing-image: info of the backing image (since 1.6)
#
# @format-specific: structure supplying additional format-specific
# information (since 1.7)
#
# Since: 1.3
#
##
{
  "struct": "ImageInfo",
  "data": {
    "filename": "str",
    "format": "str",
    "*dirty-flag": "bool",
    "*actual-size": "int",
    "virtual-size": "int",
    "*cluster-size": "int",
    "*encrypted": "bool",
    "*compressed": "bool",
    "*backing-filename": "str",
    "*full-backing-filename": "str",
    "*backing-filename-format": "str",
    "*snapshots": [
      "SnapshotInfo"
    ],
    "*backing-image": "ImageInfo",
    "*format-specific": "ImageInfoSpecific"
  }
}

##
# @ImageCheck:
#
# Information about a QEMU image file check
#
# @filename: name of the image file checked
#
# @format: format of the image file checked
#
# @check-errors: number of unexpected errors occurred during check
#
# @image-end-offset: offset (in bytes) where the image ends, this
#                    field is present if the driver for the image format
#                    supports it
#
# @corruptions: number of corruptions found during the check if any
#
# @leaks: number of leaks found during the check if any
#
# @corruptions-fixed: number of corruptions fixed during the check
#                     if any
#
# @leaks-fixed: number of leaks fixed during the check if any
#
# @total-clusters: total number of clusters, this field is present
#                  if the driver for the image format supports it
#
# @allocated-clusters: total number of allocated clusters, this
#                      field is present if the driver for the image format
#                      supports it
#
# @fragmented-clusters: total number of fragmented clusters, this
#                       field is present if the driver for the image format
#                       supports it
#
# @compressed-clusters: total number of compressed clusters, this
#                       field is present if the driver for the image format
#                       supports it
#
# Since: 1.4
#
##
{
  "struct": "ImageCheck",
  "data": {
    "filename": "str",
    "format": "str",
    "check-errors": "int",
    "*image-end-offset": "int",
    "*corruptions": "int",
    "*leaks": "int",
    "*corruptions-fixed": "int",
    "*leaks-fixed": "int",
    "*total-clusters": "int",
    "*allocated-clusters": "int",
    "*fragmented-clusters": "int",
    "*compressed-clusters": "int"
  }
}

##
# @MapEntry:
#
# Mapping information from a virtual block range to a host file range
#
# @start: the start byte of the mapped virtual range
#
# @length: the number of bytes of the mapped virtual range
#
# @data: whether the mapped range has data
#
# @zero: whether the virtual blocks are zeroed
#
# @depth: the depth of the mapping
#
# @offset: the offset in file that the virtual sectors are mapped to
#
# @filename: filename that is referred to by @offset
#
# Since: 2.6
#
##
{
  "struct": "MapEntry",
  "data": {
    "start": "int",
    "length": "int",
    "data": "bool",
    "zero": "bool",
    "depth": "int",
    "*offset": "int",
    "*filename": "str"
  }
}

##
# @BlockdevCacheInfo:
#
# Cache mode information for a block device
#
# @writeback:   true if writeback mode is enabled
# @direct:      true if the host page cache is bypassed (O_DIRECT)
# @no-flush:    true if flush requests are ignored for the device
#
# Since: 2.3
##
{
  "struct": "BlockdevCacheInfo",
  "data": {
    "writeback": "bool",
    "direct": "bool",
    "no-flush": "bool"
  }
}

##
# @BlockDeviceInfo:
#
# Information about the backing device for a block device.
#
# @file: the filename of the backing device
#
# @node-name: the name of the block driver node (Since 2.0)
#
# @ro: true if the backing device was open read-only
#
# @drv: the name of the block format used to open the backing device. As of
#       0.14.0 this can be: 'blkdebug', 'bochs', 'cloop', 'cow', 'dmg',
#       'file', 'file', 'ftp', 'ftps', 'host_cdrom', 'host_device',
#       'http', 'https', 'luks', 'nbd', 'parallels', 'qcow',
#       'qcow2', 'raw', 'vdi', 'vmdk', 'vpc', 'vvfat'
#       2.2: 'archipelago' added, 'cow' dropped
#       2.3: 'host_floppy' deprecated
#       2.5: 'host_floppy' dropped
#       2.6: 'luks' added
#       2.8: 'replication' added, 'tftp' dropped
#       2.9: 'archipelago' dropped
#
# @backing_file: the name of the backing file (for copy-on-write)
#
# @backing_file_depth: number of files in the backing file chain (since: 1.2)
#
# @encrypted: true if the backing device is encrypted
#
# @encryption_key_missing: Deprecated; always false
#
# @detect_zeroes: detect and optimize zero writes (Since 2.1)
#
# @bps: total throughput limit in bytes per second is specified
#
# @bps_rd: read throughput limit in bytes per second is specified
#
# @bps_wr: write throughput limit in bytes per second is specified
#
# @iops: total I/O operations per second is specified
#
# @iops_rd: read I/O operations per second is specified
#
# @iops_wr: write I/O operations per second is specified
#
# @image: the info of image used (since: 1.6)
#
# @bps_max: total throughput limit during bursts,
#                     in bytes (Since 1.7)
#
# @bps_rd_max: read throughput limit during bursts,
#                        in bytes (Since 1.7)
#
# @bps_wr_max: write throughput limit during bursts,
#                        in bytes (Since 1.7)
#
# @iops_max: total I/O operations per second during bursts,
#                      in bytes (Since 1.7)
#
# @iops_rd_max: read I/O operations per second during bursts,
#                         in bytes (Since 1.7)
#
# @iops_wr_max: write I/O operations per second during bursts,
#                         in bytes (Since 1.7)
#
# @bps_max_length: maximum length of the @bps_max burst
#                            period, in seconds. (Since 2.6)
#
# @bps_rd_max_length: maximum length of the @bps_rd_max
#                               burst period, in seconds. (Since 2.6)
#
# @bps_wr_max_length: maximum length of the @bps_wr_max
#                               burst period, in seconds. (Since 2.6)
#
# @iops_max_length: maximum length of the @iops burst
#                             period, in seconds. (Since 2.6)
#
# @iops_rd_max_length: maximum length of the @iops_rd_max
#                                burst period, in seconds. (Since 2.6)
#
# @iops_wr_max_length: maximum length of the @iops_wr_max
#                                burst period, in seconds. (Since 2.6)
#
# @iops_size: an I/O size in bytes (Since 1.7)
#
# @group: throttle group name (Since 2.4)
#
# @cache: the cache mode used for the block device (since: 2.3)
#
# @write_threshold: configured write threshold for the device.
#                   0 if disabled. (Since 2.3)
#
# Since: 0.14.0
#
##
{
  "struct": "BlockDeviceInfo",
  "data": {
    "file": "str",
    "*node-name": "str",
    "ro": "bool",
    "drv": "str",
    "*backing_file": "str",
    "backing_file_depth": "int",
    "encrypted": "bool",
    "encryption_key_missing": "bool",
    "detect_zeroes": "BlockdevDetectZeroesOptions",
    "bps": "int",
    "bps_rd": "int",
    "bps_wr": "int",
    "iops": "int",
    "iops_rd": "int",
    "iops_wr": "int",
    "image": "ImageInfo",
    "*bps_max": "int",
    "*bps_rd_max": "int",
    "*bps_wr_max": "int",
    "*iops_max": "int",
    "*iops_rd_max": "int",
    "*iops_wr_max": "int",
    "*bps_max_length": "int",
    "*bps_rd_max_length": "int",
    "*bps_wr_max_length": "int",
    "*iops_max_length": "int",
    "*iops_rd_max_length": "int",
    "*iops_wr_max_length": "int",
    "*iops_size": "int",
    "*group": "str",
    "cache": "BlockdevCacheInfo",
    "write_threshold": "int"
  }
}

##
# @BlockDeviceIoStatus:
#
# An enumeration of block device I/O status.
#
# @ok: The last I/O operation has succeeded
#
# @failed: The last I/O operation has failed
#
# @nospace: The last I/O operation has failed due to a no-space condition
#
# Since: 1.0
##
{
  "enum": "BlockDeviceIoStatus",
  "data": [
    "ok",
    "failed",
    "nospace"
  ]
}

##
# @BlockDeviceMapEntry:
#
# Entry in the metadata map of the device (returned by "qemu-img map")
#
# @start: Offset in the image of the first byte described by this entry
#         (in bytes)
#
# @length: Length of the range described by this entry (in bytes)
#
# @depth: Number of layers (0 = top image, 1 = top image's backing file, etc.)
#         before reaching one for which the range is allocated.  The value is
#         in the range 0 to the depth of the image chain - 1.
#
# @zero: the sectors in this range read as zeros
#
# @data: reading the image will actually read data from a file (in particular,
#        if @offset is present this means that the sectors are not simply
#        preallocated, but contain actual data in raw format)
#
# @offset: if present, the image file stores the data for this range in
#          raw format at the given offset.
#
# Since: 1.7
##
{
  "struct": "BlockDeviceMapEntry",
  "data": {
    "start": "int",
    "length": "int",
    "depth": "int",
    "zero": "bool",
    "data": "bool",
    "*offset": "int"
  }
}

##
# @DirtyBitmapStatus:
#
# An enumeration of possible states that a dirty bitmap can report to the user.
#
# @frozen: The bitmap is currently in-use by a backup operation or block job,
#          and is immutable.
#
# @disabled: The bitmap is currently in-use by an internal operation and is
#            read-only. It can still be deleted.
#
# @active: The bitmap is actively monitoring for new writes, and can be cleared,
#          deleted, or used for backup operations.
#
# Since: 2.4
##
{
  "enum": "DirtyBitmapStatus",
  "data": [
    "active",
    "disabled",
    "frozen"
  ]
}

##
# @BlockDirtyInfo:
#
# Block dirty bitmap information.
#
# @name: the name of the dirty bitmap (Since 2.4)
#
# @count: number of dirty bytes according to the dirty bitmap
#
# @granularity: granularity of the dirty bitmap in bytes (since 1.4)
#
# @status: current status of the dirty bitmap (since 2.4)
#
# Since: 1.3
##
{
  "struct": "BlockDirtyInfo",
  "data": {
    "*name": "str",
    "count": "int",
    "granularity": "uint32",
    "status": "DirtyBitmapStatus"
  }
}

##
# @BlockInfo:
#
# Block device information.  This structure describes a virtual device and
# the backing device associated with it.
#
# @device: The device name associated with the virtual device.
#
# @qdev: The qdev ID, or if no ID is assigned, the QOM path of the block
#        device. (since 2.10)
#
# @type: This field is returned only for compatibility reasons, it should
#        not be used (always returns 'unknown')
#
# @removable: True if the device supports removable media.
#
# @locked: True if the guest has locked this device from having its media
#          removed
#
# @tray_open: True if the device's tray is open
#             (only present if it has a tray)
#
# @dirty-bitmaps: dirty bitmaps information (only present if the
#                 driver has one or more dirty bitmaps) (Since 2.0)
#
# @io-status: @BlockDeviceIoStatus. Only present if the device
#             supports it and the VM is configured to stop on errors
#             (supported device models: virtio-blk, IDE, SCSI except
#             scsi-generic)
#
# @inserted: @BlockDeviceInfo describing the device if media is
#            present
#
# Since:  0.14.0
##
{
  "struct": "BlockInfo",
  "data": {
    "device": "str",
    "*qdev": "str",
    "type": "str",
    "removable": "bool",
    "locked": "bool",
    "*inserted": "BlockDeviceInfo",
    "*tray_open": "bool",
    "*io-status": "BlockDeviceIoStatus",
    "*dirty-bitmaps": [
      "BlockDirtyInfo"
    ]
  }
}

##
# @BlockMeasureInfo:
#
# Image file size calculation information.  This structure describes the size
# requirements for creating a new image file.
#
# The size requirements depend on the new image file format.  File size always
# equals virtual disk size for the 'raw' format, even for sparse POSIX files.
# Compact formats such as 'qcow2' represent unallocated and zero regions
# efficiently so file size may be smaller than virtual disk size.
#
# The values are upper bounds that are guaranteed to fit the new image file.
# Subsequent modification, such as internal snapshot or bitmap creation, may
# require additional space and is not covered here.
#
# @required: Size required for a new image file, in bytes.
#
# @fully-allocated: Image file size, in bytes, once data has been written
#                   to all sectors.
#
# Since: 2.10
##
{
  "struct": "BlockMeasureInfo",
  "data": {
    "required": "int",
    "fully-allocated": "int"
  }
}

##
# @query-block:
#
# Get a list of BlockInfo for all virtual block devices.
#
# Returns: a list of @BlockInfo describing each virtual block device. Filter
# nodes that were created implicitly are skipped over.
#
# Since: 0.14.0
#
# Example:
#
# -> { "execute": "query-block" }
# <- {
#       "return":[
#          {
#             "io-status": "ok",
#             "device":"ide0-hd0",
#             "locked":false,
#             "removable":false,
#             "inserted":{
#                "ro":false,
#                "drv":"qcow2",
#                "encrypted":false,
#                "file":"disks/test.qcow2",
#                "backing_file_depth":1,
#                "bps":1000000,
#                "bps_rd":0,
#                "bps_wr":0,
#                "iops":1000000,
#                "iops_rd":0,
#                "iops_wr":0,
#                "bps_max": 8000000,
#                "bps_rd_max": 0,
#                "bps_wr_max": 0,
#                "iops_max": 0,
#                "iops_rd_max": 0,
#                "iops_wr_max": 0,
#                "iops_size": 0,
#                "detect_zeroes": "on",
#                "write_threshold": 0,
#                "image":{
#                   "filename":"disks/test.qcow2",
#                   "format":"qcow2",
#                   "virtual-size":2048000,
#                   "backing_file":"base.qcow2",
#                   "full-backing-filename":"disks/base.qcow2",
#                   "backing-filename-format":"qcow2",
#                   "snapshots":[
#                      {
#                         "id": "1",
#                         "name": "snapshot1",
#                         "vm-state-size": 0,
#                         "date-sec": 10000200,
#                         "date-nsec": 12,
#                         "vm-clock-sec": 206,
#                         "vm-clock-nsec": 30
#                      }
#                   ],
#                   "backing-image":{
#                       "filename":"disks/base.qcow2",
#                       "format":"qcow2",
#                       "virtual-size":2048000
#                   }
#                }
#             },
#             "qdev": "ide_disk",
#             "type":"unknown"
#          },
#          {
#             "io-status": "ok",
#             "device":"ide1-cd0",
#             "locked":false,
#             "removable":true,
#             "qdev": "/machine/unattached/device[23]",
#             "tray_open": false,
#             "type":"unknown"
#          },
#          {
#             "device":"floppy0",
#             "locked":false,
#             "removable":true,
#             "qdev": "/machine/unattached/device[20]",
#             "type":"unknown"
#          },
#          {
#             "device":"sd0",
#             "locked":false,
#             "removable":true,
#             "type":"unknown"
#          }
#       ]
#    }
#
##
{
  "command": "query-block",
  "returns": [
    "BlockInfo"
  ]
}


##
# @BlockDeviceTimedStats:
#
# Statistics of a block device during a given interval of time.
#
# @interval_length: Interval used for calculating the statistics,
#                   in seconds.
#
# @min_rd_latency_ns: Minimum latency of read operations in the
#                     defined interval, in nanoseconds.
#
# @min_wr_latency_ns: Minimum latency of write operations in the
#                     defined interval, in nanoseconds.
#
# @min_flush_latency_ns: Minimum latency of flush operations in the
#                        defined interval, in nanoseconds.
#
# @max_rd_latency_ns: Maximum latency of read operations in the
#                     defined interval, in nanoseconds.
#
# @max_wr_latency_ns: Maximum latency of write operations in the
#                     defined interval, in nanoseconds.
#
# @max_flush_latency_ns: Maximum latency of flush operations in the
#                        defined interval, in nanoseconds.
#
# @avg_rd_latency_ns: Average latency of read operations in the
#                     defined interval, in nanoseconds.
#
# @avg_wr_latency_ns: Average latency of write operations in the
#                     defined interval, in nanoseconds.
#
# @avg_flush_latency_ns: Average latency of flush operations in the
#                        defined interval, in nanoseconds.
#
# @avg_rd_queue_depth: Average number of pending read operations
#                      in the defined interval.
#
# @avg_wr_queue_depth: Average number of pending write operations
#                      in the defined interval.
#
# Since: 2.5
##
{
  "struct": "BlockDeviceTimedStats",
  "data": {
    "interval_length": "int",
    "min_rd_latency_ns": "int",
    "max_rd_latency_ns": "int",
    "avg_rd_latency_ns": "int",
    "min_wr_latency_ns": "int",
    "max_wr_latency_ns": "int",
    "avg_wr_latency_ns": "int",
    "min_flush_latency_ns": "int",
    "max_flush_latency_ns": "int",
    "avg_flush_latency_ns": "int",
    "avg_rd_queue_depth": "number",
    "avg_wr_queue_depth": "number"
  }
}

##
# @BlockDeviceStats:
#
# Statistics of a virtual block device or a block backing device.
#
# @rd_bytes:      The number of bytes read by the device.
#
# @wr_bytes:      The number of bytes written by the device.
#
# @rd_operations: The number of read operations performed by the device.
#
# @wr_operations: The number of write operations performed by the device.
#
# @flush_operations: The number of cache flush operations performed by the
#                    device (since 0.15.0)
#
# @flush_total_time_ns: Total time spend on cache flushes in nano-seconds
#                       (since 0.15.0).
#
# @wr_total_time_ns: Total time spend on writes in nano-seconds (since 0.15.0).
#
# @rd_total_time_ns: Total_time_spend on reads in nano-seconds (since 0.15.0).
#
# @wr_highest_offset: The offset after the greatest byte written to the
#                     device.  The intended use of this information is for
#                     growable sparse files (like qcow2) that are used on top
#                     of a physical device.
#
# @rd_merged: Number of read requests that have been merged into another
#             request (Since 2.3).
#
# @wr_merged: Number of write requests that have been merged into another
#             request (Since 2.3).
#
# @idle_time_ns: Time since the last I/O operation, in
#                nanoseconds. If the field is absent it means that
#                there haven't been any operations yet (Since 2.5).
#
# @failed_rd_operations: The number of failed read operations
#                        performed by the device (Since 2.5)
#
# @failed_wr_operations: The number of failed write operations
#                        performed by the device (Since 2.5)
#
# @failed_flush_operations: The number of failed flush operations
#                           performed by the device (Since 2.5)
#
# @invalid_rd_operations: The number of invalid read operations
#                          performed by the device (Since 2.5)
#
# @invalid_wr_operations: The number of invalid write operations
#                         performed by the device (Since 2.5)
#
# @invalid_flush_operations: The number of invalid flush operations
#                            performed by the device (Since 2.5)
#
# @account_invalid: Whether invalid operations are included in the
#                   last access statistics (Since 2.5)
#
# @account_failed: Whether failed operations are included in the
#                  latency and last access statistics (Since 2.5)
#
# @timed_stats: Statistics specific to the set of previously defined
#               intervals of time (Since 2.5)
#
# Since: 0.14.0
##
{
  "struct": "BlockDeviceStats",
  "data": {
    "rd_bytes": "int",
    "wr_bytes": "int",
    "rd_operations": "int",
    "wr_operations": "int",
    "flush_operations": "int",
    "flush_total_time_ns": "int",
    "wr_total_time_ns": "int",
    "rd_total_time_ns": "int",
    "wr_highest_offset": "int",
    "rd_merged": "int",
    "wr_merged": "int",
    "*idle_time_ns": "int",
    "failed_rd_operations": "int",
    "failed_wr_operations": "int",
    "failed_flush_operations": "int",
    "invalid_rd_operations": "int",
    "invalid_wr_operations": "int",
    "invalid_flush_operations": "int",
    "account_invalid": "bool",
    "account_failed": "bool",
    "timed_stats": [
      "BlockDeviceTimedStats"
    ]
  }
}

##
# @BlockStats:
#
# Statistics of a virtual block device or a block backing device.
#
# @device: If the stats are for a virtual block device, the name
#          corresponding to the virtual block device.
#
# @node-name: The node name of the device. (Since 2.3)
#
# @stats:  A @BlockDeviceStats for the device.
#
# @parent: This describes the file block device if it has one.
#          Contains recursively the statistics of the underlying
#          protocol (e.g. the host file for a qcow2 image). If there is
#          no underlying protocol, this field is omitted
#
# @backing: This describes the backing block device if it has one.
#           (Since 2.0)
#
# Since: 0.14.0
##
{
  "struct": "BlockStats",
  "data": {
    "*device": "str",
    "*node-name": "str",
    "stats": "BlockDeviceStats",
    "*parent": "BlockStats",
    "*backing": "BlockStats"
  }
}

##
# @query-blockstats:
#
# Query the @BlockStats for all virtual block devices.
#
# @query-nodes: If true, the command will query all the block nodes
#               that have a node name, in a list which will include "parent"
#               information, but not "backing".
#               If false or omitted, the behavior is as before - query all the
#               device backends, recursively including their "parent" and
#               "backing". Filter nodes that were created implicitly are
#               skipped over in this mode. (Since 2.3)
#
# Returns: A list of @BlockStats for each virtual block devices.
#
# Since: 0.14.0
#
# Example:
#
# -> { "execute": "query-blockstats" }
# <- {
#       "return":[
#          {
#             "device":"ide0-hd0",
#             "parent":{
#                "stats":{
#                   "wr_highest_offset":3686448128,
#                   "wr_bytes":9786368,
#                   "wr_operations":751,
#                   "rd_bytes":122567168,
#                   "rd_operations":36772
#                   "wr_total_times_ns":313253456
#                   "rd_total_times_ns":3465673657
#                   "flush_total_times_ns":49653
#                   "flush_operations":61,
#                   "rd_merged":0,
#                   "wr_merged":0,
#                   "idle_time_ns":2953431879,
#                   "account_invalid":true,
#                   "account_failed":false
#                }
#             },
#             "stats":{
#                "wr_highest_offset":2821110784,
#                "wr_bytes":9786368,
#                "wr_operations":692,
#                "rd_bytes":122739200,
#                "rd_operations":36604
#                "flush_operations":51,
#                "wr_total_times_ns":313253456
#                "rd_total_times_ns":3465673657
#                "flush_total_times_ns":49653,
#                "rd_merged":0,
#                "wr_merged":0,
#                "idle_time_ns":2953431879,
#                "account_invalid":true,
#                "account_failed":false
#             }
#          },
#          {
#             "device":"ide1-cd0",
#             "stats":{
#                "wr_highest_offset":0,
#                "wr_bytes":0,
#                "wr_operations":0,
#                "rd_bytes":0,
#                "rd_operations":0
#                "flush_operations":0,
#                "wr_total_times_ns":0
#                "rd_total_times_ns":0
#                "flush_total_times_ns":0,
#                "rd_merged":0,
#                "wr_merged":0,
#                "account_invalid":false,
#                "account_failed":false
#             }
#          },
#          {
#             "device":"floppy0",
#             "stats":{
#                "wr_highest_offset":0,
#                "wr_bytes":0,
#                "wr_operations":0,
#                "rd_bytes":0,
#                "rd_operations":0
#                "flush_operations":0,
#                "wr_total_times_ns":0
#                "rd_total_times_ns":0
#                "flush_total_times_ns":0,
#                "rd_merged":0,
#                "wr_merged":0,
#                "account_invalid":false,
#                "account_failed":false
#             }
#          },
#          {
#             "device":"sd0",
#             "stats":{
#                "wr_highest_offset":0,
#                "wr_bytes":0,
#                "wr_operations":0,
#                "rd_bytes":0,
#                "rd_operations":0
#                "flush_operations":0,
#                "wr_total_times_ns":0
#                "rd_total_times_ns":0
#                "flush_total_times_ns":0,
#                "rd_merged":0,
#                "wr_merged":0,
#                "account_invalid":false,
#                "account_failed":false
#             }
#          }
#       ]
#    }
#
##
{
  "command": "query-blockstats",
  "data": {
    "*query-nodes": "bool"
  },
  "returns": [
    "BlockStats"
  ]
}

##
# @BlockdevOnError:
#
# An enumeration of possible behaviors for errors on I/O operations.
# The exact meaning depends on whether the I/O was initiated by a guest
# or by a block job
#
# @report: for guest operations, report the error to the guest;
#          for jobs, cancel the job
#
# @ignore: ignore the error, only report a QMP event (BLOCK_IO_ERROR
#          or BLOCK_JOB_ERROR)
#
# @enospc: same as @stop on ENOSPC, same as @report otherwise.
#
# @stop: for guest operations, stop the virtual machine;
#        for jobs, pause the job
#
# @auto: inherit the error handling policy of the backend (since: 2.7)
#
# Since: 1.3
##
{
  "enum": "BlockdevOnError",
  "data": [
    "report",
    "ignore",
    "enospc",
    "stop",
    "auto"
  ]
}

##
# @MirrorSyncMode:
#
# An enumeration of possible behaviors for the initial synchronization
# phase of storage mirroring.
#
# @top: copies data in the topmost image to the destination
#
# @full: copies data from all images to the destination
#
# @none: only copy data written from now on
#
# @incremental: only copy data described by the dirty bitmap. Since: 2.4
#
# Since: 1.3
##
{
  "enum": "MirrorSyncMode",
  "data": [
    "top",
    "full",
    "none",
    "incremental"
  ]
}

##
# @BlockJobType:
#
# Type of a block job.
#
# @commit: block commit job type, see "block-commit"
#
# @stream: block stream job type, see "block-stream"
#
# @mirror: drive mirror job type, see "drive-mirror"
#
# @backup: drive backup job type, see "drive-backup"
#
# Since: 1.7
##
{
  "enum": "BlockJobType",
  "data": [
    "commit",
    "stream",
    "mirror",
    "backup"
  ]
}

##
# @BlockJobInfo:
#
# Information about a long-running block device operation.
#
# @type: the job type ('stream' for image streaming)
#
# @device: The job identifier. Originally the device name but other
#          values are allowed since QEMU 2.7
#
# @len: the maximum progress value
#
# @busy: false if the job is known to be in a quiescent state, with
#        no pending I/O.  Since 1.3.
#
# @paused: whether the job is paused or, if @busy is true, will
#          pause itself as soon as possible.  Since 1.3.
#
# @offset: the current progress value
#
# @speed: the rate limit, bytes per second
#
# @io-status: the status of the job (since 1.3)
#
# @ready: true if the job may be completed (since 2.2)
#
# Since: 1.1
##
{
  "struct": "BlockJobInfo",
  "data": {
    "type": "str",
    "device": "str",
    "len": "int",
    "offset": "int",
    "busy": "bool",
    "paused": "bool",
    "speed": "int",
    "io-status": "BlockDeviceIoStatus",
    "ready": "bool"
  }
}

##
# @query-block-jobs:
#
# Return information about long-running block device operations.
#
# Returns: a list of @BlockJobInfo for each active block job
#
# Since: 1.1
##
{
  "command": "query-block-jobs",
  "returns": [
    "BlockJobInfo"
  ]
}

##
# @block_passwd:
#
# This command sets the password of a block device that has not been open
# with a password and requires one.
#
# This command is now obsolete and will always return an error since 2.10
#
##
{
  "command": "block_passwd",
  "data": {
    "*device": "str",
    "*node-name": "str",
    "password": "str"
  }
}

##
# @block_resize:
#
# Resize a block image while a guest is running.
#
# Either @device or @node-name must be set but not both.
#
# @device: the name of the device to get the image resized
#
# @node-name: graph node name to get the image resized (Since 2.0)
#
# @size:  new image size in bytes
#
# Returns: nothing on success
#          If @device is not a valid block device, DeviceNotFound
#
# Since: 0.14.0
#
# Example:
#
# -> { "execute": "block_resize",
#      "arguments": { "device": "scratch", "size": 1073741824 } }
# <- { "return": {} }
#
##
{
  "command": "block_resize",
  "data": {
    "*device": "str",
    "*node-name": "str",
    "size": "int"
  }
}

##
# @NewImageMode:
#
# An enumeration that tells QEMU how to set the backing file path in
# a new image file.
#
# @existing: QEMU should look for an existing image file.
#
# @absolute-paths: QEMU should create a new image with absolute paths
# for the backing file. If there is no backing file available, the new
# image will not be backed either.
#
# Since: 1.1
##
{
  "enum": "NewImageMode",
  "data": [
    "existing",
    "absolute-paths"
  ]
}

##
# @BlockdevSnapshotSync:
#
# Either @device or @node-name must be set but not both.
#
# @device: the name of the device to generate the snapshot from.
#
# @node-name: graph node name to generate the snapshot from (Since 2.0)
#
# @snapshot-file: the target of the new image. If the file exists, or
# if it is a device, the snapshot will be created in the existing
# file/device. Otherwise, a new file will be created.
#
# @snapshot-node-name: the graph node name of the new image (Since 2.0)
#
# @format: the format of the snapshot image, default is 'qcow2'.
#
# @mode: whether and how QEMU should create a new image, default is
#        'absolute-paths'.
##
{
  "struct": "BlockdevSnapshotSync",
  "data": {
    "*device": "str",
    "*node-name": "str",
    "snapshot-file": "str",
    "*snapshot-node-name": "str",
    "*format": "str",
    "*mode": "NewImageMode"
  }
}

##
# @BlockdevSnapshot:
#
# @node: device or node name that will have a snapshot created.
#
# @overlay: reference to the existing block device that will become
#           the overlay of @node, as part of creating the snapshot.
#           It must not have a current backing file (this can be
#           achieved by passing "backing": "" to blockdev-add).
#
# Since: 2.5
##
{
  "struct": "BlockdevSnapshot",
  "data": {
    "node": "str",
    "overlay": "str"
  }
}

##
# @DriveBackup:
#
# @job-id: identifier for the newly-created block job. If
#          omitted, the device name will be used. (Since 2.7)
#
# @device: the device name or node-name of a root node which should be copied.
#
# @target: the target of the new image. If the file exists, or if it
#          is a device, the existing file/device will be used as the new
#          destination.  If it does not exist, a new file will be created.
#
# @format: the format of the new destination, default is to
#          probe if @mode is 'existing', else the format of the source
#
# @sync: what parts of the disk image should be copied to the destination
#        (all the disk, only the sectors allocated in the topmost image, from a
#        dirty bitmap, or only new I/O).
#
# @mode: whether and how QEMU should create a new image, default is
#        'absolute-paths'.
#
# @speed: the maximum speed, in bytes per second
#
# @bitmap: the name of dirty bitmap if sync is "incremental".
#          Must be present if sync is "incremental", must NOT be present
#          otherwise. (Since 2.4)
#
# @compress: true to compress data, if the target format supports it.
#            (default: false) (since 2.8)
#
# @on-source-error: the action to take on an error on the source,
#                   default 'report'.  'stop' and 'enospc' can only be used
#                   if the block device supports io-status (see BlockInfo).
#
# @on-target-error: the action to take on an error on the target,
#                   default 'report' (no limitations, since this applies to
#                   a different block device than @device).
#
# Note: @on-source-error and @on-target-error only affect background
# I/O.  If an error occurs during a guest write request, the device's
# rerror/werror actions will be used.
#
# Since: 1.6
##
{
  "struct": "DriveBackup",
  "data": {
    "*job-id": "str",
    "device": "str",
    "target": "str",
    "*format": "str",
    "sync": "MirrorSyncMode",
    "*mode": "NewImageMode",
    "*speed": "int",
    "*bitmap": "str",
    "*compress": "bool",
    "*on-source-error": "BlockdevOnError",
    "*on-target-error": "BlockdevOnError"
  }
}

##
# @BlockdevBackup:
#
# @job-id: identifier for the newly-created block job. If
#          omitted, the device name will be used. (Since 2.7)
#
# @device: the device name or node-name of a root node which should be copied.
#
# @target: the device name or node-name of the backup target node.
#
# @sync: what parts of the disk image should be copied to the destination
#        (all the disk, only the sectors allocated in the topmost image, or
#        only new I/O).
#
# @speed: the maximum speed, in bytes per second. The default is 0,
#         for unlimited.
#
# @compress: true to compress data, if the target format supports it.
#            (default: false) (since 2.8)
#
# @on-source-error: the action to take on an error on the source,
#                   default 'report'.  'stop' and 'enospc' can only be used
#                   if the block device supports io-status (see BlockInfo).
#
# @on-target-error: the action to take on an error on the target,
#                   default 'report' (no limitations, since this applies to
#                   a different block device than @device).
#
# Note: @on-source-error and @on-target-error only affect background
# I/O.  If an error occurs during a guest write request, the device's
# rerror/werror actions will be used.
#
# Since: 2.3
##
{
  "struct": "BlockdevBackup",
  "data": {
    "*job-id": "str",
    "device": "str",
    "target": "str",
    "sync": "MirrorSyncMode",
    "*speed": "int",
    "*compress": "bool",
    "*on-source-error": "BlockdevOnError",
    "*on-target-error": "BlockdevOnError"
  }
}

##
# @blockdev-snapshot-sync:
#
# Generates a synchronous snapshot of a block device.
#
# For the arguments, see the documentation of BlockdevSnapshotSync.
#
# Returns: nothing on success
#          If @device is not a valid block device, DeviceNotFound
#
# Since: 0.14.0
#
# Example:
#
# -> { "execute": "blockdev-snapshot-sync",
#      "arguments": { "device": "ide-hd0",
#                     "snapshot-file":
#                     "/some/place/my-image",
#                     "format": "qcow2" } }
# <- { "return": {} }
#
##
{
  "command": "blockdev-snapshot-sync",
  "data": "BlockdevSnapshotSync"
}


##
# @blockdev-snapshot:
#
# Generates a snapshot of a block device.
#
# Create a snapshot, by installing 'node' as the backing image of
# 'overlay'. Additionally, if 'node' is associated with a block
# device, the block device changes to using 'overlay' as its new active
# image.
#
# For the arguments, see the documentation of BlockdevSnapshot.
#
# Since: 2.5
#
# Example:
#
# -> { "execute": "blockdev-add",
#      "arguments": { "driver": "qcow2",
#                     "node-name": "node1534",
#                     "file": { "driver": "file",
#                               "filename": "hd1.qcow2" },
#                     "backing": "" } }
#
# <- { "return": {} }
#
# -> { "execute": "blockdev-snapshot",
#      "arguments": { "node": "ide-hd0",
#                     "overlay": "node1534" } }
# <- { "return": {} }
#
##
{
  "command": "blockdev-snapshot",
  "data": "BlockdevSnapshot"
}

##
# @change-backing-file:
#
# Change the backing file in the image file metadata.  This does not
# cause QEMU to reopen the image file to reparse the backing filename
# (it may, however, perform a reopen to change permissions from
# r/o -> r/w -> r/o, if needed). The new backing file string is written
# into the image file metadata, and the QEMU internal strings are
# updated.
#
# @image-node-name: The name of the block driver state node of the
#                   image to modify. The "device" argument is used
#                   to verify "image-node-name" is in the chain
#                   described by "device".
#
# @device:          The device name or node-name of the root node that owns
#                   image-node-name.
#
# @backing-file:    The string to write as the backing file.  This
#                   string is not validated, so care should be taken
#                   when specifying the string or the image chain may
#                   not be able to be reopened again.
#
# Returns: Nothing on success
#
#          If "device" does not exist or cannot be determined, DeviceNotFound
#
# Since: 2.1
##
{
  "command": "change-backing-file",
  "data": {
    "device": "str",
    "image-node-name": "str",
    "backing-file": "str"
  }
}

##
# @block-commit:
#
# Live commit of data from overlay image nodes into backing nodes - i.e.,
# writes data between 'top' and 'base' into 'base'.
#
# @job-id: identifier for the newly-created block job. If
#          omitted, the device name will be used. (Since 2.7)
#
# @device:  the device name or node-name of a root node
#
# @base:   The file name of the backing image to write data into.
#                    If not specified, this is the deepest backing image.
#
# @top:    The file name of the backing image within the image chain,
#                    which contains the topmost data to be committed down. If
#                    not specified, this is the active layer.
#
# @backing-file:  The backing file string to write into the overlay
#                           image of 'top'.  If 'top' is the active layer,
#                           specifying a backing file string is an error. This
#                           filename is not validated.
#
#                           If a pathname string is such that it cannot be
#                           resolved by QEMU, that means that subsequent QMP or
#                           HMP commands must use node-names for the image in
#                           question, as filename lookup methods will fail.
#
#                           If not specified, QEMU will automatically determine
#                           the backing file string to use, or error out if
#                           there is no obvious choice. Care should be taken
#                           when specifying the string, to specify a valid
#                           filename or protocol.
#                           (Since 2.1)
#
#                    If top == base, that is an error.
#                    If top == active, the job will not be completed by itself,
#                    user needs to complete the job with the block-job-complete
#                    command after getting the ready event. (Since 2.0)
#
#                    If the base image is smaller than top, then the base image
#                    will be resized to be the same size as top.  If top is
#                    smaller than the base image, the base will not be
#                    truncated.  If you want the base image size to match the
#                    size of the smaller top, you can safely truncate it
#                    yourself once the commit operation successfully completes.
#
# @speed:  the maximum speed, in bytes per second
#
# @filter-node-name: the node name that should be assigned to the
#                    filter driver that the commit job inserts into the graph
#                    above @top. If this option is not given, a node name is
#                    autogenerated. (Since: 2.9)
#
# Returns: Nothing on success
#          If commit or stream is already active on this device, DeviceInUse
#          If @device does not exist, DeviceNotFound
#          If image commit is not supported by this device, NotSupported
#          If @base or @top is invalid, a generic error is returned
#          If @speed is invalid, InvalidParameter
#
# Since: 1.3
#
# Example:
#
# -> { "execute": "block-commit",
#      "arguments": { "device": "virtio0",
#                     "top": "/tmp/snap1.qcow2" } }
# <- { "return": {} }
#
##
{
  "command": "block-commit",
  "data": {
    "*job-id": "str",
    "device": "str",
    "*base": "str",
    "*top": "str",
    "*backing-file": "str",
    "*speed": "int",
    "*filter-node-name": "str"
  }
}

##
# @drive-backup:
#
# Start a point-in-time copy of a block device to a new destination.  The
# status of ongoing drive-backup operations can be checked with
# query-block-jobs where the BlockJobInfo.type field has the value 'backup'.
# The operation can be stopped before it has completed using the
# block-job-cancel command.
#
# Returns: nothing on success
#          If @device is not a valid block device, GenericError
#
# Since: 1.6
#
# Example:
#
# -> { "execute": "drive-backup",
#      "arguments": { "device": "drive0",
#                     "sync": "full",
#                     "target": "backup.img" } }
# <- { "return": {} }
#
##
{
  "command": "drive-backup",
  "boxed": true,
  "data": "DriveBackup"
}

##
# @blockdev-backup:
#
# Start a point-in-time copy of a block device to a new destination.  The
# status of ongoing blockdev-backup operations can be checked with
# query-block-jobs where the BlockJobInfo.type field has the value 'backup'.
# The operation can be stopped before it has completed using the
# block-job-cancel command.
#
# Returns: nothing on success
#          If @device is not a valid block device, DeviceNotFound
#
# Since: 2.3
#
# Example:
# -> { "execute": "blockdev-backup",
#      "arguments": { "device": "src-id",
#                     "sync": "full",
#                     "target": "tgt-id" } }
# <- { "return": {} }
#
##
{
  "command": "blockdev-backup",
  "boxed": true,
  "data": "BlockdevBackup"
}


##
# @query-named-block-nodes:
#
# Get the named block driver list
#
# Returns: the list of BlockDeviceInfo
#
# Since: 2.0
#
# Example:
#
# -> { "execute": "query-named-block-nodes" }
# <- { "return": [ { "ro":false,
#                    "drv":"qcow2",
#                    "encrypted":false,
#                    "file":"disks/test.qcow2",
#                    "node-name": "my-node",
#                    "backing_file_depth":1,
#                    "bps":1000000,
#                    "bps_rd":0,
#                    "bps_wr":0,
#                    "iops":1000000,
#                    "iops_rd":0,
#                    "iops_wr":0,
#                    "bps_max": 8000000,
#                    "bps_rd_max": 0,
#                    "bps_wr_max": 0,
#                    "iops_max": 0,
#                    "iops_rd_max": 0,
#                    "iops_wr_max": 0,
#                    "iops_size": 0,
#                    "write_threshold": 0,
#                    "image":{
#                       "filename":"disks/test.qcow2",
#                       "format":"qcow2",
#                       "virtual-size":2048000,
#                       "backing_file":"base.qcow2",
#                       "full-backing-filename":"disks/base.qcow2",
#                       "backing-filename-format":"qcow2",
#                       "snapshots":[
#                          {
#                             "id": "1",
#                             "name": "snapshot1",
#                             "vm-state-size": 0,
#                             "date-sec": 10000200,
#                             "date-nsec": 12,
#                             "vm-clock-sec": 206,
#                             "vm-clock-nsec": 30
#                          }
#                       ],
#                       "backing-image":{
#                           "filename":"disks/base.qcow2",
#                           "format":"qcow2",
#                           "virtual-size":2048000
#                       }
#                    } } ] }
#
##
{
  "command": "query-named-block-nodes",
  "returns": [
    "BlockDeviceInfo"
  ]
}

##
# @drive-mirror:
#
# Start mirroring a block device's writes to a new destination. target
# specifies the target of the new image. If the file exists, or if it
# is a device, it will be used as the new destination for writes. If
# it does not exist, a new file will be created. format specifies the
# format of the mirror image, default is to probe if mode='existing',
# else the format of the source.
#
# Returns: nothing on success
#          If @device is not a valid block device, GenericError
#
# Since: 1.3
#
# Example:
#
# -> { "execute": "drive-mirror",
#      "arguments": { "device": "ide-hd0",
#                     "target": "/some/place/my-image",
#                     "sync": "full",
#                     "format": "qcow2" } }
# <- { "return": {} }
#
##
{
  "command": "drive-mirror",
  "boxed": true,
  "data": "DriveMirror"
}

##
# @DriveMirror:
#
# A set of parameters describing drive mirror setup.
#
# @job-id: identifier for the newly-created block job. If
#          omitted, the device name will be used. (Since 2.7)
#
# @device:  the device name or node-name of a root node whose writes should be
#           mirrored.
#
# @target: the target of the new image. If the file exists, or if it
#          is a device, the existing file/device will be used as the new
#          destination.  If it does not exist, a new file will be created.
#
# @format: the format of the new destination, default is to
#          probe if @mode is 'existing', else the format of the source
#
# @node-name: the new block driver state node name in the graph
#             (Since 2.1)
#
# @replaces: with sync=full graph node name to be replaced by the new
#            image when a whole image copy is done. This can be used to repair
#            broken Quorum files. (Since 2.1)
#
# @mode: whether and how QEMU should create a new image, default is
#        'absolute-paths'.
#
# @speed:  the maximum speed, in bytes per second
#
# @sync: what parts of the disk image should be copied to the destination
#        (all the disk, only the sectors allocated in the topmost image, or
#        only new I/O).
#
# @granularity: granularity of the dirty bitmap, default is 64K
#               if the image format doesn't have clusters, 4K if the clusters
#               are smaller than that, else the cluster size.  Must be a
#               power of 2 between 512 and 64M (since 1.4).
#
# @buf-size: maximum amount of data in flight from source to
#            target (since 1.4).
#
# @on-source-error: the action to take on an error on the source,
#                   default 'report'.  'stop' and 'enospc' can only be used
#                   if the block device supports io-status (see BlockInfo).
#
# @on-target-error: the action to take on an error on the target,
#                   default 'report' (no limitations, since this applies to
#                   a different block device than @device).
# @unmap: Whether to try to unmap target sectors where source has
#         only zero. If true, and target unallocated sectors will read as zero,
#         target image sectors will be unmapped; otherwise, zeroes will be
#         written. Both will result in identical contents.
#         Default is true. (Since 2.4)
#
# Since: 1.3
##
{
  "struct": "DriveMirror",
  "data": {
    "*job-id": "str",
    "device": "str",
    "target": "str",
    "*format": "str",
    "*node-name": "str",
    "*replaces": "str",
    "sync": "MirrorSyncMode",
    "*mode": "NewImageMode",
    "*speed": "int",
    "*granularity": "uint32",
    "*buf-size": "int",
    "*on-source-error": "BlockdevOnError",
    "*on-target-error": "BlockdevOnError",
    "*unmap": "bool"
  }
}

##
# @BlockDirtyBitmap:
#
# @node: name of device/node which the bitmap is tracking
#
# @name: name of the dirty bitmap
#
# Since: 2.4
##
{
  "struct": "BlockDirtyBitmap",
  "data": {
    "node": "str",
    "name": "str"
  }
}

##
# @BlockDirtyBitmapAdd:
#
# @node: name of device/node which the bitmap is tracking
#
# @name: name of the dirty bitmap
#
# @granularity: the bitmap granularity, default is 64k for
#               block-dirty-bitmap-add
#
# @persistent: the bitmap is persistent, i.e. it will be saved to the
#              corresponding block device image file on its close. For now only
#              Qcow2 disks support persistent bitmaps. Default is false for
#              block-dirty-bitmap-add. (Since: 2.10)
#
# @autoload: the bitmap will be automatically loaded when the image it is stored
#            in is opened. This flag may only be specified for persistent
#            bitmaps. Default is false for block-dirty-bitmap-add. (Since: 2.10)
#
# Since: 2.4
##
{
  "struct": "BlockDirtyBitmapAdd",
  "data": {
    "node": "str",
    "name": "str",
    "*granularity": "uint32",
    "*persistent": "bool",
    "*autoload": "bool"
  }
}

##
# @block-dirty-bitmap-add:
#
# Create a dirty bitmap with a name on the node, and start tracking the writes.
#
# Returns: nothing on success
#          If @node is not a valid block device or node, DeviceNotFound
#          If @name is already taken, GenericError with an explanation
#
# Since: 2.4
#
# Example:
#
# -> { "execute": "block-dirty-bitmap-add",
#      "arguments": { "node": "drive0", "name": "bitmap0" } }
# <- { "return": {} }
#
##
{
  "command": "block-dirty-bitmap-add",
  "data": "BlockDirtyBitmapAdd"
}

##
# @block-dirty-bitmap-remove:
#
# Stop write tracking and remove the dirty bitmap that was created
# with block-dirty-bitmap-add. If the bitmap is persistent, remove it from its
# storage too.
#
# Returns: nothing on success
#          If @node is not a valid block device or node, DeviceNotFound
#          If @name is not found, GenericError with an explanation
#          if @name is frozen by an operation, GenericError
#
# Since: 2.4
#
# Example:
#
# -> { "execute": "block-dirty-bitmap-remove",
#      "arguments": { "node": "drive0", "name": "bitmap0" } }
# <- { "return": {} }
#
##
{
  "command": "block-dirty-bitmap-remove",
  "data": "BlockDirtyBitmap"
}

##
# @block-dirty-bitmap-clear:
#
# Clear (reset) a dirty bitmap on the device, so that an incremental
# backup from this point in time forward will only backup clusters
# modified after this clear operation.
#
# Returns: nothing on success
#          If @node is not a valid block device, DeviceNotFound
#          If @name is not found, GenericError with an explanation
#
# Since: 2.4
#
# Example:
#
# -> { "execute": "block-dirty-bitmap-clear",
#      "arguments": { "node": "drive0", "name": "bitmap0" } }
# <- { "return": {} }
#
##
{
  "command": "block-dirty-bitmap-clear",
  "data": "BlockDirtyBitmap"
}

##
# @blockdev-mirror:
#
# Start mirroring a block device's writes to a new destination.
#
# @job-id: identifier for the newly-created block job. If
#          omitted, the device name will be used. (Since 2.7)
#
# @device: The device name or node-name of a root node whose writes should be
#          mirrored.
#
# @target: the id or node-name of the block device to mirror to. This mustn't be
#          attached to guest.
#
# @replaces: with sync=full graph node name to be replaced by the new
#            image when a whole image copy is done. This can be used to repair
#            broken Quorum files.
#
# @speed:  the maximum speed, in bytes per second
#
# @sync: what parts of the disk image should be copied to the destination
#        (all the disk, only the sectors allocated in the topmost image, or
#        only new I/O).
#
# @granularity: granularity of the dirty bitmap, default is 64K
#               if the image format doesn't have clusters, 4K if the clusters
#               are smaller than that, else the cluster size.  Must be a
#               power of 2 between 512 and 64M
#
# @buf-size: maximum amount of data in flight from source to
#            target
#
# @on-source-error: the action to take on an error on the source,
#                   default 'report'.  'stop' and 'enospc' can only be used
#                   if the block device supports io-status (see BlockInfo).
#
# @on-target-error: the action to take on an error on the target,
#                   default 'report' (no limitations, since this applies to
#                   a different block device than @device).
#
# @filter-node-name: the node name that should be assigned to the
#                    filter driver that the mirror job inserts into the graph
#                    above @device. If this option is not given, a node name is
#                    autogenerated. (Since: 2.9)
#
# Returns: nothing on success.
#
# Since: 2.6
#
# Example:
#
# -> { "execute": "blockdev-mirror",
#      "arguments": { "device": "ide-hd0",
#                     "target": "target0",
#                     "sync": "full" } }
# <- { "return": {} }
#
##
{
  "command": "blockdev-mirror",
  "data": {
    "*job-id": "str",
    "device": "str",
    "target": "str",
    "*replaces": "str",
    "sync": "MirrorSyncMode",
    "*speed": "int",
    "*granularity": "uint32",
    "*buf-size": "int",
    "*on-source-error": "BlockdevOnError",
    "*on-target-error": "BlockdevOnError",
    "*filter-node-name": "str"
  }
}

##
{
  "command": "block_set_io_throttle",
  "boxed": true,
  "data": "BlockIOThrottle"
}

##
# @BlockIOThrottle:
#
# A set of parameters describing block throttling.
#
# @device: Block device name (deprecated, use @id instead)
#
# @id: The name or QOM path of the guest device (since: 2.8)
#
# @bps: total throughput limit in bytes per second
#
# @bps_rd: read throughput limit in bytes per second
#
# @bps_wr: write throughput limit in bytes per second
#
# @iops: total I/O operations per second
#
# @iops_rd: read I/O operations per second
#
# @iops_wr: write I/O operations per second
#
# @bps_max: total throughput limit during bursts,
#                     in bytes (Since 1.7)
#
# @bps_rd_max: read throughput limit during bursts,
#                        in bytes (Since 1.7)
#
# @bps_wr_max: write throughput limit during bursts,
#                        in bytes (Since 1.7)
#
# @iops_max: total I/O operations per second during bursts,
#                      in bytes (Since 1.7)
#
# @iops_rd_max: read I/O operations per second during bursts,
#                         in bytes (Since 1.7)
#
# @iops_wr_max: write I/O operations per second during bursts,
#                         in bytes (Since 1.7)
#
# @bps_max_length: maximum length of the @bps_max burst
#                            period, in seconds. It must only
#                            be set if @bps_max is set as well.
#                            Defaults to 1. (Since 2.6)
#
# @bps_rd_max_length: maximum length of the @bps_rd_max
#                               burst period, in seconds. It must only
#                               be set if @bps_rd_max is set as well.
#                               Defaults to 1. (Since 2.6)
#
# @bps_wr_max_length: maximum length of the @bps_wr_max
#                               burst period, in seconds. It must only
#                               be set if @bps_wr_max is set as well.
#                               Defaults to 1. (Since 2.6)
#
# @iops_max_length: maximum length of the @iops burst
#                             period, in seconds. It must only
#                             be set if @iops_max is set as well.
#                             Defaults to 1. (Since 2.6)
#
# @iops_rd_max_length: maximum length of the @iops_rd_max
#                                burst period, in seconds. It must only
#                                be set if @iops_rd_max is set as well.
#                                Defaults to 1. (Since 2.6)
#
# @iops_wr_max_length: maximum length of the @iops_wr_max
#                                burst period, in seconds. It must only
#                                be set if @iops_wr_max is set as well.
#                                Defaults to 1. (Since 2.6)
#
# @iops_size: an I/O size in bytes (Since 1.7)
#
# @group: throttle group name (Since 2.4)
#
# Since: 1.1
##
{
  "struct": "BlockIOThrottle",
  "data": {
    "*device": "str",
    "*id": "str",
    "bps": "int",
    "bps_rd": "int",
    "bps_wr": "int",
    "iops": "int",
    "iops_rd": "int",
    "iops_wr": "int",
    "*bps_max": "int",
    "*bps_rd_max": "int",
    "*bps_wr_max": "int",
    "*iops_max": "int",
    "*iops_rd_max": "int",
    "*iops_wr_max": "int",
    "*bps_max_length": "int",
    "*bps_rd_max_length": "int",
    "*bps_wr_max_length": "int",
    "*iops_max_length": "int",
    "*iops_rd_max_length": "int",
    "*iops_wr_max_length": "int",
    "*iops_size": "int",
    "*group": "str"
  }
}

##
# @ThrottleLimits:
#
# Limit parameters for throttling.
# Since some limit combinations are illegal, limits should always be set in one
# transaction. All fields are optional. When setting limits, if a field is
# missing the current value is not changed.
#
# @iops-total:             limit total I/O operations per second
# @iops-total-max:         I/O operations burst
# @iops-total-max-length:  length of the iops-total-max burst period, in seconds
#                          It must only be set if @iops-total-max is set as well.
# @iops-read:              limit read operations per second
# @iops-read-max:          I/O operations read burst
# @iops-read-max-length:   length of the iops-read-max burst period, in seconds
#                          It must only be set if @iops-read-max is set as well.
# @iops-write:             limit write operations per second
# @iops-write-max:         I/O operations write burst
# @iops-write-max-length:  length of the iops-write-max burst period, in seconds
#                          It must only be set if @iops-write-max is set as well.
# @bps-total:              limit total bytes per second
# @bps-total-max:          total bytes burst
# @bps-total-max-length:   length of the bps-total-max burst period, in seconds.
#                          It must only be set if @bps-total-max is set as well.
# @bps-read:               limit read bytes per second
# @bps-read-max:           total bytes read burst
# @bps-read-max-length:    length of the bps-read-max burst period, in seconds
#                          It must only be set if @bps-read-max is set as well.
# @bps-write:              limit write bytes per second
# @bps-write-max:          total bytes write burst
# @bps-write-max-length:   length of the bps-write-max burst period, in seconds
#                          It must only be set if @bps-write-max is set as well.
# @iops-size:              when limiting by iops max size of an I/O in bytes
#
# Since: 2.11
##
{
  "struct": "ThrottleLimits",
  "data": {
    "*iops-total": "int",
    "*iops-total-max": "int",
    "*iops-total-max-length": "int",
    "*iops-read": "int",
    "*iops-read-max": "int",
    "*iops-read-max-length": "int",
    "*iops-write": "int",
    "*iops-write-max": "int",
    "*iops-write-max-length": "int",
    "*bps-total": "int",
    "*bps-total-max": "int",
    "*bps-total-max-length": "int",
    "*bps-read": "int",
    "*bps-read-max": "int",
    "*bps-read-max-length": "int",
    "*bps-write": "int",
    "*bps-write-max": "int",
    "*bps-write-max-length": "int",
    "*iops-size": "int"
  }
}

##
# @block-stream:
#
# Copy data from a backing file into a block device.
#
# The block streaming operation is performed in the background until the entire
# backing file has been copied.  This command returns immediately once streaming
# has started.  The status of ongoing block streaming operations can be checked
# with query-block-jobs.  The operation can be stopped before it has completed
# using the block-job-cancel command.
#
# The node that receives the data is called the top image, can be located in
# any part of the chain (but always above the base image; see below) and can be
# specified using its device or node name. Earlier qemu versions only allowed
# 'device' to name the top level node; presence of the 'base-node' parameter
# during introspection can be used as a witness of the enhanced semantics
# of 'device'.
#
# If a base file is specified then sectors are not copied from that base file and
# its backing chain.  When streaming completes the image file will have the base
# file as its backing file.  This can be used to stream a subset of the backing
# file chain instead of flattening the entire image.
#
# On successful completion the image file is updated to drop the backing file
# and the BLOCK_JOB_COMPLETED event is emitted.
#
# @job-id: identifier for the newly-created block job. If
#          omitted, the device name will be used. (Since 2.7)
#
# @device: the device or node name of the top image
#
# @base:   the common backing file name.
#                    It cannot be set if @base-node is also set.
#
# @base-node: the node name of the backing file.
#                       It cannot be set if @base is also set. (Since 2.8)
#
# @backing-file: The backing file string to write into the top
#                          image. This filename is not validated.
#
#                          If a pathname string is such that it cannot be
#                          resolved by QEMU, that means that subsequent QMP or
#                          HMP commands must use node-names for the image in
#                          question, as filename lookup methods will fail.
#
#                          If not specified, QEMU will automatically determine
#                          the backing file string to use, or error out if there
#                          is no obvious choice.  Care should be taken when
#                          specifying the string, to specify a valid filename or
#                          protocol.
#                          (Since 2.1)
#
# @speed:  the maximum speed, in bytes per second
#
# @on-error: the action to take on an error (default report).
#            'stop' and 'enospc' can only be used if the block device
#            supports io-status (see BlockInfo).  Since 1.3.
#
# Returns: Nothing on success. If @device does not exist, DeviceNotFound.
#
# Since: 1.1
#
# Example:
#
# -> { "execute": "block-stream",
#      "arguments": { "device": "virtio0",
#                     "base": "/tmp/master.qcow2" } }
# <- { "return": {} }
#
##
{
  "command": "block-stream",
  "data": {
    "*job-id": "str",
    "device": "str",
    "*base": "str",
    "*base-node": "str",
    "*backing-file": "str",
    "*speed": "int",
    "*on-error": "BlockdevOnError"
  }
}

##
# @block-job-set-speed:
#
# Set maximum speed for a background block operation.
#
# This command can only be issued when there is an active block job.
#
# Throttling can be disabled by setting the speed to 0.
#
# @device: The job identifier. This used to be a device name (hence
#          the name of the parameter), but since QEMU 2.7 it can have
#          other values.
#
# @speed:  the maximum speed, in bytes per second, or 0 for unlimited.
#          Defaults to 0.
#
# Returns: Nothing on success
#          If no background operation is active on this device, DeviceNotActive
#
# Since: 1.1
##
{
  "command": "block-job-set-speed",
  "data": {
    "device": "str",
    "speed": "int"
  }
}

##
# @block-job-cancel:
#
# Stop an active background block operation.
#
# This command returns immediately after marking the active background block
# operation for cancellation.  It is an error to call this command if no
# operation is in progress.
#
# The operation will cancel as soon as possible and then emit the
# BLOCK_JOB_CANCELLED event.  Before that happens the job is still visible when
# enumerated using query-block-jobs.
#
# Note that if you issue 'block-job-cancel' after 'drive-mirror' has indicated
# (via the event BLOCK_JOB_READY) that the source and destination are
# synchronized, then the event triggered by this command changes to
# BLOCK_JOB_COMPLETED, to indicate that the mirroring has ended and the
# destination now has a point-in-time copy tied to the time of the cancellation.
#
# For streaming, the image file retains its backing file unless the streaming
# operation happens to complete just as it is being cancelled.  A new streaming
# operation can be started at a later time to finish copying all data from the
# backing file.
#
# @device: The job identifier. This used to be a device name (hence
#          the name of the parameter), but since QEMU 2.7 it can have
#          other values.
#
# @force: whether to allow cancellation of a paused job (default
#         false).  Since 1.3.
#
# Returns: Nothing on success
#          If no background operation is active on this device, DeviceNotActive
#
# Since: 1.1
##
{
  "command": "block-job-cancel",
  "data": {
    "device": "str",
    "*force": "bool"
  }
}

##
# @block-job-pause:
#
# Pause an active background block operation.
#
# This command returns immediately after marking the active background block
# operation for pausing.  It is an error to call this command if no
# operation is in progress.  Pausing an already paused job has no cumulative
# effect; a single block-job-resume command will resume the job.
#
# The operation will pause as soon as possible.  No event is emitted when
# the operation is actually paused.  Cancelling a paused job automatically
# resumes it.
#
# @device: The job identifier. This used to be a device name (hence
#          the name of the parameter), but since QEMU 2.7 it can have
#          other values.
#
# Returns: Nothing on success
#          If no background operation is active on this device, DeviceNotActive
#
# Since: 1.3
##
{
  "command": "block-job-pause",
  "data": {
    "device": "str"
  }
}

##
# @block-job-resume:
#
# Resume an active background block operation.
#
# This command returns immediately after resuming a paused background block
# operation.  It is an error to call this command if no operation is in
# progress.  Resuming an already running job is not an error.
#
# This command also clears the error status of the job.
#
# @device: The job identifier. This used to be a device name (hence
#          the name of the parameter), but since QEMU 2.7 it can have
#          other values.
#
# Returns: Nothing on success
#          If no background operation is active on this device, DeviceNotActive
#
# Since: 1.3
##
{
  "command": "block-job-resume",
  "data": {
    "device": "str"
  }
}

##
# @block-job-complete:
#
# Manually trigger completion of an active background block operation.  This
# is supported for drive mirroring, where it also switches the device to
# write to the target path only.  The ability to complete is signaled with
# a BLOCK_JOB_READY event.
#
# This command completes an active background block operation synchronously.
# The ordering of this command's return with the BLOCK_JOB_COMPLETED event
# is not defined.  Note that if an I/O error occurs during the processing of
# this command: 1) the command itself will fail; 2) the error will be processed
# according to the rerror/werror arguments that were specified when starting
# the operation.
#
# A cancelled or paused job cannot be completed.
#
# @device: The job identifier. This used to be a device name (hence
#          the name of the parameter), but since QEMU 2.7 it can have
#          other values.
#
# Returns: Nothing on success
#          If no background operation is active on this device, DeviceNotActive
#
# Since: 1.3
##
{
  "command": "block-job-complete",
  "data": {
    "device": "str"
  }
}

##
# @BlockdevDiscardOptions:
#
# Determines how to handle discard requests.
#
# @ignore:      Ignore the request
# @unmap:       Forward as an unmap request
#
# Since: 2.9
##
{
  "enum": "BlockdevDiscardOptions",
  "data": [
    "ignore",
    "unmap"
  ]
}

##
# @BlockdevDetectZeroesOptions:
#
# Describes the operation mode for the automatic conversion of plain
# zero writes by the OS to driver specific optimized zero write commands.
#
# @off:      Disabled (default)
# @on:       Enabled
# @unmap:    Enabled and even try to unmap blocks if possible. This requires
#            also that @BlockdevDiscardOptions is set to unmap for this device.
#
# Since: 2.1
##
{
  "enum": "BlockdevDetectZeroesOptions",
  "data": [
    "off",
    "on",
    "unmap"
  ]
}

##
# @BlockdevAioOptions:
#
# Selects the AIO backend to handle I/O requests
#
# @threads:     Use qemu's thread pool
# @native:      Use native AIO backend (only Linux and Windows)
#
# Since: 2.9
##
{
  "enum": "BlockdevAioOptions",
  "data": [
    "threads",
    "native"
  ]
}

##
# @BlockdevCacheOptions:
#
# Includes cache-related options for block devices
#
# @direct:      enables use of O_DIRECT (bypass the host page cache;
#               default: false)
# @no-flush:    ignore any flush requests for the device (default:
#               false)
#
# Since: 2.9
##
{
  "struct": "BlockdevCacheOptions",
  "data": {
    "*direct": "bool",
    "*no-flush": "bool"
  }
}

##
# @BlockdevDriver:
#
# Drivers that are supported in block device operations.
#
# @vxhs: Since 2.10
# @throttle: Since 2.11
#
# Since: 2.9
##
{
  "enum": "BlockdevDriver",
  "data": [
    "blkdebug",
    "blkverify",
    "bochs",
    "cloop",
    "dmg",
    "file",
    "ftp",
    "ftps",
    "gluster",
    "host_cdrom",
    "host_device",
    "http",
    "https",
    "iscsi",
    "luks",
    "nbd",
    "nfs",
    "null-aio",
    "null-co",
    "parallels",
    "qcow",
    "qcow2",
    "qed",
    "quorum",
    "raw",
    "rbd",
    "replication",
    "sheepdog",
    "ssh",
    "throttle",
    "vdi",
    "vhdx",
    "vmdk",
    "vpc",
    "vvfat",
    "vxhs"
  ]
}

##
# @BlockdevOptionsFile:
#
# Driver specific block device options for the file backend.
#
# @filename:    path to the image file
# @pr-manager:  the id for the object that will handle persistent reservations
#               for this device (default: none, forward the commands via SG_IO;
#               since 2.11)
# @aio:         AIO backend (default: threads) (since: 2.8)
# @locking:     whether to enable file locking. If set to 'auto', only enable
#               when Open File Descriptor (OFD) locking API is available
#               (default: auto, since 2.10)
#
# Since: 2.9
##
{
  "struct": "BlockdevOptionsFile",
  "data": {
    "filename": "str",
    "*pr-manager": "str",
    "*locking": "OnOffAuto",
    "*aio": "BlockdevAioOptions"
  }
}

##
# @BlockdevOptionsNull:
#
# Driver specific block device options for the null backend.
#
# @size:    size of the device in bytes.
# @latency-ns: emulated latency (in nanoseconds) in processing
#              requests. Default to zero which completes requests immediately.
#              (Since 2.4)
#
# Since: 2.9
##
{
  "struct": "BlockdevOptionsNull",
  "data": {
    "*size": "int",
    "*latency-ns": "uint64"
  }
}

##
# @BlockdevOptionsVVFAT:
#
# Driver specific block device options for the vvfat protocol.
#
# @dir:         directory to be exported as FAT image
# @fat-type:    FAT type: 12, 16 or 32
# @floppy:      whether to export a floppy image (true) or
#               partitioned hard disk (false; default)
# @label:       set the volume label, limited to 11 bytes. FAT16 and
#               FAT32 traditionally have some restrictions on labels, which are
#               ignored by most operating systems. Defaults to "QEMU VVFAT".
#               (since 2.4)
# @rw:          whether to allow write operations (default: false)
#
# Since: 2.9
##
{
  "struct": "BlockdevOptionsVVFAT",
  "data": {
    "dir": "str",
    "*fat-type": "int",
    "*floppy": "bool",
    "*label": "str",
    "*rw": "bool"
  }
}

##
# @BlockdevOptionsGenericFormat:
#
# Driver specific block device options for image format that have no option
# besides their data source.
#
# @file:        reference to or definition of the data source block device
#
# Since: 2.9
##
{
  "struct": "BlockdevOptionsGenericFormat",
  "data": {
    "file": "BlockdevRef"
  }
}

##
# @BlockdevOptionsLUKS:
#
# Driver specific block device options for LUKS.
#
# @key-secret: the ID of a QCryptoSecret object providing
#              the decryption key (since 2.6). Mandatory except when
#              doing a metadata-only probe of the image.
#
# Since: 2.9
##
{
  "struct": "BlockdevOptionsLUKS",
  "base": "BlockdevOptionsGenericFormat",
  "data": {
    "*key-secret": "str"
  }
}


##
# @BlockdevOptionsGenericCOWFormat:
#
# Driver specific block device options for image format that have no option
# besides their data source and an optional backing file.
#
# @backing:     reference to or definition of the backing file block
#               device, null disables the backing file entirely.
#               Defaults to the backing file stored the image file.
#
# Since: 2.9
##
{
  "struct": "BlockdevOptionsGenericCOWFormat",
  "base": "BlockdevOptionsGenericFormat",
  "data": {
    "*backing": "BlockdevRefOrNull"
  }
}

##
# @Qcow2OverlapCheckMode:
#
# General overlap check modes.
#
# @none:        Do not perform any checks
#
# @constant:    Perform only checks which can be done in constant time and
#               without reading anything from disk
#
# @cached:      Perform only checks which can be done without reading anything
#               from disk
#
# @all:         Perform all available overlap checks
#
# Since: 2.9
##
{
  "enum": "Qcow2OverlapCheckMode",
  "data": [
    "none",
    "constant",
    "cached",
    "all"
  ]
}

##
# @Qcow2OverlapCheckFlags:
#
# Structure of flags for each metadata structure. Setting a field to 'true'
# makes qemu guard that structure against unintended overwriting. The default
# value is chosen according to the template given.
#
# @template: Specifies a template mode which can be adjusted using the other
#            flags, defaults to 'cached'
#
# Since: 2.9
##
{
  "struct": "Qcow2OverlapCheckFlags",
  "data": {
    "*template": "Qcow2OverlapCheckMode",
    "*main-header": "bool",
    "*active-l1": "bool",
    "*active-l2": "bool",
    "*refcount-table": "bool",
    "*refcount-block": "bool",
    "*snapshot-table": "bool",
    "*inactive-l1": "bool",
    "*inactive-l2": "bool"
  }
}

##
# @Qcow2OverlapChecks:
#
# Specifies which metadata structures should be guarded against unintended
# overwriting.
#
# @flags:   set of flags for separate specification of each metadata structure
#           type
#
# @mode:    named mode which chooses a specific set of flags
#
# Since: 2.9
##
{
  "alternate": "Qcow2OverlapChecks",
  "data": {
    "flags": "Qcow2OverlapCheckFlags",
    "mode": "Qcow2OverlapCheckMode"
  }
}

##
# @BlockdevQcowEncryptionFormat:
#
# @aes: AES-CBC with plain64 initialization vectors
#
# Since: 2.10
##
{
  "enum": "BlockdevQcowEncryptionFormat",
  "data": [
    "aes"
  ]
}

##
# @BlockdevQcowEncryption:
#
# Since: 2.10
##
{
  "union": "BlockdevQcowEncryption",
  "base": {
    "format": "BlockdevQcowEncryptionFormat"
  },
  "discriminator": "format",
  "data": {
    "aes": "QCryptoBlockOptionsQCow"
  }
}

##
# @BlockdevOptionsQcow:
#
# Driver specific block device options for qcow.
#
# @encrypt:               Image decryption options. Mandatory for
#                         encrypted images, except when doing a metadata-only
#                         probe of the image.
#
# Since: 2.10
##
{
  "struct": "BlockdevOptionsQcow",
  "base": "BlockdevOptionsGenericCOWFormat",
  "data": {
    "*encrypt": "BlockdevQcowEncryption"
  }
}

##
# @BlockdevQcow2EncryptionFormat:
# @aes: AES-CBC with plain64 initialization venctors
#
# Since: 2.10
##
{
  "enum": "BlockdevQcow2EncryptionFormat",
  "data": [
    "aes",
    "luks"
  ]
}

##
# @BlockdevQcow2Encryption:
#
# Since: 2.10
##
{
  "union": "BlockdevQcow2Encryption",
  "base": {
    "format": "BlockdevQcow2EncryptionFormat"
  },
  "discriminator": "format",
  "data": {
    "aes": "QCryptoBlockOptionsQCow",
    "luks": "QCryptoBlockOptionsLUKS"
  }
}

##
# @BlockdevOptionsQcow2:
#
# Driver specific block device options for qcow2.
#
# @lazy-refcounts:        whether to enable the lazy refcounts
#                         feature (default is taken from the image file)
#
# @pass-discard-request:  whether discard requests to the qcow2
#                         device should be forwarded to the data source
#
# @pass-discard-snapshot: whether discard requests for the data source
#                         should be issued when a snapshot operation (e.g.
#                         deleting a snapshot) frees clusters in the qcow2 file
#
# @pass-discard-other:    whether discard requests for the data source
#                         should be issued on other occasions where a cluster
#                         gets freed
#
# @overlap-check:         which overlap checks to perform for writes
#                         to the image, defaults to 'cached' (since 2.2)
#
# @cache-size:            the maximum total size of the L2 table and
#                         refcount block caches in bytes (since 2.2)
#
# @l2-cache-size:         the maximum size of the L2 table cache in
#                         bytes (since 2.2)
#
# @refcount-cache-size:   the maximum size of the refcount block cache
#                         in bytes (since 2.2)
#
# @cache-clean-interval:  clean unused entries in the L2 and refcount
#                         caches. The interval is in seconds. The default value
#                         is 0 and it disables this feature (since 2.5)
# @encrypt:               Image decryption options. Mandatory for
#                         encrypted images, except when doing a metadata-only
#                         probe of the image. (since 2.10)
#
# Since: 2.9
##
{
  "struct": "BlockdevOptionsQcow2",
  "base": "BlockdevOptionsGenericCOWFormat",
  "data": {
    "*lazy-refcounts": "bool",
    "*pass-discard-request": "bool",
    "*pass-discard-snapshot": "bool",
    "*pass-discard-other": "bool",
    "*overlap-check": "Qcow2OverlapChecks",
    "*cache-size": "int",
    "*l2-cache-size": "int",
    "*refcount-cache-size": "int",
    "*cache-clean-interval": "int",
    "*encrypt": "BlockdevQcow2Encryption"
  }
}

##
# @BlockdevOptionsSsh:
#
# @server:              host address
#
# @path:                path to the image on the host
#
# @user:                user as which to connect, defaults to current
#                       local user name
#
# TODO: Expose the host_key_check option in QMP
#
# Since: 2.9
##
{
  "struct": "BlockdevOptionsSsh",
  "data": {
    "server": "InetSocketAddress",
    "path": "str",
    "*user": "str"
  }
}


##
# @BlkdebugEvent:
#
# Trigger events supported by blkdebug.
#
# @l1_shrink_write_table:      write zeros to the l1 table to shrink image.
#                              (since 2.11)
#
# @l1_shrink_free_l2_clusters: discard the l2 tables. (since 2.11)
#
# @cor_write: a write due to copy-on-read (since 2.11)
#
# Since: 2.9
##
{
  "enum": "BlkdebugEvent",
  "prefix": "BLKDBG",
  "data": [
    "l1_update",
    "l1_grow_alloc_table",
    "l1_grow_write_table",
    "l1_grow_activate_table",
    "l2_load",
    "l2_update",
    "l2_update_compressed",
    "l2_alloc_cow_read",
    "l2_alloc_write",
    "read_aio",
    "read_backing_aio",
    "read_compressed",
    "write_aio",
    "write_compressed",
    "vmstate_load",
    "vmstate_save",
    "cow_read",
    "cow_write",
    "reftable_load",
    "reftable_grow",
    "reftable_update",
    "refblock_load",
    "refblock_update",
    "refblock_update_part",
    "refblock_alloc",
    "refblock_alloc_hookup",
    "refblock_alloc_write",
    "refblock_alloc_write_blocks",
    "refblock_alloc_write_table",
    "refblock_alloc_switch_table",
    "cluster_alloc",
    "cluster_alloc_bytes",
    "cluster_free",
    "flush_to_os",
    "flush_to_disk",
    "pwritev_rmw_head",
    "pwritev_rmw_after_head",
    "pwritev_rmw_tail",
    "pwritev_rmw_after_tail",
    "pwritev",
    "pwritev_zero",
    "pwritev_done",
    "empty_image_prepare",
    "l1_shrink_write_table",
    "l1_shrink_free_l2_clusters",
    "cor_write"
  ]
}

##
# @BlkdebugInjectErrorOptions:
#
# Describes a single error injection for blkdebug.
#
# @event:       trigger event
#
# @state:       the state identifier blkdebug needs to be in to
#               actually trigger the event; defaults to "any"
#
# @errno:       error identifier (errno) to be returned; defaults to
#               EIO
#
# @sector:      specifies the sector index which has to be affected
#               in order to actually trigger the event; defaults to "any
#               sector"
#
# @once:        disables further events after this one has been
#               triggered; defaults to false
#
# @immediately: fail immediately; defaults to false
#
# Since: 2.9
##
{
  "struct": "BlkdebugInjectErrorOptions",
  "data": {
    "event": "BlkdebugEvent",
    "*state": "int",
    "*errno": "int",
    "*sector": "int",
    "*once": "bool",
    "*immediately": "bool"
  }
}

##
# @BlkdebugSetStateOptions:
#
# Describes a single state-change event for blkdebug.
#
# @event:       trigger event
#
# @state:       the current state identifier blkdebug needs to be in;
#               defaults to "any"
#
# @new_state:   the state identifier blkdebug is supposed to assume if
#               this event is triggered
#
# Since: 2.9
##
{
  "struct": "BlkdebugSetStateOptions",
  "data": {
    "event": "BlkdebugEvent",
    "*state": "int",
    "new_state": "int"
  }
}

##
# @BlockdevOptionsBlkdebug:
#
# Driver specific block device options for blkdebug.
#
# @image:           underlying raw block device (or image file)
#
# @config:          filename of the configuration file
#
# @align:           required alignment for requests in bytes, must be
#                   positive power of 2, or 0 for default
#
# @max-transfer:    maximum size for I/O transfers in bytes, must be
#                   positive multiple of @align and of the underlying
#                   file's request alignment (but need not be a power of
#                   2), or 0 for default (since 2.10)
#
# @opt-write-zero:  preferred alignment for write zero requests in bytes,
#                   must be positive multiple of @align and of the
#                   underlying file's request alignment (but need not be a
#                   power of 2), or 0 for default (since 2.10)
#
# @max-write-zero:  maximum size for write zero requests in bytes, must be
#                   positive multiple of @align, of @opt-write-zero, and of
#                   the underlying file's request alignment (but need not
#                   be a power of 2), or 0 for default (since 2.10)
#
# @opt-discard:     preferred alignment for discard requests in bytes, must
#                   be positive multiple of @align and of the underlying
#                   file's request alignment (but need not be a power of
#                   2), or 0 for default (since 2.10)
#
# @max-discard:     maximum size for discard requests in bytes, must be
#                   positive multiple of @align, of @opt-discard, and of
#                   the underlying file's request alignment (but need not
#                   be a power of 2), or 0 for default (since 2.10)
#
# @inject-error:    array of error injection descriptions
#
# @set-state:       array of state-change descriptions
#
# Since: 2.9
##
{
  "struct": "BlockdevOptionsBlkdebug",
  "data": {
    "image": "BlockdevRef",
    "*config": "str",
    "*align": "int",
    "*max-transfer": "int32",
    "*opt-write-zero": "int32",
    "*max-write-zero": "int32",
    "*opt-discard": "int32",
    "*max-discard": "int32",
    "*inject-error": [
      "BlkdebugInjectErrorOptions"
    ],
    "*set-state": [
      "BlkdebugSetStateOptions"
    ]
  }
}

##
# @BlockdevOptionsBlkverify:
#
# Driver specific block device options for blkverify.
#
# @test:    block device to be tested
#
# @raw:     raw image used for verification
#
# Since: 2.9
##
{
  "struct": "BlockdevOptionsBlkverify",
  "data": {
    "test": "BlockdevRef",
    "raw": "BlockdevRef"
  }
}

##
# @QuorumReadPattern:
#
# An enumeration of quorum read patterns.
#
# @quorum: read all the children and do a quorum vote on reads
#
# @fifo: read only from the first child that has not failed
#
# Since: 2.9
##
{
  "enum": "QuorumReadPattern",
  "data": [
    "quorum",
    "fifo"
  ]
}

##
# @BlockdevOptionsQuorum:
#
# Driver specific block device options for Quorum
#
# @blkverify:      true if the driver must print content mismatch
#                  set to false by default
#
# @children:       the children block devices to use
#
# @vote-threshold: the vote limit under which a read will fail
#
# @rewrite-corrupted: rewrite corrupted data when quorum is reached
#                     (Since 2.1)
#
# @read-pattern: choose read pattern and set to quorum by default
#                (Since 2.2)
#
# Since: 2.9
##
{
  "struct": "BlockdevOptionsQuorum",
  "data": {
    "*blkverify": "bool",
    "children": [
      "BlockdevRef"
    ],
    "vote-threshold": "int",
    "*rewrite-corrupted": "bool",
    "*read-pattern": "QuorumReadPattern"
  }
}

##
# @BlockdevOptionsGluster:
#
# Driver specific block device options for Gluster
#
# @volume:      name of gluster volume where VM image resides
#
# @path:        absolute path to image file in gluster volume
#
# @server:      gluster servers description
#
# @debug:       libgfapi log level (default '4' which is Error)
#               (Since 2.8)
#
# @logfile:     libgfapi log file (default /dev/stderr) (Since 2.8)
#
# Since: 2.9
##
{
  "struct": "BlockdevOptionsGluster",
  "data": {
    "volume": "str",
    "path": "str",
    "server": [
      "SocketAddress"
    ],
    "*debug": "int",
    "*logfile": "str"
  }
}

##
# @IscsiTransport:
#
# An enumeration of libiscsi transport types
#
# Since: 2.9
##
{
  "enum": "IscsiTransport",
  "data": [
    "tcp",
    "iser"
  ]
}

##
# @IscsiHeaderDigest:
#
# An enumeration of header digests supported by libiscsi
#
# Since: 2.9
##
{
  "enum": "IscsiHeaderDigest",
  "prefix": "QAPI_ISCSI_HEADER_DIGEST",
  "data": [
    "crc32c",
    "none",
    "crc32c-none",
    "none-crc32c"
  ]
}

##
# @BlockdevOptionsIscsi:
#
# @transport:       The iscsi transport type
#
# @portal:          The address of the iscsi portal
#
# @target:          The target iqn name
#
# @lun:             LUN to connect to. Defaults to 0.
#
# @user:            User name to log in with. If omitted, no CHAP
#                   authentication is performed.
#
# @password-secret: The ID of a QCryptoSecret object providing
#                   the password for the login. This option is required if
#                   @user is specified.
#
# @initiator-name:  The iqn name we want to identify to the target
#                   as. If this option is not specified, an initiator name is
#                   generated automatically.
#
# @header-digest:   The desired header digest. Defaults to
#                   none-crc32c.
#
# @timeout:         Timeout in seconds after which a request will
#                   timeout. 0 means no timeout and is the default.
#
# Driver specific block device options for iscsi
#
# Since: 2.9
##
{
  "struct": "BlockdevOptionsIscsi",
  "data": {
    "transport": "IscsiTransport",
    "portal": "str",
    "target": "str",
    "*lun": "int",
    "*user": "str",
    "*password-secret": "str",
    "*initiator-name": "str",
    "*header-digest": "IscsiHeaderDigest",
    "*timeout": "int"
  }
}


##
# @BlockdevOptionsRbd:
#
# @pool:               Ceph pool name.
#
# @image:              Image name in the Ceph pool.
#
# @conf:               path to Ceph configuration file.  Values
#                      in the configuration file will be overridden by
#                      options specified via QAPI.
#
# @snapshot:           Ceph snapshot name.
#
# @user:               Ceph id name.
#
# @server:             Monitor host address and port.  This maps
#                      to the "mon_host" Ceph option.
#
# Since: 2.9
##
{
  "struct": "BlockdevOptionsRbd",
  "data": {
    "pool": "str",
    "image": "str",
    "*conf": "str",
    "*snapshot": "str",
    "*user": "str",
    "*server": [
      "InetSocketAddressBase"
    ]
  }
}

##
# @BlockdevOptionsSheepdog:
#
# Driver specific block device options for sheepdog
#
# @vdi:         Virtual disk image name
# @server:      The Sheepdog server to connect to
# @snap-id:     Snapshot ID
# @tag:         Snapshot tag name
#
# Only one of @snap-id and @tag may be present.
#
# Since: 2.9
##
{
  "struct": "BlockdevOptionsSheepdog",
  "data": {
    "server": "SocketAddress",
    "vdi": "str",
    "*snap-id": "uint32",
    "*tag": "str"
  }
}

##
# @ReplicationMode:
#
# An enumeration of replication modes.
#
# @primary: Primary mode, the vm's state will be sent to secondary QEMU.
#
# @secondary: Secondary mode, receive the vm's state from primary QEMU.
#
# Since: 2.9
##
{
  "enum": "ReplicationMode",
  "data": [
    "primary",
    "secondary"
  ]
}

##
# @BlockdevOptionsReplication:
#
# Driver specific block device options for replication
#
# @mode: the replication mode
#
# @top-id: In secondary mode, node name or device ID of the root
#          node who owns the replication node chain. Must not be given in
#          primary mode.
#
# Since: 2.9
##
{
  "struct": "BlockdevOptionsReplication",
  "base": "BlockdevOptionsGenericFormat",
  "data": {
    "mode": "ReplicationMode",
    "*top-id": "str"
  }
}

##
# @NFSTransport:
#
# An enumeration of NFS transport types
#
# @inet:        TCP transport
#
# Since: 2.9
##
{
  "enum": "NFSTransport",
  "data": [
    "inet"
  ]
}

##
# @NFSServer:
#
# Captures the address of the socket
#
# @type:        transport type used for NFS (only TCP supported)
#
# @host:        host address for NFS server
#
# Since: 2.9
##
{
  "struct": "NFSServer",
  "data": {
    "type": "NFSTransport",
    "host": "str"
  }
}

##
# @BlockdevOptionsNfs:
#
# Driver specific block device option for NFS
#
# @server:                  host address
#
# @path:                    path of the image on the host
#
# @user:                    UID value to use when talking to the
#                           server (defaults to 65534 on Windows and getuid()
#                           on unix)
#
# @group:                   GID value to use when talking to the
#                           server (defaults to 65534 on Windows and getgid()
#                           in unix)
#
# @tcp-syn-count:           number of SYNs during the session
#                           establishment (defaults to libnfs default)
#
# @readahead-size:          set the readahead size in bytes (defaults
#                           to libnfs default)
#
# @page-cache-size:         set the pagecache size in bytes (defaults
#                           to libnfs default)
#
# @debug:                   set the NFS debug level (max 2) (defaults
#                           to libnfs default)
#
# Since: 2.9
##
{
  "struct": "BlockdevOptionsNfs",
  "data": {
    "server": "NFSServer",
    "path": "str",
    "*user": "int",
    "*group": "int",
    "*tcp-syn-count": "int",
    "*readahead-size": "int",
    "*page-cache-size": "int",
    "*debug": "int"
  }
}

##
# @BlockdevOptionsCurlBase:
#
# Driver specific block device options shared by all protocols supported by the
# curl backend.
#
# @url:                     URL of the image file
#
# @readahead:               Size of the read-ahead cache; must be a multiple of
#                           512 (defaults to 256 kB)
#
# @timeout:                 Timeout for connections, in seconds (defaults to 5)
#
# @username:                Username for authentication (defaults to none)
#
# @password-secret:         ID of a QCryptoSecret object providing a password
#                           for authentication (defaults to no password)
#
# @proxy-username:          Username for proxy authentication (defaults to none)
#
# @proxy-password-secret:   ID of a QCryptoSecret object providing a password
#                           for proxy authentication (defaults to no password)
#
# Since: 2.9
##
{
  "struct": "BlockdevOptionsCurlBase",
  "data": {
    "url": "str",
    "*readahead": "int",
    "*timeout": "int",
    "*username": "str",
    "*password-secret": "str",
    "*proxy-username": "str",
    "*proxy-password-secret": "str"
  }
}

##
# @BlockdevOptionsCurlHttp:
#
# Driver specific block device options for HTTP connections over the curl
# backend.  URLs must start with "http://".
#
# @cookie:      List of cookies to set; format is
#               "name1=content1; name2=content2;" as explained by
#               CURLOPT_COOKIE(3). Defaults to no cookies.
#
# @cookie-secret: ID of a QCryptoSecret object providing the cookie data in a
#                 secure way. See @cookie for the format. (since 2.10)
#
# Since: 2.9
##
{
  "struct": "BlockdevOptionsCurlHttp",
  "base": "BlockdevOptionsCurlBase",
  "data": {
    "*cookie": "str",
    "*cookie-secret": "str"
  }
}

##
# @BlockdevOptionsCurlHttps:
#
# Driver specific block device options for HTTPS connections over the curl
# backend.  URLs must start with "https://".
#
# @cookie:      List of cookies to set; format is
#               "name1=content1; name2=content2;" as explained by
#               CURLOPT_COOKIE(3). Defaults to no cookies.
#
# @sslverify:   Whether to verify the SSL certificate's validity (defaults to
#               true)
#
# @cookie-secret: ID of a QCryptoSecret object providing the cookie data in a
#                 secure way. See @cookie for the format. (since 2.10)
#
# Since: 2.9
##
{
  "struct": "BlockdevOptionsCurlHttps",
  "base": "BlockdevOptionsCurlBase",
  "data": {
    "*cookie": "str",
    "*sslverify": "bool",
    "*cookie-secret": "str"
  }
}

##
# @BlockdevOptionsCurlFtp:
#
# Driver specific block device options for FTP connections over the curl
# backend.  URLs must start with "ftp://".
#
# Since: 2.9
##
{
  "struct": "BlockdevOptionsCurlFtp",
  "base": "BlockdevOptionsCurlBase",
  "data": {}
}

##
# @BlockdevOptionsCurlFtps:
#
# Driver specific block device options for FTPS connections over the curl
# backend.  URLs must start with "ftps://".
#
# @sslverify:   Whether to verify the SSL certificate's validity (defaults to
#               true)
#
# Since: 2.9
##
{
  "struct": "BlockdevOptionsCurlFtps",
  "base": "BlockdevOptionsCurlBase",
  "data": {
    "*sslverify": "bool"
  }
}

##
# @BlockdevOptionsNbd:
#
# Driver specific block device options for NBD.
#
# @server:      NBD server address
#
# @export:      export name
#
# @tls-creds:   TLS credentials ID
#
# Since: 2.9
##
{
  "struct": "BlockdevOptionsNbd",
  "data": {
    "server": "SocketAddress",
    "*export": "str",
    "*tls-creds": "str"
  }
}

##
# @BlockdevOptionsRaw:
#
# Driver specific block device options for the raw driver.
#
# @offset:      position where the block device starts
# @size:        the assumed size of the device
#
# Since: 2.9
##
{
  "struct": "BlockdevOptionsRaw",
  "base": "BlockdevOptionsGenericFormat",
  "data": {
    "*offset": "int",
    "*size": "int"
  }
}

##
# @BlockdevOptionsVxHS:
#
# Driver specific block device options for VxHS
#
# @vdisk-id:    UUID of VxHS volume
# @server:      vxhs server IP, port
# @tls-creds:   TLS credentials ID
#
# Since: 2.10
##
{
  "struct": "BlockdevOptionsVxHS",
  "data": {
    "vdisk-id": "str",
    "server": "InetSocketAddressBase",
    "*tls-creds": "str"
  }
}

##
# @BlockdevOptionsThrottle:
#
# Driver specific block device options for the throttle driver
#
# @throttle-group:   the name of the throttle-group object to use. It
#                    must already exist.
# @file:             reference to or definition of the data source block device
# Since: 2.11
##
{
  "struct": "BlockdevOptionsThrottle",
  "data": {
    "throttle-group": "str",
    "file": "BlockdevRef"
  }
}

##
# @BlockdevOptions:
#
# Options for creating a block device.  Many options are available for all
# block devices, independent of the block driver:
#
# @driver:        block driver name
# @node-name:     the node name of the new node (Since 2.0).
#                 This option is required on the top level of blockdev-add.
# @discard:       discard-related options (default: ignore)
# @cache:         cache-related options
# @read-only:     whether the block device should be read-only (default: false).
#                 Note that some block drivers support only read-only access,
#                 either generally or in certain configurations. In this case,
#                 the default value does not work and the option must be
#                 specified explicitly.
# @detect-zeroes: detect and optimize zero writes (Since 2.1)
#                 (default: off)
# @force-share:   force share all permission on added nodes.
#                 Requires read-only=true. (Since 2.10)
#
# Remaining options are determined by the block driver.
#
# Since: 2.9
##
{
  "union": "BlockdevOptions",
  "base": {
    "driver": "BlockdevDriver",
    "*node-name": "str",
    "*discard": "BlockdevDiscardOptions",
    "*cache": "BlockdevCacheOptions",
    "*read-only": "bool",
    "*force-share": "bool",
    "*detect-zeroes": "BlockdevDetectZeroesOptions"
  },
  "discriminator": "driver",
  "data": {
    "blkdebug": "BlockdevOptionsBlkdebug",
    "blkverify": "BlockdevOptionsBlkverify",
    "bochs": "BlockdevOptionsGenericFormat",
    "cloop": "BlockdevOptionsGenericFormat",
    "dmg": "BlockdevOptionsGenericFormat",
    "file": "BlockdevOptionsFile",
    "ftp": "BlockdevOptionsCurlFtp",
    "ftps": "BlockdevOptionsCurlFtps",
    "gluster": "BlockdevOptionsGluster",
    "host_cdrom": "BlockdevOptionsFile",
    "host_device": "BlockdevOptionsFile",
    "http": "BlockdevOptionsCurlHttp",
    "https": "BlockdevOptionsCurlHttps",
    "iscsi": "BlockdevOptionsIscsi",
    "luks": "BlockdevOptionsLUKS",
    "nbd": "BlockdevOptionsNbd",
    "nfs": "BlockdevOptionsNfs",
    "null-aio": "BlockdevOptionsNull",
    "null-co": "BlockdevOptionsNull",
    "parallels": "BlockdevOptionsGenericFormat",
    "qcow2": "BlockdevOptionsQcow2",
    "qcow": "BlockdevOptionsQcow",
    "qed": "BlockdevOptionsGenericCOWFormat",
    "quorum": "BlockdevOptionsQuorum",
    "raw": "BlockdevOptionsRaw",
    "rbd": "BlockdevOptionsRbd",
    "replication": "BlockdevOptionsReplication",
    "sheepdog": "BlockdevOptionsSheepdog",
    "ssh": "BlockdevOptionsSsh",
    "throttle": "BlockdevOptionsThrottle",
    "vdi": "BlockdevOptionsGenericFormat",
    "vhdx": "BlockdevOptionsGenericFormat",
    "vmdk": "BlockdevOptionsGenericCOWFormat",
    "vpc": "BlockdevOptionsGenericFormat",
    "vvfat": "BlockdevOptionsVVFAT",
    "vxhs": "BlockdevOptionsVxHS"
  }
}

##
# @BlockdevRef:
#
# Reference to a block device.
#
# @definition:      defines a new block device inline
# @reference:       references the ID of an existing block device
#
# Since: 2.9
##
{
  "alternate": "BlockdevRef",
  "data": {
    "definition": "BlockdevOptions",
    "reference": "str"
  }
}

##
# @BlockdevRefOrNull:
#
# Reference to a block device.
#
# @definition:      defines a new block device inline
# @reference:       references the ID of an existing block device.
#                   An empty string means that no block device should
#                   be referenced.  Deprecated; use null instead.
# @null:            No block device should be referenced (since 2.10)
#
# Since: 2.9
##
{
  "alternate": "BlockdevRefOrNull",
  "data": {
    "definition": "BlockdevOptions",
    "reference": "str",
    "null": "null"
  }
}

##
# @blockdev-add:
#
# Creates a new block device. If the @id option is given at the top level, a
# BlockBackend will be created; otherwise, @node-name is mandatory at the top
# level and no BlockBackend will be created.
#
# Since: 2.9
#
# Example:
#
# 1.
# -> { "execute": "blockdev-add",
#      "arguments": {
#           "driver": "qcow2",
#           "node-name": "test1",
#           "file": {
#               "driver": "file",
#               "filename": "test.qcow2"
#            }
#       }
#     }
# <- { "return": {} }
#
# 2.
# -> { "execute": "blockdev-add",
#      "arguments": {
#           "driver": "qcow2",
#           "node-name": "node0",
#           "discard": "unmap",
#           "cache": {
#              "direct": true
#            },
#            "file": {
#              "driver": "file",
#              "filename": "/tmp/test.qcow2"
#            },
#            "backing": {
#               "driver": "raw",
#               "file": {
#                  "driver": "file",
#                  "filename": "/dev/fdset/4"
#                }
#            }
#        }
#      }
#
# <- { "return": {} }
#
##
{
  "command": "blockdev-add",
  "data": "BlockdevOptions",
  "boxed": true
}

##
# @blockdev-del:
#
# Deletes a block device that has been added using blockdev-add.
# The command will fail if the node is attached to a device or is
# otherwise being used.
#
# @node-name: Name of the graph node to delete.
#
# Since: 2.9
#
# Example:
#
# -> { "execute": "blockdev-add",
#      "arguments": {
#           "driver": "qcow2",
#           "node-name": "node0",
#           "file": {
#               "driver": "file",
#               "filename": "test.qcow2"
#           }
#      }
#    }
# <- { "return": {} }
#
# -> { "execute": "blockdev-del",
#      "arguments": { "node-name": "node0" }
#    }
# <- { "return": {} }
#
##
{
  "command": "blockdev-del",
  "data": {
    "node-name": "str"
  }
}

##
# @blockdev-open-tray:
#
# Opens a block device's tray. If there is a block driver state tree inserted as
# a medium, it will become inaccessible to the guest (but it will remain
# associated to the block device, so closing the tray will make it accessible
# again).
#
# If the tray was already open before, this will be a no-op.
#
# Once the tray opens, a DEVICE_TRAY_MOVED event is emitted. There are cases in
# which no such event will be generated, these include:
# - if the guest has locked the tray, @force is false and the guest does not
#   respond to the eject request
# - if the BlockBackend denoted by @device does not have a guest device attached
#   to it
# - if the guest device does not have an actual tray
#
# @device: Block device name (deprecated, use @id instead)
#
# @id:     The name or QOM path of the guest device (since: 2.8)
#
# @force:  if false (the default), an eject request will be sent to
#          the guest if it has locked the tray (and the tray will not be opened
#          immediately); if true, the tray will be opened regardless of whether
#          it is locked
#
# Since: 2.5
#
# Example:
#
# -> { "execute": "blockdev-open-tray",
#      "arguments": { "id": "ide0-1-0" } }
#
# <- { "timestamp": { "seconds": 1418751016,
#                     "microseconds": 716996 },
#      "event": "DEVICE_TRAY_MOVED",
#      "data": { "device": "ide1-cd0",
#                "id": "ide0-1-0",
#                "tray-open": true } }
#
# <- { "return": {} }
#
##
{
  "command": "blockdev-open-tray",
  "data": {
    "*device": "str",
    "*id": "str",
    "*force": "bool"
  }
}

##
# @blockdev-close-tray:
#
# Closes a block device's tray. If there is a block driver state tree associated
# with the block device (which is currently ejected), that tree will be loaded
# as the medium.
#
# If the tray was already closed before, this will be a no-op.
#
# @device:  Block device name (deprecated, use @id instead)
#
# @id:      The name or QOM path of the guest device (since: 2.8)
#
# Since: 2.5
#
# Example:
#
# -> { "execute": "blockdev-close-tray",
#      "arguments": { "id": "ide0-1-0" } }
#
# <- { "timestamp": { "seconds": 1418751345,
#                     "microseconds": 272147 },
#      "event": "DEVICE_TRAY_MOVED",
#      "data": { "device": "ide1-cd0",
#                "id": "ide0-1-0",
#                "tray-open": false } }
#
# <- { "return": {} }
#
##
{
  "command": "blockdev-close-tray",
  "data": {
    "*device": "str",
    "*id": "str"
  }
}

##
# @x-blockdev-remove-medium:
#
# Removes a medium (a block driver state tree) from a block device. That block
# device's tray must currently be open (unless there is no attached guest
# device).
#
# If the tray is open and there is no medium inserted, this will be a no-op.
#
# @device: Block device name (deprecated, use @id instead)
#
# @id:     The name or QOM path of the guest device (since: 2.8)
#
# Note: This command is still a work in progress and is considered experimental.
# Stay away from it unless you want to help with its development.
#
# Since: 2.5
#
# Example:
#
# -> { "execute": "x-blockdev-remove-medium",
#      "arguments": { "id": "ide0-1-0" } }
#
# <- { "error": { "class": "GenericError",
#                 "desc": "Tray of device 'ide0-1-0' is not open" } }
#
# -> { "execute": "blockdev-open-tray",
#      "arguments": { "id": "ide0-1-0" } }
#
# <- { "timestamp": { "seconds": 1418751627,
#                     "microseconds": 549958 },
#      "event": "DEVICE_TRAY_MOVED",
#      "data": { "device": "ide1-cd0",
#                "id": "ide0-1-0",
#                "tray-open": true } }
#
# <- { "return": {} }
#
# -> { "execute": "x-blockdev-remove-medium",
#      "arguments": { "id": "ide0-1-0" } }
#
# <- { "return": {} }
#
##
{
  "command": "x-blockdev-remove-medium",
  "data": {
    "*device": "str",
    "*id": "str"
  }
}

##
# @x-blockdev-insert-medium:
#
# Inserts a medium (a block driver state tree) into a block device. That block
# device's tray must currently be open (unless there is no attached guest
# device) and there must be no medium inserted already.
#
# @device:    Block device name (deprecated, use @id instead)
#
# @id:        The name or QOM path of the guest device (since: 2.8)
#
# @node-name: name of a node in the block driver state graph
#
# Note: This command is still a work in progress and is considered experimental.
# Stay away from it unless you want to help with its development.
#
# Since: 2.5
#
# Example:
#
# -> { "execute": "blockdev-add",
#      "arguments": {
#          "node-name": "node0",
#          "driver": "raw",
#          "file": { "driver": "file",
#                    "filename": "fedora.iso" } } }
# <- { "return": {} }
#
# -> { "execute": "x-blockdev-insert-medium",
#      "arguments": { "id": "ide0-1-0",
#                     "node-name": "node0" } }
#
# <- { "return": {} }
#
##
{
  "command": "x-blockdev-insert-medium",
  "data": {
    "*device": "str",
    "*id": "str",
    "node-name": "str"
  }
}


##
# @BlockdevChangeReadOnlyMode:
#
# Specifies the new read-only mode of a block device subject to the
# @blockdev-change-medium command.
#
# @retain:      Retains the current read-only mode
#
# @read-only:   Makes the device read-only
#
# @read-write:  Makes the device writable
#
# Since: 2.3
#
##
{
  "enum": "BlockdevChangeReadOnlyMode",
  "data": [
    "retain",
    "read-only",
    "read-write"
  ]
}


##
# @blockdev-change-medium:
#
# Changes the medium inserted into a block device by ejecting the current medium
# and loading a new image file which is inserted as the new medium (this command
# combines blockdev-open-tray, x-blockdev-remove-medium,
# x-blockdev-insert-medium and blockdev-close-tray).
#
# @device:          Block device name (deprecated, use @id instead)
#
# @id:              The name or QOM path of the guest device
#                   (since: 2.8)
#
# @filename:        filename of the new image to be loaded
#
# @format:          format to open the new image with (defaults to
#                   the probed format)
#
# @read-only-mode:  change the read-only mode of the device; defaults
#                   to 'retain'
#
# Since: 2.5
#
# Examples:
#
# 1. Change a removable medium
#
# -> { "execute": "blockdev-change-medium",
#      "arguments": { "id": "ide0-1-0",
#                     "filename": "/srv/images/Fedora-12-x86_64-DVD.iso",
#                     "format": "raw" } }
# <- { "return": {} }
#
# 2. Load a read-only medium into a writable drive
#
# -> { "execute": "blockdev-change-medium",
#      "arguments": { "id": "floppyA",
#                     "filename": "/srv/images/ro.img",
#                     "format": "raw",
#                     "read-only-mode": "retain" } }
#
# <- { "error":
#      { "class": "GenericError",
#        "desc": "Could not open '/srv/images/ro.img': Permission denied" } }
#
# -> { "execute": "blockdev-change-medium",
#      "arguments": { "id": "floppyA",
#                     "filename": "/srv/images/ro.img",
#                     "format": "raw",
#                     "read-only-mode": "read-only" } }
#
# <- { "return": {} }
#
##
{
  "command": "blockdev-change-medium",
  "data": {
    "*device": "str",
    "*id": "str",
    "filename": "str",
    "*format": "str",
    "*read-only-mode": "BlockdevChangeReadOnlyMode"
  }
}


##
# @BlockErrorAction:
#
# An enumeration of action that has been taken when a DISK I/O occurs
#
# @ignore: error has been ignored
#
# @report: error has been reported to the device
#
# @stop: error caused VM to be stopped
#
# Since: 2.1
##
{
  "enum": "BlockErrorAction",
  "data": [
    "ignore",
    "report",
    "stop"
  ]
}


##
# @BLOCK_IMAGE_CORRUPTED:
#
# Emitted when a disk image is being marked corrupt. The image can be
# identified by its device or node name. The 'device' field is always
# present for compatibility reasons, but it can be empty ("") if the
# image does not have a device name associated.
#
# @device: device name. This is always present for compatibility
#          reasons, but it can be empty ("") if the image does not
#          have a device name associated.
#
# @node-name: node name (Since: 2.4)
#
# @msg: informative message for human consumption, such as the kind of
#       corruption being detected. It should not be parsed by machine as it is
#       not guaranteed to be stable
#
# @offset: if the corruption resulted from an image access, this is
#          the host's access offset into the image
#
# @size: if the corruption resulted from an image access, this is
#        the access size
#
# @fatal: if set, the image is marked corrupt and therefore unusable after this
#        event and must be repaired (Since 2.2; before, every
#        BLOCK_IMAGE_CORRUPTED event was fatal)
#
# Note: If action is "stop", a STOP event will eventually follow the
#       BLOCK_IO_ERROR event.
#
# Example:
#
# <- { "event": "BLOCK_IMAGE_CORRUPTED",
#      "data": { "device": "ide0-hd0", "node-name": "node0",
#                "msg": "Prevented active L1 table overwrite", "offset": 196608,
#                "size": 65536 },
#      "timestamp": { "seconds": 1378126126, "microseconds": 966463 } }
#
# Since: 1.7
##
{
  "event": "BLOCK_IMAGE_CORRUPTED",
  "data": {
    "device": "str",
    "*node-name": "str",
    "msg": "str",
    "*offset": "int",
    "*size": "int",
    "fatal": "bool"
  }
}

##
# @BLOCK_IO_ERROR:
#
# Emitted when a disk I/O error occurs
#
# @device: device name. This is always present for compatibility
#          reasons, but it can be empty ("") if the image does not
#          have a device name associated.
#
# @node-name: node name. Note that errors may be reported for the root node
#             that is directly attached to a guest device rather than for the
#             node where the error occurred. (Since: 2.8)
#
# @operation: I/O operation
#
# @action: action that has been taken
#
# @nospace: true if I/O error was caused due to a no-space
#           condition. This key is only present if query-block's
#           io-status is present, please see query-block documentation
#           for more information (since: 2.2)
#
# @reason: human readable string describing the error cause.
#          (This field is a debugging aid for humans, it should not
#           be parsed by applications) (since: 2.2)
#
# Note: If action is "stop", a STOP event will eventually follow the
# BLOCK_IO_ERROR event
#
# Since: 0.13.0
#
# Example:
#
# <- { "event": "BLOCK_IO_ERROR",
#      "data": { "device": "ide0-hd1",
#                "node-name": "#block212",
#                "operation": "write",
#                "action": "stop" },
#      "timestamp": { "seconds": 1265044230, "microseconds": 450486 } }
#
##
{
  "event": "BLOCK_IO_ERROR",
  "data": {
    "device": "str",
    "node-name": "str",
    "operation": "IoOperationType",
    "action": "BlockErrorAction",
    "*nospace": "bool",
    "reason": "str"
  }
}

##
# @BLOCK_JOB_COMPLETED:
#
# Emitted when a block job has completed
#
# @type: job type
#
# @device: The job identifier. Originally the device name but other
#          values are allowed since QEMU 2.7
#
# @len: maximum progress value
#
# @offset: current progress value. On success this is equal to len.
#          On failure this is less than len
#
# @speed: rate limit, bytes per second
#
# @error: error message. Only present on failure. This field
#         contains a human-readable error message. There are no semantics
#         other than that streaming has failed and clients should not try to
#         interpret the error string
#
# Since: 1.1
#
# Example:
#
# <- { "event": "BLOCK_JOB_COMPLETED",
#      "data": { "type": "stream", "device": "virtio-disk0",
#                "len": 10737418240, "offset": 10737418240,
#                "speed": 0 },
#      "timestamp": { "seconds": 1267061043, "microseconds": 959568 } }
#
##
{
  "event": "BLOCK_JOB_COMPLETED",
  "data": {
    "type": "BlockJobType",
    "device": "str",
    "len": "int",
    "offset": "int",
    "speed": "int",
    "*error": "str"
  }
}

##
# @BLOCK_JOB_CANCELLED:
#
# Emitted when a block job has been cancelled
#
# @type: job type
#
# @device: The job identifier. Originally the device name but other
#          values are allowed since QEMU 2.7
#
# @len: maximum progress value
#
# @offset: current progress value. On success this is equal to len.
#          On failure this is less than len
#
# @speed: rate limit, bytes per second
#
# Since: 1.1
#
# Example:
#
# <- { "event": "BLOCK_JOB_CANCELLED",
#      "data": { "type": "stream", "device": "virtio-disk0",
#                "len": 10737418240, "offset": 134217728,
#                "speed": 0 },
#      "timestamp": { "seconds": 1267061043, "microseconds": 959568 } }
#
##
{
  "event": "BLOCK_JOB_CANCELLED",
  "data": {
    "type": "BlockJobType",
    "device": "str",
    "len": "int",
    "offset": "int",
    "speed": "int"
  }
}

##
# @BLOCK_JOB_ERROR:
#
# Emitted when a block job encounters an error
#
# @device: The job identifier. Originally the device name but other
#          values are allowed since QEMU 2.7
#
# @operation: I/O operation
#
# @action: action that has been taken
#
# Since: 1.3
#
# Example:
#
# <- { "event": "BLOCK_JOB_ERROR",
#      "data": { "device": "ide0-hd1",
#                "operation": "write",
#                "action": "stop" },
#      "timestamp": { "seconds": 1265044230, "microseconds": 450486 } }
#
##
{
  "event": "BLOCK_JOB_ERROR",
  "data": {
    "device": "str",
    "operation": "IoOperationType",
    "action": "BlockErrorAction"
  }
}

##
# @BLOCK_JOB_READY:
#
# Emitted when a block job is ready to complete
#
# @type: job type
#
# @device: The job identifier. Originally the device name but other
#          values are allowed since QEMU 2.7
#
# @len: maximum progress value
#
# @offset: current progress value. On success this is equal to len.
#          On failure this is less than len
#
# @speed: rate limit, bytes per second
#
# Note: The "ready to complete" status is always reset by a @BLOCK_JOB_ERROR
# event
#
# Since: 1.3
#
# Example:
#
# <- { "event": "BLOCK_JOB_READY",
#      "data": { "device": "drive0", "type": "mirror", "speed": 0,
#                "len": 2097152, "offset": 2097152 }
#      "timestamp": { "seconds": 1265044230, "microseconds": 450486 } }
#
##
{
  "event": "BLOCK_JOB_READY",
  "data": {
    "type": "BlockJobType",
    "device": "str",
    "len": "int",
    "offset": "int",
    "speed": "int"
  }
}

##
# @PreallocMode:
#
# Preallocation mode of QEMU image file
#
# @off: no preallocation
# @metadata: preallocate only for metadata
# @falloc: like @full preallocation but allocate disk space by
#          posix_fallocate() rather than writing zeros.
# @full: preallocate all data by writing zeros to device to ensure disk
#        space is really available. @full preallocation also sets up
#        metadata correctly.
#
# Since: 2.2
##
{
  "enum": "PreallocMode",
  "data": [
    "off",
    "metadata",
    "falloc",
    "full"
  ]
}

##
# @BLOCK_WRITE_THRESHOLD:
#
# Emitted when writes on block device reaches or exceeds the
# configured write threshold. For thin-provisioned devices, this
# means the device should be extended to avoid pausing for
# disk exhaustion.
# The event is one shot. Once triggered, it needs to be
# re-registered with another block-set-write-threshold command.
#
# @node-name: graph node name on which the threshold was exceeded.
#
# @amount-exceeded: amount of data which exceeded the threshold, in bytes.
#
# @write-threshold: last configured threshold, in bytes.
#
# Since: 2.3
##
{
  "event": "BLOCK_WRITE_THRESHOLD",
  "data": {
    "node-name": "str",
    "amount-exceeded": "uint64",
    "write-threshold": "uint64"
  }
}

##
# @block-set-write-threshold:
#
# Change the write threshold for a block drive. An event will be
# delivered if a write to this block drive crosses the configured
# threshold.  The threshold is an offset, thus must be
# non-negative. Default is no write threshold. Setting the threshold
# to zero disables it.
#
# This is useful to transparently resize thin-provisioned drives without
# the guest OS noticing.
#
# @node-name: graph node name on which the threshold must be set.
#
# @write-threshold: configured threshold for the block device, bytes.
#                   Use 0 to disable the threshold.
#
# Since: 2.3
#
# Example:
#
# -> { "execute": "block-set-write-threshold",
#      "arguments": { "node-name": "mydev",
#                     "write-threshold": 17179869184 } }
# <- { "return": {} }
#
##
{
  "command": "block-set-write-threshold",
  "data": {
    "node-name": "str",
    "write-threshold": "uint64"
  }
}

##
# @x-blockdev-change:
#
# Dynamically reconfigure the block driver state graph. It can be used
# to add, remove, insert or replace a graph node. Currently only the
# Quorum driver implements this feature to add or remove its child. This
# is useful to fix a broken quorum child.
#
# If @node is specified, it will be inserted under @parent. @child
# may not be specified in this case. If both @parent and @child are
# specified but @node is not, @child will be detached from @parent.
#
# @parent: the id or name of the parent node.
#
# @child: the name of a child under the given parent node.
#
# @node: the name of the node that will be added.
#
# Note: this command is experimental, and its API is not stable. It
# does not support all kinds of operations, all kinds of children, nor
# all block drivers.
#
# Warning: The data in a new quorum child MUST be consistent with that of
# the rest of the array.
#
# Since: 2.7
#
# Example:
#
# 1. Add a new node to a quorum
# -> { "execute": "blockdev-add",
#      "arguments": {
#          "driver": "raw",
#          "node-name": "new_node",
#          "file": { "driver": "file",
#                    "filename": "test.raw" } } }
# <- { "return": {} }
# -> { "execute": "x-blockdev-change",
#      "arguments": { "parent": "disk1",
#                     "node": "new_node" } }
# <- { "return": {} }
#
# 2. Delete a quorum's node
# -> { "execute": "x-blockdev-change",
#      "arguments": { "parent": "disk1",
#                     "child": "children.1" } }
# <- { "return": {} }
#
##
{
  "command": "x-blockdev-change",
  "data": {
    "parent": "str",
    "*child": "str",
    "*node": "str"
  }
}


##
# @BiosAtaTranslation:
#
# Policy that BIOS should use to interpret cylinder/head/sector
# addresses.  Note that Bochs BIOS and SeaBIOS will not actually
# translate logical CHS to physical; instead, they will use logical
# block addressing.
#
# @auto: If cylinder/heads/sizes are passed, choose between none and LBA
#        depending on the size of the disk.  If they are not passed,
#        choose none if QEMU can guess that the disk had 16 or fewer
#        heads, large if QEMU can guess that the disk had 131072 or
#        fewer tracks across all heads (i.e. cylinders*heads<131072),
#        otherwise LBA.
#
# @none: The physical disk geometry is equal to the logical geometry.
#
# @lba: Assume 63 sectors per track and one of 16, 32, 64, 128 or 255
#       heads (if fewer than 255 are enough to cover the whole disk
#       with 1024 cylinders/head).  The number of cylinders/head is
#       then computed based on the number of sectors and heads.
#
# @large: The number of cylinders per head is scaled down to 1024
#         by correspondingly scaling up the number of heads.
#
# @rechs: Same as @large, but first convert a 16-head geometry to
#         15-head, by proportionally scaling up the number of
#         cylinders/head.
#
# Since: 2.0
##
{
  "enum": "BiosAtaTranslation",
  "data": [
    "auto",
    "none",
    "lba",
    "large",
    "rechs"
  ]
}

##
# @FloppyDriveType:
#
# Type of Floppy drive to be emulated by the Floppy Disk Controller.
#
# @144:  1.44MB 3.5" drive
# @288:  2.88MB 3.5" drive
# @120:  1.2MB 5.25" drive
# @none: No drive connected
# @auto: Automatically determined by inserted media at boot
#
# Since: 2.6
##
{
  "enum": "FloppyDriveType",
  "data": [
    "144",
    "288",
    "120",
    "none",
    "auto"
  ]
}

##
# @BlockdevSnapshotInternal:
#
# @device: the device name or node-name of a root node to generate the snapshot
#          from
#
# @name: the name of the internal snapshot to be created
#
# Notes: In transaction, if @name is empty, or any snapshot matching @name
#        exists, the operation will fail. Only some image formats support it,
#        for example, qcow2, rbd, and sheepdog.
#
# Since: 1.7
##
{
  "struct": "BlockdevSnapshotInternal",
  "data": {
    "device": "str",
    "name": "str"
  }
}

##
# @blockdev-snapshot-internal-sync:
#
# Synchronously take an internal snapshot of a block device, when the
# format of the image used supports it. If the name is an empty
# string, or a snapshot with name already exists, the operation will
# fail.
#
# For the arguments, see the documentation of BlockdevSnapshotInternal.
#
# Returns: nothing on success
#
#          If @device is not a valid block device, GenericError
#
#          If any snapshot matching @name exists, or @name is empty,
#          GenericError
#
#          If the format of the image used does not support it,
#          BlockFormatFeatureNotSupported
#
# Since: 1.7
#
# Example:
#
# -> { "execute": "blockdev-snapshot-internal-sync",
#      "arguments": { "device": "ide-hd0",
#                     "name": "snapshot0" }
#    }
# <- { "return": {} }
#
##
{
  "command": "blockdev-snapshot-internal-sync",
  "data": "BlockdevSnapshotInternal"
}

##
# @blockdev-snapshot-delete-internal-sync:
#
# Synchronously delete an internal snapshot of a block device, when the format
# of the image used support it. The snapshot is identified by name or id or
# both. One of the name or id is required. Return SnapshotInfo for the
# successfully deleted snapshot.
#
# @device: the device name or node-name of a root node to delete the snapshot
#          from
#
# @id: optional the snapshot's ID to be deleted
#
# @name: optional the snapshot's name to be deleted
#
# Returns: SnapshotInfo on success
#          If @device is not a valid block device, GenericError
#          If snapshot not found, GenericError
#          If the format of the image used does not support it,
#          BlockFormatFeatureNotSupported
#          If @id and @name are both not specified, GenericError
#
# Since: 1.7
#
# Example:
#
# -> { "execute": "blockdev-snapshot-delete-internal-sync",
#      "arguments": { "device": "ide-hd0",
#                     "name": "snapshot0" }
#    }
# <- { "return": {
#                    "id": "1",
#                    "name": "snapshot0",
#                    "vm-state-size": 0,
#                    "date-sec": 1000012,
#                    "date-nsec": 10,
#                    "vm-clock-sec": 100,
#                    "vm-clock-nsec": 20
#      }
#    }
#
##
{
  "command": "blockdev-snapshot-delete-internal-sync",
  "data": {
    "device": "str",
    "*id": "str",
    "*name": "str"
  },
  "returns": "SnapshotInfo"
}

##
{
  "command": "eject",
  "data": {
    "*device": "str",
    "*id": "str",
    "*force": "bool"
  }
}

##
# @nbd-server-start:
#
# Start an NBD server listening on the given host and port.  Block
# devices can then be exported using @nbd-server-add.  The NBD
# server will present them as named exports; for example, another
# QEMU instance could refer to them as "nbd:HOST:PORT:exportname=NAME".
#
# @addr: Address on which to listen.
# @tls-creds: (optional) ID of the TLS credentials object. Since 2.6
#
# Returns: error if the server is already running.
#
# Since: 1.3.0
##
{
  "command": "nbd-server-start",
  "data": {
    "addr": "SocketAddressLegacy",
    "*tls-creds": "str"
  }
}

##
# @nbd-server-add:
#
# Export a block node to QEMU's embedded NBD server.
#
# @device: The device name or node name of the node to be exported
#
# @writable: Whether clients should be able to write to the device via the
#     NBD connection (default false).
#
# Returns: error if the device is already marked for export.
#
# Since: 1.3.0
##
{
  "command": "nbd-server-add",
  "data": {
    "device": "str",
    "*writable": "bool"
  }
}

##
# @nbd-server-stop:
#
# Stop QEMU's embedded NBD server, and unregister all devices previously
# added via @nbd-server-add.
#
# Since: 1.3.0
##
{
  "command": "nbd-server-stop"
}

##
# @DEVICE_TRAY_MOVED:
#
# Emitted whenever the tray of a removable device is moved by the guest or by
# HMP/QMP commands
#
# @device: Block device name. This is always present for compatibility
#          reasons, but it can be empty ("") if the image does not
#          have a device name associated.
#
# @id: The name or QOM path of the guest device (since 2.8)
#
# @tray-open: true if the tray has been opened or false if it has been closed
#
# Since: 1.1
#
# Example:
#
# <- { "event": "DEVICE_TRAY_MOVED",
#      "data": { "device": "ide1-cd0",
#                "id": "/machine/unattached/device[22]",
#                "tray-open": true
#      },
#      "timestamp": { "seconds": 1265044230, "microseconds": 450486 } }
#
##
{
  "event": "DEVICE_TRAY_MOVED",
  "data": {
    "device": "str",
    "id": "str",
    "tray-open": "bool"
  }
}

##
# @QuorumOpType:
#
# An enumeration of the quorum operation types
#
# @read: read operation
#
# @write: write operation
#
# @flush: flush operation
#
# Since: 2.6
##
{
  "enum": "QuorumOpType",
  "data": [
    "read",
    "write",
    "flush"
  ]
}

##
# @QUORUM_FAILURE:
#
# Emitted by the Quorum block driver if it fails to establish a quorum
#
# @reference: device name if defined else node name
#
# @sector-num: number of the first sector of the failed read operation
#
# @sectors-count: failed read operation sector count
#
# Note: This event is rate-limited.
#
# Since: 2.0
#
# Example:
#
# <- { "event": "QUORUM_FAILURE",
#      "data": { "reference": "usr1", "sector-num": 345435, "sectors-count": 5 },
#      "timestamp": { "seconds": 1344522075, "microseconds": 745528 } }
#
##
{
  "event": "QUORUM_FAILURE",
  "data": {
    "reference": "str",
    "sector-num": "int",
    "sectors-count": "int"
  }
}

##
# @QUORUM_REPORT_BAD:
#
# Emitted to report a corruption of a Quorum file
#
# @type: quorum operation type (Since 2.6)
#
# @error: error message. Only present on failure. This field
#         contains a human-readable error message. There are no semantics other
#         than that the block layer reported an error and clients should not
#         try to interpret the error string.
#
# @node-name: the graph node name of the block driver state
#
# @sector-num: number of the first sector of the failed read operation
#
# @sectors-count: failed read operation sector count
#
# Note: This event is rate-limited.
#
# Since: 2.0
#
# Example:
#
# 1. Read operation
#
# { "event": "QUORUM_REPORT_BAD",
#      "data": { "node-name": "node0", "sector-num": 345435, "sectors-count": 5,
#                "type": "read" },
#      "timestamp": { "seconds": 1344522075, "microseconds": 745528 } }
#
# 2. Flush operation
#
# { "event": "QUORUM_REPORT_BAD",
#      "data": { "node-name": "node0", "sector-num": 0, "sectors-count": 2097120,
#                "type": "flush", "error": "Broken pipe" },
#      "timestamp": { "seconds": 1456406829, "microseconds": 291763 } }
#
##
{
  "event": "QUORUM_REPORT_BAD",
  "data": {
    "type": "QuorumOpType",
    "*error": "str",
    "node-name": "str",
    "sector-num": "int",
    "sectors-count": "int"
  }
}


##
# @Abort:
#
# This action can be used to test transaction failure.
#
# Since: 1.6
##
{
  "struct": "Abort",
  "data": {}
}

##
# @ActionCompletionMode:
#
# An enumeration of Transactional completion modes.
#
# @individual: Do not attempt to cancel any other Actions if any Actions fail
#              after the Transaction request succeeds. All Actions that
#              can complete successfully will do so without waiting on others.
#              This is the default.
#
# @grouped: If any Action fails after the Transaction succeeds, cancel all
#           Actions. Actions do not complete until all Actions are ready to
#           complete. May be rejected by Actions that do not support this
#           completion mode.
#
# Since: 2.5
##
{
  "enum": "ActionCompletionMode",
  "data": [
    "individual",
    "grouped"
  ]
}

##
# @TransactionAction:
#
# A discriminated record of operations that can be performed with
# @transaction. Action @type can be:
#
# - @abort: since 1.6
# - @block-dirty-bitmap-add: since 2.5
# - @block-dirty-bitmap-clear: since 2.5
# - @blockdev-backup: since 2.3
# - @blockdev-snapshot: since 2.5
# - @blockdev-snapshot-internal-sync: since 1.7
# - @blockdev-snapshot-sync: since 1.1
# - @drive-backup: since 1.6
#
# Since: 1.1
##
{
  "union": "TransactionAction",
  "data": {
    "abort": "Abort",
    "block-dirty-bitmap-add": "BlockDirtyBitmapAdd",
    "block-dirty-bitmap-clear": "BlockDirtyBitmap",
    "blockdev-backup": "BlockdevBackup",
    "blockdev-snapshot": "BlockdevSnapshot",
    "blockdev-snapshot-internal-sync": "BlockdevSnapshotInternal",
    "blockdev-snapshot-sync": "BlockdevSnapshotSync",
    "drive-backup": "DriveBackup"
  }
}

##
# @TransactionProperties:
#
# Optional arguments to modify the behavior of a Transaction.
#
# @completion-mode: Controls how jobs launched asynchronously by
#                   Actions will complete or fail as a group.
#                   See @ActionCompletionMode for details.
#
# Since: 2.5
##
{
  "struct": "TransactionProperties",
  "data": {
    "*completion-mode": "ActionCompletionMode"
  }
}

##
# @transaction:
#
# Executes a number of transactionable QMP commands atomically. If any
# operation fails, then the entire set of actions will be abandoned and the
# appropriate error returned.
#
# For external snapshots, the dictionary contains the device, the file to use for
# the new snapshot, and the format.  The default format, if not specified, is
# qcow2.
#
# Each new snapshot defaults to being created by QEMU (wiping any
# contents if the file already exists), but it is also possible to reuse
# an externally-created file.  In the latter case, you should ensure that
# the new image file has the same contents as the current one; QEMU cannot
# perform any meaningful check.  Typically this is achieved by using the
# current image file as the backing file for the new image.
#
# On failure, the original disks pre-snapshot attempt will be used.
#
# For internal snapshots, the dictionary contains the device and the snapshot's
# name.  If an internal snapshot matching name already exists, the request will
# be rejected.  Only some image formats support it, for example, qcow2, rbd,
# and sheepdog.
#
# On failure, qemu will try delete the newly created internal snapshot in the
# transaction.  When an I/O error occurs during deletion, the user needs to fix
# it later with qemu-img or other command.
#
# @actions: List of @TransactionAction;
#           information needed for the respective operations.
#
# @properties: structure of additional options to control the
#              execution of the transaction. See @TransactionProperties
#              for additional detail.
#
# Returns: nothing on success
#
#          Errors depend on the operations of the transaction
#
# Note: The transaction aborts on the first failure.  Therefore, there will be
# information on only one failed operation returned in an error condition, and
# subsequent actions will not have been attempted.
#
# Since: 1.1
#
# Example:
#
# -> { "execute": "transaction",
#      "arguments": { "actions": [
#          { "type": "blockdev-snapshot-sync", "data" : { "device": "ide-hd0",
#                                      "snapshot-file": "/some/place/my-image",
#                                      "format": "qcow2" } },
#          { "type": "blockdev-snapshot-sync", "data" : { "node-name": "myfile",
#                                      "snapshot-file": "/some/place/my-image2",
#                                      "snapshot-node-name": "node3432",
#                                      "mode": "existing",
#                                      "format": "qcow2" } },
#          { "type": "blockdev-snapshot-sync", "data" : { "device": "ide-hd1",
#                                      "snapshot-file": "/some/place/my-image2",
#                                      "mode": "existing",
#                                      "format": "qcow2" } },
#          { "type": "blockdev-snapshot-internal-sync", "data" : {
#                                      "device": "ide-hd2",
#                                      "name": "snapshot0" } } ] } }
# <- { "return": {} }
#
##
{
  "command": "transaction",
  "data": {
    "actions": [
      "TransactionAction"
    ],
    "*properties": "TransactionProperties"
  }
}


##
# @TraceEventState:
#
# State of a tracing event.
#
# @unavailable: The event is statically disabled.
#
# @disabled: The event is dynamically disabled.
#
# @enabled: The event is dynamically enabled.
#
# Since: 2.2
##
{
  "enum": "TraceEventState",
  "data": [
    "unavailable",
    "disabled",
    "enabled"
  ]
}

##
# @TraceEventInfo:
#
# Information of a tracing event.
#
# @name: Event name.
# @state: Tracing state.
# @vcpu: Whether this is a per-vCPU event (since 2.7).
#
# An event is per-vCPU if it has the "vcpu" property in the "trace-events"
# files.
#
# Since: 2.2
##
{
  "struct": "TraceEventInfo",
  "data": {
    "name": "str",
    "state": "TraceEventState",
    "vcpu": "bool"
  }
}

##
# @trace-event-get-state:
#
# Query the state of events.
#
# @name: Event name pattern (case-sensitive glob).
# @vcpu: The vCPU to query (any by default; since 2.7).
#
# Returns: a list of @TraceEventInfo for the matching events
#
# An event is returned if:
# - its name matches the @name pattern, and
# - if @vcpu is given, the event has the "vcpu" property.
#
# Therefore, if @vcpu is given, the operation will only match per-vCPU events,
# returning their state on the specified vCPU. Special case: if @name is an
# exact match, @vcpu is given and the event does not have the "vcpu" property,
# an error is returned.
#
# Since: 2.2
#
# Example:
#
# -> { "execute": "trace-event-get-state",
#      "arguments": { "name": "qemu_memalign" } }
# <- { "return": [ { "name": "qemu_memalign", "state": "disabled" } ] }
#
##
{
  "command": "trace-event-get-state",
  "data": {
    "name": "str",
    "*vcpu": "int"
  },
  "returns": [
    "TraceEventInfo"
  ]
}

##
# @trace-event-set-state:
#
# Set the dynamic tracing state of events.
#
# @name: Event name pattern (case-sensitive glob).
# @enable: Whether to enable tracing.
# @ignore-unavailable: Do not match unavailable events with @name.
# @vcpu: The vCPU to act upon (all by default; since 2.7).
#
# An event's state is modified if:
# - its name matches the @name pattern, and
# - if @vcpu is given, the event has the "vcpu" property.
#
# Therefore, if @vcpu is given, the operation will only match per-vCPU events,
# setting their state on the specified vCPU. Special case: if @name is an exact
# match, @vcpu is given and the event does not have the "vcpu" property, an
# error is returned.
#
# Since: 2.2
#
# Example:
#
# -> { "execute": "trace-event-set-state",
#      "arguments": { "name": "qemu_memalign", "enable": "true" } }
# <- { "return": {} }
#
##
{
  "command": "trace-event-set-state",
  "data": {
    "name": "str",
    "enable": "bool",
    "*ignore-unavailable": "bool",
    "*vcpu": "int"
  }
}


##
# @query-qmp-schema:
#
# Command query-qmp-schema exposes the QMP wire ABI as an array of
# SchemaInfo.  This lets QMP clients figure out what commands and
# events are available in this QEMU, and their parameters and results.
#
# However, the SchemaInfo can't reflect all the rules and restrictions
# that apply to QMP.  It's interface introspection (figuring out
# what's there), not interface specification.  The specification is in
# the QAPI schema.
#
# Furthermore, while we strive to keep the QMP wire format
# backwards-compatible across qemu versions, the introspection output
# is not guaranteed to have the same stability.  For example, one
# version of qemu may list an object member as an optional
# non-variant, while another lists the same member only through the
# object's variants; or the type of a member may change from a generic
# string into a specific enum or from one specific type into an
# alternate that includes the original type alongside something else.
#
# Returns: array of @SchemaInfo, where each element describes an
# entity in the ABI: command, event, type, ...
#
# The order of the various SchemaInfo is unspecified; however, all
# names are guaranteed to be unique (no name will be duplicated with
# different meta-types).
#
# Note: the QAPI schema is also used to help define *internal*
# interfaces, by defining QAPI types.  These are not part of the QMP
# wire ABI, and therefore not returned by this command.
#
# Since: 2.5
##
{
  "command": "query-qmp-schema",
  "returns": [
    "SchemaInfo"
  ],
  "gen": false
}                

##
# @SchemaMetaType:
#
# This is a @SchemaInfo's meta type, i.e. the kind of entity it
# describes.
#
# @builtin: a predefined type such as 'int' or 'bool'.
#
# @enum: an enumeration type
#
# @array: an array type
#
# @object: an object type (struct or union)
#
# @alternate: an alternate type
#
# @command: a QMP command
#
# @event: a QMP event
#
# Since: 2.5
##
{
  "enum": "SchemaMetaType",
  "data": [
    "builtin",
    "enum",
    "array",
    "object",
    "alternate",
    "command",
    "event"
  ]
}

##
# @SchemaInfo:
#
# @name: the entity's name, inherited from @base.
#        The SchemaInfo is always referenced by this name.
#        Commands and events have the name defined in the QAPI schema.
#        Unlike command and event names, type names are not part of
#        the wire ABI.  Consequently, type names are meaningless
#        strings here, although they are still guaranteed unique
#        regardless of @meta-type.
#
# @meta-type: the entity's meta type, inherited from @base.
#
# Additional members depend on the value of @meta-type.
#
# Since: 2.5
##
{
  "union": "SchemaInfo",
  "base": {
    "name": "str",
    "meta-type": "SchemaMetaType"
  },
  "discriminator": "meta-type",
  "data": {
    "builtin": "SchemaInfoBuiltin",
    "enum": "SchemaInfoEnum",
    "array": "SchemaInfoArray",
    "object": "SchemaInfoObject",
    "alternate": "SchemaInfoAlternate",
    "command": "SchemaInfoCommand",
    "event": "SchemaInfoEvent"
  }
}

##
# @SchemaInfoBuiltin:
#
# Additional SchemaInfo members for meta-type 'builtin'.
#
# @json-type: the JSON type used for this type on the wire.
#
# Since: 2.5
##
{
  "struct": "SchemaInfoBuiltin",
  "data": {
    "json-type": "JSONType"
  }
}

##
# @JSONType:
#
# The four primitive and two structured types according to RFC 7159
# section 1, plus 'int' (split off 'number'), plus the obvious top
# type 'value'.
#
# Since: 2.5
##
{
  "enum": "JSONType",
  "data": [
    "string",
    "number",
    "int",
    "boolean",
    "null",
    "object",
    "array",
    "value"
  ]
}

##
# @SchemaInfoEnum:
#
# Additional SchemaInfo members for meta-type 'enum'.
#
# @values: the enumeration type's values, in no particular order.
#
# Values of this type are JSON string on the wire.
#
# Since: 2.5
##
{
  "struct": "SchemaInfoEnum",
  "data": {
    "values": [
      "str"
    ]
  }
}

##
# @SchemaInfoArray:
#
# Additional SchemaInfo members for meta-type 'array'.
#
# @element-type: the array type's element type.
#
# Values of this type are JSON array on the wire.
#
# Since: 2.5
##
{
  "struct": "SchemaInfoArray",
  "data": {
    "element-type": "str"
  }
}

##
# @SchemaInfoObject:
#
# Additional SchemaInfo members for meta-type 'object'.
#
# @members: the object type's (non-variant) members, in no particular order.
#
# @tag: the name of the member serving as type tag.
#       An element of @members with this name must exist.
#
# @variants: variant members, i.e. additional members that
#            depend on the type tag's value.  Present exactly when
#            @tag is present.  The variants are in no particular order,
#            and may even differ from the order of the values of the
#            enum type of the @tag.
#
# Values of this type are JSON object on the wire.
#
# Since: 2.5
##
{
  "struct": "SchemaInfoObject",
  "data": {
    "members": [
      "SchemaInfoObjectMember"
    ],
    "*tag": "str",
    "*variants": [
      "SchemaInfoObjectVariant"
    ]
  }
}

##
# @SchemaInfoObjectMember:
#
# An object member.
#
# @name: the member's name, as defined in the QAPI schema.
#
# @type: the name of the member's type.
#
# @default: default when used as command parameter.
#           If absent, the parameter is mandatory.
#           If present, the value must be null.  The parameter is
#           optional, and behavior when it's missing is not specified
#           here.
#           Future extension: if present and non-null, the parameter
#           is optional, and defaults to this value.
#
# Since: 2.5
##
{
  "struct": "SchemaInfoObjectMember",
  "data": {
    "name": "str",
    "type": "str",
    "*default": "any"
  }
}


##
# @SchemaInfoObjectVariant:
#
# The variant members for a value of the type tag.
#
# @case: a value of the type tag.
#
# @type: the name of the object type that provides the variant members
#        when the type tag has value @case.
#
# Since: 2.5
##
{
  "struct": "SchemaInfoObjectVariant",
  "data": {
    "case": "str",
    "type": "str"
  }
}

##
# @SchemaInfoAlternate:
#
# Additional SchemaInfo members for meta-type 'alternate'.
#
# @members: the alternate type's members, in no particular order.
#           The members' wire encoding is distinct, see
#           docs/devel/qapi-code-gen.txt section Alternate types.
#
# On the wire, this can be any of the members.
#
# Since: 2.5
##
{
  "struct": "SchemaInfoAlternate",
  "data": {
    "members": [
      "SchemaInfoAlternateMember"
    ]
  }
}

##
# @SchemaInfoAlternateMember:
#
# An alternate member.
#
# @type: the name of the member's type.
#
# Since: 2.5
##
{
  "struct": "SchemaInfoAlternateMember",
  "data": {
    "type": "str"
  }
}

##
# @SchemaInfoCommand:
#
# Additional SchemaInfo members for meta-type 'command'.
#
# @arg-type: the name of the object type that provides the command's
#            parameters.
#
# @ret-type: the name of the command's result type.
#
# TODO: @success-response (currently irrelevant, because it's QGA, not QMP)
#
# Since: 2.5
##
{
  "struct": "SchemaInfoCommand",
  "data": {
    "arg-type": "str",
    "ret-type": "str"
  }
}

##
# @SchemaInfoEvent:
#
# Additional SchemaInfo members for meta-type 'event'.
#
# @arg-type: the name of the object type that provides the event's
#            parameters.
#
# Since: 2.5
##
{
  "struct": "SchemaInfoEvent",
  "data": {
    "arg-type": "str"
  }
}


##
# @qmp_capabilities:
#
# Enable QMP capabilities.
#
# Arguments: None.
#
# Example:
#
# -> { "execute": "qmp_capabilities" }
# <- { "return": {} }
#
# Notes: This command is valid exactly when first connecting: it must be
# issued before any other command will be accepted, and will fail once the
# monitor is accepting other commands. (see qemu docs/interop/qmp-spec.txt)
#
# Since: 0.13
#
##
{
  "command": "qmp_capabilities"
}

##
# @VersionTriple:
#
# A three-part version number.
#
# @major:  The major version number.
#
# @minor:  The minor version number.
#
# @micro:  The micro version number.
#
# Since: 2.4
##
{
  "struct": "VersionTriple",
  "data": {
    "major": "int",
    "minor": "int",
    "micro": "int"
  }
}


##
# @VersionInfo:
#
# A description of QEMU's version.
#
# @qemu:        The version of QEMU.  By current convention, a micro
#               version of 50 signifies a development branch.  A micro version
#               greater than or equal to 90 signifies a release candidate for
#               the next minor version.  A micro version of less than 50
#               signifies a stable release.
#
# @package:     QEMU will always set this field to an empty string.  Downstream
#               versions of QEMU should set this to a non-empty string.  The
#               exact format depends on the downstream however it highly
#               recommended that a unique name is used.
#
# Since: 0.14.0
##
{
  "struct": "VersionInfo",
  "data": {
    "qemu": "VersionTriple",
    "package": "str"
  }
}

##
# @query-version:
#
# Returns the current version of QEMU.
#
# Returns:  A @VersionInfo object describing the current version of QEMU.
#
# Since: 0.14.0
#
# Example:
#
# -> { "execute": "query-version" }
# <- {
#       "return":{
#          "qemu":{
#             "major":0,
#             "minor":11,
#             "micro":5
#          },
#          "package":""
#       }
#    }
#
##
{
  "command": "query-version",
  "returns": "VersionInfo"
}

##
# @CommandInfo:
#
# Information about a QMP command
#
# @name: The command name
#
# Since: 0.14.0
##
{
  "struct": "CommandInfo",
  "data": {
    "name": "str"
  }
}

##
# @query-commands:
#
# Return a list of supported QMP commands by this server
#
# Returns: A list of @CommandInfo for all supported commands
#
# Since: 0.14.0
#
# Example:
#
# -> { "execute": "query-commands" }
# <- {
#      "return":[
#         {
#            "name":"query-balloon"
#         },
#         {
#            "name":"system_powerdown"
#         }
#      ]
#    }
#
# Note: This example has been shortened as the real response is too long.
#
##
{
  "command": "query-commands",
  "returns": [
    "CommandInfo"
  ]
}

##
# @LostTickPolicy:
#
# Policy for handling lost ticks in timer devices.
#
# @discard: throw away the missed tick(s) and continue with future injection
#           normally.  Guest time may be delayed, unless the OS has explicit
#           handling of lost ticks
#
# @delay: continue to deliver ticks at the normal rate.  Guest time will be
#         delayed due to the late tick
#
# @merge: merge the missed tick(s) into one tick and inject.  Guest time
#         may be delayed, depending on how the OS reacts to the merging
#         of ticks
#
# @slew: deliver ticks at a higher rate to catch up with the missed tick. The
#        guest time should not be delayed once catchup is complete.
#
# Since: 2.0
##
{
  "enum": "LostTickPolicy",
  "data": [
    "discard",
    "delay",
    "merge",
    "slew"
  ]
}

##
# @add_client:
#
# Allow client connections for VNC, Spice and socket based
# character devices to be passed in to QEMU via SCM_RIGHTS.
#
# @protocol: protocol name. Valid names are "vnc", "spice" or the
#            name of a character device (eg. from -chardev id=XXXX)
#
# @fdname: file descriptor name previously passed via 'getfd' command
#
# @skipauth: whether to skip authentication. Only applies
#            to "vnc" and "spice" protocols
#
# @tls: whether to perform TLS. Only applies to the "spice"
#       protocol
#
# Returns: nothing on success.
#
# Since: 0.14.0
#
# Example:
#
# -> { "execute": "add_client", "arguments": { "protocol": "vnc",
#                                              "fdname": "myclient" } }
# <- { "return": {} }
#
##
{
  "command": "add_client",
  "data": {
    "protocol": "str",
    "fdname": "str",
    "*skipauth": "bool",
    "*tls": "bool"
  }
}

##
# @NameInfo:
#
# Guest name information.
#
# @name: The name of the guest
#
# Since: 0.14.0
##
{
  "struct": "NameInfo",
  "data": {
    "*name": "str"
  }
}

##
# @query-name:
#
# Return the name information of a guest.
#
# Returns: @NameInfo of the guest
#
# Since: 0.14.0
#
# Example:
#
# -> { "execute": "query-name" }
# <- { "return": { "name": "qemu-name" } }
#
##
{
  "command": "query-name",
  "returns": "NameInfo"
}

##
# @KvmInfo:
#
# Information about support for KVM acceleration
#
# @enabled: true if KVM acceleration is active
#
# @present: true if KVM acceleration is built into this executable
#
# Since: 0.14.0
##
{
  "struct": "KvmInfo",
  "data": {
    "enabled": "bool",
    "present": "bool"
  }
}

##
# @query-kvm:
#
# Returns information about KVM acceleration
#
# Returns: @KvmInfo
#
# Since: 0.14.0
#
# Example:
#
# -> { "execute": "query-kvm" }
# <- { "return": { "enabled": true, "present": true } }
#
##
{
  "command": "query-kvm",
  "returns": "KvmInfo"
}

##
# @UuidInfo:
#
# Guest UUID information (Universally Unique Identifier).
#
# @UUID: the UUID of the guest
#
# Since: 0.14.0
#
# Notes: If no UUID was specified for the guest, a null UUID is returned.
##
{
  "struct": "UuidInfo",
  "data": {
    "UUID": "str"
  }
}

##
# @query-uuid:
#
# Query the guest UUID information.
#
# Returns: The @UuidInfo for the guest
#
# Since: 0.14.0
#
# Example:
#
# -> { "execute": "query-uuid" }
# <- { "return": { "UUID": "550e8400-e29b-41d4-a716-446655440000" } }
#
##
{
  "command": "query-uuid",
  "returns": "UuidInfo"
}

##
# @EventInfo:
#
# Information about a QMP event
#
# @name: The event name
#
# Since: 1.2.0
##
{
  "struct": "EventInfo",
  "data": {
    "name": "str"
  }
}

##
# @query-events:
#
# Return a list of supported QMP events by this server
#
# Returns: A list of @EventInfo for all supported events
#
# Since: 1.2.0
#
# Example:
#
# -> { "execute": "query-events" }
# <- {
#      "return": [
#          {
#             "name":"SHUTDOWN"
#          },
#          {
#             "name":"RESET"
#          }
#       ]
#    }
#
# Note: This example has been shortened as the real response is too long.
#
##
{
  "command": "query-events",
  "returns": [
    "EventInfo"
  ]
}

##
# @CpuInfoArch:
#
# An enumeration of cpu types that enable additional information during
# @query-cpus.
#
# Since: 2.6
##
{
  "enum": "CpuInfoArch",
  "data": [
    "x86",
    "sparc",
    "ppc",
    "mips",
    "tricore",
    "other"
  ]
}

##
# @CpuInfo:
#
# Information about a virtual CPU
#
# @CPU: the index of the virtual CPU
#
# @current: this only exists for backwards compatibility and should be ignored
#
# @halted: true if the virtual CPU is in the halt state.  Halt usually refers
#          to a processor specific low power mode.
#
# @qom_path: path to the CPU object in the QOM tree (since 2.4)
#
# @thread_id: ID of the underlying host thread
#
# @props: properties describing to which node/socket/core/thread
#         virtual CPU belongs to, provided if supported by board (since 2.10)
#
# @arch: architecture of the cpu, which determines which additional fields
#        will be listed (since 2.6)
#
# Since: 0.14.0
#
# Notes: @halted is a transient state that changes frequently.  By the time the
#        data is sent to the client, the guest may no longer be halted.
##
{
  "union": "CpuInfo",
  "base": {
    "CPU": "int",
    "current": "bool",
    "halted": "bool",
    "qom_path": "str",
    "thread_id": "int",
    "*props": "CpuInstanceProperties",
    "arch": "CpuInfoArch"
  },
  "discriminator": "arch",
  "data": {
    "x86": "CpuInfoX86",
    "sparc": "CpuInfoSPARC",
    "ppc": "CpuInfoPPC",
    "mips": "CpuInfoMIPS",
    "tricore": "CpuInfoTricore",
    "other": "CpuInfoOther"
  }
}

##
# @CpuInfoX86:
#
# Additional information about a virtual i386 or x86_64 CPU
#
# @pc: the 64-bit instruction pointer
#
# Since: 2.6
##
{
  "struct": "CpuInfoX86",
  "data": {
    "pc": "int"
  }
}

##
# @CpuInfoSPARC:
#
# Additional information about a virtual SPARC CPU
#
# @pc: the PC component of the instruction pointer
#
# @npc: the NPC component of the instruction pointer
#
# Since: 2.6
##
{
  "struct": "CpuInfoSPARC",
  "data": {
    "pc": "int",
    "npc": "int"
  }
}

##
# @CpuInfoPPC:
#
# Additional information about a virtual PPC CPU
#
# @nip: the instruction pointer
#
# Since: 2.6
##
{
  "struct": "CpuInfoPPC",
  "data": {
    "nip": "int"
  }
}

##
# @CpuInfoMIPS:
#
# Additional information about a virtual MIPS CPU
#
# @PC: the instruction pointer
#
# Since: 2.6
##
{
  "struct": "CpuInfoMIPS",
  "data": {
    "PC": "int"
  }
}

##
# @CpuInfoTricore:
#
# Additional information about a virtual Tricore CPU
#
# @PC: the instruction pointer
#
# Since: 2.6
##
{
  "struct": "CpuInfoTricore",
  "data": {
    "PC": "int"
  }
}

##
# @CpuInfoOther:
#
# No additional information is available about the virtual CPU
#
# Since: 2.6
#
##
{
  "struct": "CpuInfoOther",
  "data": {}
}

##
# @query-cpus:
#
# Returns a list of information about each virtual CPU.
#
# Returns: a list of @CpuInfo for each virtual CPU
#
# Since: 0.14.0
#
# Example:
#
# -> { "execute": "query-cpus" }
# <- { "return": [
#          {
#             "CPU":0,
#             "current":true,
#             "halted":false,
#             "qom_path":"/machine/unattached/device[0]",
#             "arch":"x86",
#             "pc":3227107138,
#             "thread_id":3134
#          },
#          {
#             "CPU":1,
#             "current":false,
#             "halted":true,
#             "qom_path":"/machine/unattached/device[2]",
#             "arch":"x86",
#             "pc":7108165,
#             "thread_id":3135
#          }
#       ]
#    }
#
##
{
  "command": "query-cpus",
  "returns": [
    "CpuInfo"
  ]
}

##
# @IOThreadInfo:
#
# Information about an iothread
#
# @id: the identifier of the iothread
#
# @thread-id: ID of the underlying host thread
#
# @poll-max-ns: maximum polling time in ns, 0 means polling is disabled
#               (since 2.9)
#
# @poll-grow: how many ns will be added to polling time, 0 means that it's not
#             configured (since 2.9)
#
# @poll-shrink: how many ns will be removed from polling time, 0 means that
#               it's not configured (since 2.9)
#
# Since: 2.0
##
{
  "struct": "IOThreadInfo",
  "data": {
    "id": "str",
    "thread-id": "int",
    "poll-max-ns": "int",
    "poll-grow": "int",
    "poll-shrink": "int"
  }
}

##
# @query-iothreads:
#
# Returns a list of information about each iothread.
#
# Note: this list excludes the QEMU main loop thread, which is not declared
# using the -object iothread command-line option.  It is always the main thread
# of the process.
#
# Returns: a list of @IOThreadInfo for each iothread
#
# Since: 2.0
#
# Example:
#
# -> { "execute": "query-iothreads" }
# <- { "return": [
#          {
#             "id":"iothread0",
#             "thread-id":3134
#          },
#          {
#             "id":"iothread1",
#             "thread-id":3135
#          }
#       ]
#    }
#
##
{
  "command": "query-iothreads",
  "returns": [
    "IOThreadInfo"
  ]
}

##
# @BalloonInfo:
#
# Information about the guest balloon device.
#
# @actual: the number of bytes the balloon currently contains
#
# Since: 0.14.0
#
##
{
  "struct": "BalloonInfo",
  "data": {
    "actual": "int"
  }
}

##
# @query-balloon:
#
# Return information about the balloon device.
#
# Returns: @BalloonInfo on success
#
#          If the balloon driver is enabled but not functional because the KVM
#          kernel module cannot support it, KvmMissingCap
#
#          If no balloon device is present, DeviceNotActive
#
# Since: 0.14.0
#
# Example:
#
# -> { "execute": "query-balloon" }
# <- { "return": {
#          "actual": 1073741824,
#       }
#    }
#
##
{
  "command": "query-balloon",
  "returns": "BalloonInfo"
}

##
# @BALLOON_CHANGE:
#
# Emitted when the guest changes the actual BALLOON level. This value is
# equivalent to the @actual field return by the 'query-balloon' command
#
# @actual: actual level of the guest memory balloon in bytes
#
# Note: this event is rate-limited.
#
# Since: 1.2
#
# Example:
#
# <- { "event": "BALLOON_CHANGE",
#      "data": { "actual": 944766976 },
#      "timestamp": { "seconds": 1267020223, "microseconds": 435656 } }
#
##
{
  "event": "BALLOON_CHANGE",
  "data": {
    "actual": "int"
  }
}

##
# @PciMemoryRange:
#
# A PCI device memory region
#
# @base: the starting address (guest physical)
#
# @limit: the ending address (guest physical)
#
# Since: 0.14.0
##
{
  "struct": "PciMemoryRange",
  "data": {
    "base": "int",
    "limit": "int"
  }
}

##
# @PciMemoryRegion:
#
# Information about a PCI device I/O region.
#
# @bar: the index of the Base Address Register for this region
#
# @type: 'io' if the region is a PIO region
#        'memory' if the region is a MMIO region
#
# @size: memory size
#
# @prefetch: if @type is 'memory', true if the memory is prefetchable
#
# @mem_type_64: if @type is 'memory', true if the BAR is 64-bit
#
# Since: 0.14.0
##
{
  "struct": "PciMemoryRegion",
  "data": {
    "bar": "int",
    "type": "str",
    "address": "int",
    "size": "int",
    "*prefetch": "bool",
    "*mem_type_64": "bool"
  }
}

##
# @PciBusInfo:
#
# Information about a bus of a PCI Bridge device
#
# @number: primary bus interface number.  This should be the number of the
#          bus the device resides on.
#
# @secondary: secondary bus interface number.  This is the number of the
#             main bus for the bridge
#
# @subordinate: This is the highest number bus that resides below the
#               bridge.
#
# @io_range: The PIO range for all devices on this bridge
#
# @memory_range: The MMIO range for all devices on this bridge
#
# @prefetchable_range: The range of prefetchable MMIO for all devices on
#                      this bridge
#
# Since: 2.4
##
{
  "struct": "PciBusInfo",
  "data": {
    "number": "int",
    "secondary": "int",
    "subordinate": "int",
    "io_range": "PciMemoryRange",
    "memory_range": "PciMemoryRange",
    "prefetchable_range": "PciMemoryRange"
  }
}

##
# @PciBridgeInfo:
#
# Information about a PCI Bridge device
#
# @bus: information about the bus the device resides on
#
# @devices: a list of @PciDeviceInfo for each device on this bridge
#
# Since: 0.14.0
##
{
  "struct": "PciBridgeInfo",
  "data": {
    "bus": "PciBusInfo",
    "*devices": [
      "PciDeviceInfo"
    ]
  }
}

##
# @PciDeviceClass:
#
# Information about the Class of a PCI device
#
# @desc: a string description of the device's class
#
# @class: the class code of the device
#
# Since: 2.4
##
{
  "struct": "PciDeviceClass",
  "data": {
    "*desc": "str",
    "class": "int"
  }
}

##
# @PciDeviceId:
#
# Information about the Id of a PCI device
#
# @device: the PCI device id
#
# @vendor: the PCI vendor id
#
# Since: 2.4
##
{
  "struct": "PciDeviceId",
  "data": {
    "device": "int",
    "vendor": "int"
  }
}

##
# @PciDeviceInfo:
#
# Information about a PCI device
#
# @bus: the bus number of the device
#
# @slot: the slot the device is located in
#
# @function: the function of the slot used by the device
#
# @class_info: the class of the device
#
# @id: the PCI device id
#
# @irq: if an IRQ is assigned to the device, the IRQ number
#
# @qdev_id: the device name of the PCI device
#
# @pci_bridge: if the device is a PCI bridge, the bridge information
#
# @regions: a list of the PCI I/O regions associated with the device
#
# Notes: the contents of @class_info.desc are not stable and should only be
#        treated as informational.
#
# Since: 0.14.0
##
{
  "struct": "PciDeviceInfo",
  "data": {
    "bus": "int",
    "slot": "int",
    "function": "int",
    "class_info": "PciDeviceClass",
    "id": "PciDeviceId",
    "*irq": "int",
    "qdev_id": "str",
    "*pci_bridge": "PciBridgeInfo",
    "regions": [
      "PciMemoryRegion"
    ]
  }
}

##
# @PciInfo:
#
# Information about a PCI bus
#
# @bus: the bus index
#
# @devices: a list of devices on this bus
#
# Since: 0.14.0
##
{
  "struct": "PciInfo",
  "data": {
    "bus": "int",
    "devices": [
      "PciDeviceInfo"
    ]
  }
}

##
# @query-pci:
#
# Return information about the PCI bus topology of the guest.
#
# Returns: a list of @PciInfo for each PCI bus. Each bus is
# represented by a json-object, which has a key with a json-array of
# all PCI devices attached to it. Each device is represented by a
# json-object.
#
# Since: 0.14.0
#
# Example:
#
# -> { "execute": "query-pci" }
# <- { "return": [
#          {
#             "bus": 0,
#             "devices": [
#                {
#                   "bus": 0,
#                   "qdev_id": "",
#                   "slot": 0,
#                   "class_info": {
#                      "class": 1536,
#                      "desc": "Host bridge"
#                   },
#                   "id": {
#                      "device": 32902,
#                      "vendor": 4663
#                   },
#                   "function": 0,
#                   "regions": [
#                   ]
#                },
#                {
#                   "bus": 0,
#                   "qdev_id": "",
#                   "slot": 1,
#                   "class_info": {
#                      "class": 1537,
#                      "desc": "ISA bridge"
#                   },
#                   "id": {
#                      "device": 32902,
#                      "vendor": 28672
#                   },
#                   "function": 0,
#                   "regions": [
#                   ]
#                },
#                {
#                   "bus": 0,
#                   "qdev_id": "",
#                   "slot": 1,
#                   "class_info": {
#                      "class": 257,
#                      "desc": "IDE controller"
#                   },
#                   "id": {
#                      "device": 32902,
#                      "vendor": 28688
#                   },
#                   "function": 1,
#                   "regions": [
#                      {
#                         "bar": 4,
#                         "size": 16,
#                         "address": 49152,
#                         "type": "io"
#                      }
#                   ]
#                },
#                {
#                   "bus": 0,
#                   "qdev_id": "",
#                   "slot": 2,
#                   "class_info": {
#                      "class": 768,
#                      "desc": "VGA controller"
#                   },
#                   "id": {
#                      "device": 4115,
#                      "vendor": 184
#                   },
#                   "function": 0,
#                   "regions": [
#                      {
#                         "prefetch": true,
#                         "mem_type_64": false,
#                         "bar": 0,
#                         "size": 33554432,
#                         "address": 4026531840,
#                         "type": "memory"
#                      },
#                      {
#                         "prefetch": false,
#                         "mem_type_64": false,
#                         "bar": 1,
#                         "size": 4096,
#                         "address": 4060086272,
#                         "type": "memory"
#                      },
#                      {
#                         "prefetch": false,
#                         "mem_type_64": false,
#                         "bar": 6,
#                         "size": 65536,
#                         "address": -1,
#                         "type": "memory"
#                      }
#                   ]
#                },
#                {
#                   "bus": 0,
#                   "qdev_id": "",
#                   "irq": 11,
#                   "slot": 4,
#                   "class_info": {
#                      "class": 1280,
#                      "desc": "RAM controller"
#                   },
#                   "id": {
#                      "device": 6900,
#                      "vendor": 4098
#                   },
#                   "function": 0,
#                   "regions": [
#                      {
#                         "bar": 0,
#                         "size": 32,
#                         "address": 49280,
#                         "type": "io"
#                      }
#                   ]
#                }
#             ]
#          }
#       ]
#    }
#
# Note: This example has been shortened as the real response is too long.
#
##
{
  "command": "query-pci",
  "returns": [
    "PciInfo"
  ]
}

##
{
  "command": "quit"
}

##
# @stop:
#
# Stop all guest VCPU execution.
#
# Since:  0.14.0
#
# Notes:  This function will succeed even if the guest is already in the stopped
#         state.  In "inmigrate" state, it will ensure that the guest
#         remains paused once migration finishes, as if the -S option was
#         passed on the command line.
#
# Example:
#
# -> { "execute": "stop" }
# <- { "return": {} }
#
##
{
  "command": "stop"
}

##
# @system_reset:
#
# Performs a hard reset of a guest.
#
# Since: 0.14.0
#
# Example:
#
# -> { "execute": "system_reset" }
# <- { "return": {} }
#
##
{
  "command": "system_reset"
}

##
# @system_powerdown:
#
# Requests that a guest perform a powerdown operation.
#
# Since: 0.14.0
#
# Notes: A guest may or may not respond to this command.  This command
#        returning does not indicate that a guest has accepted the request or
#        that it has shut down.  Many guests will respond to this command by
#        prompting the user in some way.
# Example:
#
# -> { "execute": "system_powerdown" }
# <- { "return": {} }
#
##
{
  "command": "system_powerdown"
}

##
# @cpu:
#
# This command is a nop that is only provided for the purposes of compatibility.
#
# Since: 0.14.0
#
# Notes: Do not use this command.
##
{
  "command": "cpu",
  "data": {
    "index": "int"
  }
}

##
# @cpu-add:
#
# Adds CPU with specified ID
#
# @id: ID of CPU to be created, valid values [0..max_cpus)
#
# Returns: Nothing on success
#
# Since: 1.5
#
# Example:
#
# -> { "execute": "cpu-add", "arguments": { "id": 2 } }
# <- { "return": {} }
#
##
{
  "command": "cpu-add",
  "data": {
    "id": "int"
  }
}

##
# @memsave:
#
# Save a portion of guest memory to a file.
#
# @val: the virtual address of the guest to start from
#
# @size: the size of memory region to save
#
# @filename: the file to save the memory to as binary data
#
# @cpu-index: the index of the virtual CPU to use for translating the
#                       virtual address (defaults to CPU 0)
#
# Returns: Nothing on success
#
# Since: 0.14.0
#
# Notes: Errors were not reliably returned until 1.1
#
# Example:
#
# -> { "execute": "memsave",
#      "arguments": { "val": 10,
#                     "size": 100,
#                     "filename": "/tmp/virtual-mem-dump" } }
# <- { "return": {} }
#
##
{
  "command": "memsave",
  "data": {
    "val": "int",
    "size": "int",
    "filename": "str",
    "*cpu-index": "int"
  }
}

##
# @pmemsave:
#
# Save a portion of guest physical memory to a file.
#
# @val: the physical address of the guest to start from
#
# @size: the size of memory region to save
#
# @filename: the file to save the memory to as binary data
#
# Returns: Nothing on success
#
# Since: 0.14.0
#
# Notes: Errors were not reliably returned until 1.1
#
# Example:
#
# -> { "execute": "pmemsave",
#      "arguments": { "val": 10,
#                     "size": 100,
#                     "filename": "/tmp/physical-mem-dump" } }
# <- { "return": {} }
#
##
{
  "command": "pmemsave",
  "data": {
    "val": "int",
    "size": "int",
    "filename": "str"
  }
}

##
# @cont:
#
# Resume guest VCPU execution.
#
# Since:  0.14.0
#
# Returns:  If successful, nothing
#
# Notes:  This command will succeed if the guest is currently running.  It
#         will also succeed if the guest is in the "inmigrate" state; in
#         this case, the effect of the command is to make sure the guest
#         starts once migration finishes, removing the effect of the -S
#         command line option if it was passed.
#
# Example:
#
# -> { "execute": "cont" }
# <- { "return": {} }
#
##
{
  "command": "cont"
}

##
# @system_wakeup:
#
# Wakeup guest from suspend.  Does nothing in case the guest isn't suspended.
#
# Since:  1.1
#
# Returns:  nothing.
#
# Example:
#
# -> { "execute": "system_wakeup" }
# <- { "return": {} }
#
##
{
  "command": "system_wakeup"
}

##
# @inject-nmi:
#
# Injects a Non-Maskable Interrupt into the default CPU (x86/s390) or all CPUs (ppc64).
# The command fails when the guest doesn't support injecting.
#
# Returns:  If successful, nothing
#
# Since:  0.14.0
#
# Note: prior to 2.1, this command was only supported for x86 and s390 VMs
#
# Example:
#
# -> { "execute": "inject-nmi" }
# <- { "return": {} }
#
##
{
  "command": "inject-nmi"
}

##
# @balloon:
#
# Request the balloon driver to change its balloon size.
#
# @value: the target size of the balloon in bytes
#
# Returns: Nothing on success
#          If the balloon driver is enabled but not functional because the KVM
#            kernel module cannot support it, KvmMissingCap
#          If no balloon device is present, DeviceNotActive
#
# Notes: This command just issues a request to the guest.  When it returns,
#        the balloon size may not have changed.  A guest can change the balloon
#        size independent of this command.
#
# Since: 0.14.0
#
# Example:
#
# -> { "execute": "balloon", "arguments": { "value": 536870912 } }
# <- { "return": {} }
#
##
{
  "command": "balloon",
  "data": {
    "value": "int"
  }
}

##
# @human-monitor-command:
#
# Execute a command on the human monitor and return the output.
#
# @command-line: the command to execute in the human monitor
#
# @cpu-index: The CPU to use for commands that require an implicit CPU
#
# Returns: the output of the command as a string
#
# Since: 0.14.0
#
# Notes: This command only exists as a stop-gap.  Its use is highly
#        discouraged.  The semantics of this command are not
#        guaranteed: this means that command names, arguments and
#        responses can change or be removed at ANY time.  Applications
#        that rely on long term stability guarantees should NOT
#        use this command.
#
#        Known limitations:
#
#        * This command is stateless, this means that commands that depend
#          on state information (such as getfd) might not work
#
#        * Commands that prompt the user for data don't currently work
#
# Example:
#
# -> { "execute": "human-monitor-command",
#      "arguments": { "command-line": "info kvm" } }
# <- { "return": "kvm support: enabled\r\n" }
#
##
{
  "command": "human-monitor-command",
  "data": {
    "command-line": "str",
    "*cpu-index": "int"
  },
  "returns": "str"
}

##
# @ObjectPropertyInfo:
#
# @name: the name of the property
#
# @type: the type of the property.  This will typically come in one of four
#        forms:
#
#        1) A primitive type such as 'u8', 'u16', 'bool', 'str', or 'double'.
#           These types are mapped to the appropriate JSON type.
#
#        2) A child type in the form 'child<subtype>' where subtype is a qdev
#           device type name.  Child properties create the composition tree.
#
#        3) A link type in the form 'link<subtype>' where subtype is a qdev
#           device type name.  Link properties form the device model graph.
#
# Since: 1.2
##
{
  "struct": "ObjectPropertyInfo",
  "data": {
    "name": "str",
    "type": "str"
  }
}

##
# @qom-list:
#
# This command will list any properties of a object given a path in the object
# model.
#
# @path: the path within the object model.  See @qom-get for a description of
#        this parameter.
#
# Returns: a list of @ObjectPropertyInfo that describe the properties of the
#          object.
#
# Since: 1.2
##
{
  "command": "qom-list",
  "data": {
    "path": "str"
  },
  "returns": [
    "ObjectPropertyInfo"
  ]
}

##
# @qom-get:
#
# This command will get a property from a object model path and return the
# value.
#
# @path: The path within the object model.  There are two forms of supported
#        paths--absolute and partial paths.
#
#        Absolute paths are derived from the root object and can follow child<>
#        or link<> properties.  Since they can follow link<> properties, they
#        can be arbitrarily long.  Absolute paths look like absolute filenames
#        and are prefixed  with a leading slash.
#
#        Partial paths look like relative filenames.  They do not begin
#        with a prefix.  The matching rules for partial paths are subtle but
#        designed to make specifying objects easy.  At each level of the
#        composition tree, the partial path is matched as an absolute path.
#        The first match is not returned.  At least two matches are searched
#        for.  A successful result is only returned if only one match is
#        found.  If more than one match is found, a flag is return to
#        indicate that the match was ambiguous.
#
# @property: The property name to read
#
# Returns: The property value.  The type depends on the property
#          type. child<> and link<> properties are returned as #str
#          pathnames.  All integer property types (u8, u16, etc) are
#          returned as #int.
#
# Since: 1.2
##
{
  "command": "qom-get",
  "data": {
    "path": "str",
    "property": "str"
  },
  "returns": "any"
}

##
# @qom-set:
#
# This command will set a property from a object model path.
#
# @path: see @qom-get for a description of this parameter
#
# @property: the property name to set
#
# @value: a value who's type is appropriate for the property type.  See @qom-get
#         for a description of type mapping.
#
# Since: 1.2
##
{
  "command": "qom-set",
  "data": {
    "path": "str",
    "property": "str",
    "value": "any"
  }
}

##
# @change:
#
# This command is multiple commands multiplexed together.
#
# @device: This is normally the name of a block device but it may also be 'vnc'.
#          when it's 'vnc', then sub command depends on @target
#
# @target: If @device is a block device, then this is the new filename.
#          If @device is 'vnc', then if the value 'password' selects the vnc
#          change password command.   Otherwise, this specifies a new server URI
#          address to listen to for VNC connections.
#
# @arg:    If @device is a block device, then this is an optional format to open
#          the device with.
#          If @device is 'vnc' and @target is 'password', this is the new VNC
#          password to set.  See change-vnc-password for additional notes.
#
# Returns: Nothing on success.
#          If @device is not a valid block device, DeviceNotFound
#
# Notes:  This interface is deprecated, and it is strongly recommended that you
#         avoid using it.  For changing block devices, use
#         blockdev-change-medium; for changing VNC parameters, use
#         change-vnc-password.
#
# Since: 0.14.0
#
# Example:
#
# 1. Change a removable medium
#
# -> { "execute": "change",
#      "arguments": { "device": "ide1-cd0",
#                     "target": "/srv/images/Fedora-12-x86_64-DVD.iso" } }
# <- { "return": {} }
#
# 2. Change VNC password
#
# -> { "execute": "change",
#      "arguments": { "device": "vnc", "target": "password",
#                     "arg": "foobar1" } }
# <- { "return": {} }
#
##
{
  "command": "change",
  "data": {
    "device": "str",
    "target": "str",
    "*arg": "str"
  }
}

##
# @ObjectTypeInfo:
#
# This structure describes a search result from @qom-list-types
#
# @name: the type name found in the search
#
# @abstract: the type is abstract and can't be directly instantiated.
#            Omitted if false. (since 2.10)
#
# @parent: Name of parent type, if any (since 2.10)
#
# Since: 1.1
##
{
  "struct": "ObjectTypeInfo",
  "data": {
    "name": "str",
    "*abstract": "bool",
    "*parent": "str"
  }
}

##
# @qom-list-types:
#
# This command will return a list of types given search parameters
#
# @implements: if specified, only return types that implement this type name
#
# @abstract: if true, include abstract types in the results
#
# Returns: a list of @ObjectTypeInfo or an empty list if no results are found
#
# Since: 1.1
##
{
  "command": "qom-list-types",
  "data": {
    "*implements": "str",
    "*abstract": "bool"
  },
  "returns": [
    "ObjectTypeInfo"
  ]
}

##
# @DevicePropertyInfo:
#
# Information about device properties.
#
# @name: the name of the property
# @type: the typename of the property
# @description: if specified, the description of the property.
#               (since 2.2)
#
# Since: 1.2
##
{
  "struct": "DevicePropertyInfo",
  "data": {
    "name": "str",
    "type": "str",
    "*description": "str"
  }
}

##
# @device-list-properties:
#
# List properties associated with a device.
#
# @typename: the type name of a device
#
# Returns: a list of DevicePropertyInfo describing a devices properties
#
# Since: 1.2
##
{
  "command": "device-list-properties",
  "data": {
    "typename": "str"
  },
  "returns": [
    "DevicePropertyInfo"
  ]
}

##
# @xen-set-global-dirty-log:
#
# Enable or disable the global dirty log mode.
#
# @enable: true to enable, false to disable.
#
# Returns: nothing
#
# Since: 1.3
#
# Example:
#
# -> { "execute": "xen-set-global-dirty-log",
#      "arguments": { "enable": true } }
# <- { "return": {} }
#
##
{
  "command": "xen-set-global-dirty-log",
  "data": {
    "enable": "bool"
  }
}

##
# @device_add:
#
# @driver: the name of the new device's driver
#
# @bus: the device's parent bus (device tree path)
#
# @id: the device's ID, must be unique
#
# Additional arguments depend on the type.
#
# Add a device.
#
# Notes:
# 1. For detailed information about this command, please refer to the
#    'docs/qdev-device-use.txt' file.
#
# 2. It's possible to list device properties by running QEMU with the
#    "-device DEVICE,help" command-line argument, where DEVICE is the
#    device's name
#
# Example:
#
# -> { "execute": "device_add",
#      "arguments": { "driver": "e1000", "id": "net1",
#                     "bus": "pci.0",
#                     "mac": "52:54:00:12:34:56" } }
# <- { "return": {} }
#
# TODO: This command effectively bypasses QAPI completely due to its
# "additional arguments" business.  It shouldn't have been added to
# the schema in this form.  It should be qapified properly, or
# replaced by a properly qapified command.
#
# Since: 0.13
##
{
  "command": "device_add",
  "data": {
    "driver": "str",
    "*bus": "str",
    "*id": "str"
  },
  "gen": false
} 

##
# @device_del:
#
# Remove a device from a guest
#
# @id: the device's ID or QOM path
#
# Returns: Nothing on success
#          If @id is not a valid device, DeviceNotFound
#
# Notes: When this command completes, the device may not be removed from the
#        guest.  Hot removal is an operation that requires guest cooperation.
#        This command merely requests that the guest begin the hot removal
#        process.  Completion of the device removal process is signaled with a
#        DEVICE_DELETED event. Guest reset will automatically complete removal
#        for all devices.
#
# Since: 0.14.0
#
# Example:
#
# -> { "execute": "device_del",
#      "arguments": { "id": "net1" } }
# <- { "return": {} }
#
# -> { "execute": "device_del",
#      "arguments": { "id": "/machine/peripheral-anon/device[0]" } }
# <- { "return": {} }
#
##
{
  "command": "device_del",
  "data": {
    "id": "str"
  }
}

##
# @DEVICE_DELETED:
#
# Emitted whenever the device removal completion is acknowledged by the guest.
# At this point, it's safe to reuse the specified device ID. Device removal can
# be initiated by the guest or by HMP/QMP commands.
#
# @device: device name
#
# @path: device path
#
# Since: 1.5
#
# Example:
#
# <- { "event": "DEVICE_DELETED",
#      "data": { "device": "virtio-net-pci-0",
#                "path": "/machine/peripheral/virtio-net-pci-0" },
#      "timestamp": { "seconds": 1265044230, "microseconds": 450486 } }
#
##
{
  "event": "DEVICE_DELETED",
  "data": {
    "*device": "str",
    "path": "str"
  }
}

##
# @DumpGuestMemoryFormat:
#
# An enumeration of guest-memory-dump's format.
#
# @elf: elf format
#
# @kdump-zlib: kdump-compressed format with zlib-compressed
#
# @kdump-lzo: kdump-compressed format with lzo-compressed
#
# @kdump-snappy: kdump-compressed format with snappy-compressed
#
# Since: 2.0
##
{
  "enum": "DumpGuestMemoryFormat",
  "data": [
    "elf",
    "kdump-zlib",
    "kdump-lzo",
    "kdump-snappy"
  ]
}

##
# @dump-guest-memory:
#
# Dump guest's memory to vmcore. It is a synchronous operation that can take
# very long depending on the amount of guest memory.
#
# @paging: if true, do paging to get guest's memory mapping. This allows
#          using gdb to process the core file.
#
#          IMPORTANT: this option can make QEMU allocate several gigabytes
#                     of RAM. This can happen for a large guest, or a
#                     malicious guest pretending to be large.
#
#          Also, paging=true has the following limitations:
#
#             1. The guest may be in a catastrophic state or can have corrupted
#                memory, which cannot be trusted
#             2. The guest can be in real-mode even if paging is enabled. For
#                example, the guest uses ACPI to sleep, and ACPI sleep state
#                goes in real-mode
#             3. Currently only supported on i386 and x86_64.
#
# @protocol: the filename or file descriptor of the vmcore. The supported
#            protocols are:
#
#            1. file: the protocol starts with "file:", and the following
#               string is the file's path.
#            2. fd: the protocol starts with "fd:", and the following string
#               is the fd's name.
#
# @detach: if true, QMP will return immediately rather than
#          waiting for the dump to finish. The user can track progress
#          using "query-dump". (since 2.6).
#
# @begin: if specified, the starting physical address.
#
# @length: if specified, the memory size, in bytes. If you don't
#          want to dump all guest's memory, please specify the start @begin
#          and @length
#
# @format: if specified, the format of guest memory dump. But non-elf
#          format is conflict with paging and filter, ie. @paging, @begin and
#          @length is not allowed to be specified with non-elf @format at the
#          same time (since 2.0)
#
# Note: All boolean arguments default to false
#
# Returns: nothing on success
#
# Since: 1.2
#
# Example:
#
# -> { "execute": "dump-guest-memory",
#      "arguments": { "protocol": "fd:dump" } }
# <- { "return": {} }
#
##
{
  "command": "dump-guest-memory",
  "data": {
    "paging": "bool",
    "protocol": "str",
    "*detach": "bool",
    "*begin": "int",
    "*length": "int",
    "*format": "DumpGuestMemoryFormat"
  }
}

##
# @DumpStatus:
#
# Describe the status of a long-running background guest memory dump.
#
# @none: no dump-guest-memory has started yet.
#
# @active: there is one dump running in background.
#
# @completed: the last dump has finished successfully.
#
# @failed: the last dump has failed.
#
# Since: 2.6
##
{
  "enum": "DumpStatus",
  "data": [
    "none",
    "active",
    "completed",
    "failed"
  ]
}

##
# @DumpQueryResult:
#
# The result format for 'query-dump'.
#
# @status: enum of @DumpStatus, which shows current dump status
#
# @completed: bytes written in latest dump (uncompressed)
#
# @total: total bytes to be written in latest dump (uncompressed)
#
# Since: 2.6
##
{
  "struct": "DumpQueryResult",
  "data": {
    "status": "DumpStatus",
    "completed": "int",
    "total": "int"
  }
}

##
# @query-dump:
#
# Query latest dump status.
#
# Returns: A @DumpStatus object showing the dump status.
#
# Since: 2.6
#
# Example:
#
# -> { "execute": "query-dump" }
# <- { "return": { "status": "active", "completed": 1024000,
#                  "total": 2048000 } }
#
##
{
  "command": "query-dump",
  "returns": "DumpQueryResult"
}

##
# @DUMP_COMPLETED:
#
# Emitted when background dump has completed
#
# @result: DumpQueryResult type described in qapi-schema.json.
#
# @error: human-readable error string that provides
#         hint on why dump failed. Only presents on failure. The
#         user should not try to interpret the error string.
#
# Since: 2.6
#
# Example:
#
# { "event": "DUMP_COMPLETED",
#   "data": {"result": {"total": 1090650112, "status": "completed",
#                       "completed": 1090650112} } }
#
##
{
  "event": "DUMP_COMPLETED",
  "data": {
    "result": "DumpQueryResult",
    "*error": "str"
  }
}

##
# @DumpGuestMemoryCapability:
#
# A list of the available formats for dump-guest-memory
#
# Since: 2.0
##
{
  "struct": "DumpGuestMemoryCapability",
  "data": {
    "formats": [
      "DumpGuestMemoryFormat"
    ]
  }
}

##
# @query-dump-guest-memory-capability:
#
# Returns the available formats for dump-guest-memory
#
# Returns:  A @DumpGuestMemoryCapability object listing available formats for
#           dump-guest-memory
#
# Since: 2.0
#
# Example:
#
# -> { "execute": "query-dump-guest-memory-capability" }
# <- { "return": { "formats":
#                  ["elf", "kdump-zlib", "kdump-lzo", "kdump-snappy"] }
#
##
{
  "command": "query-dump-guest-memory-capability",
  "returns": "DumpGuestMemoryCapability"
}

##
# @dump-skeys:
#
# Dump guest's storage keys
#
# @filename: the path to the file to dump to
#
# This command is only supported on s390 architecture.
#
# Since: 2.5
#
# Example:
#
# -> { "execute": "dump-skeys",
#      "arguments": { "filename": "/tmp/skeys" } }
# <- { "return": {} }
#
##
{
  "command": "dump-skeys",
  "data": {
    "filename": "str"
  }
}

##
# @object-add:
#
# Create a QOM object.
#
# @qom-type: the class name for the object to be created
#
# @id: the name of the new object
#
# @props: a dictionary of properties to be passed to the backend
#
# Returns: Nothing on success
#          Error if @qom-type is not a valid class name
#
# Since: 2.0
#
# Example:
#
# -> { "execute": "object-add",
#      "arguments": { "qom-type": "rng-random", "id": "rng1",
#                     "props": { "filename": "/dev/hwrng" } } }
# <- { "return": {} }
#
##
{
  "command": "object-add",
  "data": {
    "qom-type": "str",
    "id": "str",
    "*props": "any"
  }
}

##
# @object-del:
#
# Remove a QOM object.
#
# @id: the name of the QOM object to remove
#
# Returns: Nothing on success
#          Error if @id is not a valid id for a QOM object
#
# Since: 2.0
#
# Example:
#
# -> { "execute": "object-del", "arguments": { "id": "rng1" } }
# <- { "return": {} }
#
##
{
  "command": "object-del",
  "data": {
    "id": "str"
  }
}

##
# @getfd:
#
# Receive a file descriptor via SCM rights and assign it a name
#
# @fdname: file descriptor name
#
# Returns: Nothing on success
#
# Since: 0.14.0
#
# Notes: If @fdname already exists, the file descriptor assigned to
#        it will be closed and replaced by the received file
#        descriptor.
#
#        The 'closefd' command can be used to explicitly close the
#        file descriptor when it is no longer needed.
#
# Example:
#
# -> { "execute": "getfd", "arguments": { "fdname": "fd1" } }
# <- { "return": {} }
#
##
{
  "command": "getfd",
  "data": {
    "fdname": "str"
  }
}

##
# @closefd:
#
# Close a file descriptor previously passed via SCM rights
#
# @fdname: file descriptor name
#
# Returns: Nothing on success
#
# Since: 0.14.0
#
# Example:
#
# -> { "execute": "closefd", "arguments": { "fdname": "fd1" } }
# <- { "return": {} }
#
##
{
  "command": "closefd",
  "data": {
    "fdname": "str"
  }
}

##
# @MachineInfo:
#
# Information describing a machine.
#
# @name: the name of the machine
#
# @alias: an alias for the machine name
#
# @is-default: whether the machine is default
#
# @cpu-max: maximum number of CPUs supported by the machine type
#           (since 1.5.0)
#
# @hotpluggable-cpus: cpu hotplug via -device is supported (since 2.7.0)
#
# Since: 1.2.0
##
{
  "struct": "MachineInfo",
  "data": {
    "name": "str",
    "*alias": "str",
    "*is-default": "bool",
    "cpu-max": "int",
    "hotpluggable-cpus": "bool"
  }
}

##
# @query-machines:
#
# Return a list of supported machines
#
# Returns: a list of MachineInfo
#
# Since: 1.2.0
##
{
  "command": "query-machines",
  "returns": [
    "MachineInfo"
  ]
}

##
# @CpuDefinitionInfo:
#
# Virtual CPU definition.
#
# @name: the name of the CPU definition
#
# @migration-safe: whether a CPU definition can be safely used for
#                  migration in combination with a QEMU compatibility machine
#                  when migrating between different QMU versions and between
#                  hosts with different sets of (hardware or software)
#                  capabilities. If not provided, information is not available
#                  and callers should not assume the CPU definition to be
#                  migration-safe. (since 2.8)
#
# @static: whether a CPU definition is static and will not change depending on
#          QEMU version, machine type, machine options and accelerator options.
#          A static model is always migration-safe. (since 2.8)
#
# @unavailable-features: List of properties that prevent
#                        the CPU model from running in the current
#                        host. (since 2.8)
# @typename: Type name that can be used as argument to @device-list-properties,
#            to introspect properties configurable using -cpu or -global.
#            (since 2.9)
#
# @unavailable-features is a list of QOM property names that
# represent CPU model attributes that prevent the CPU from running.
# If the QOM property is read-only, that means there's no known
# way to make the CPU model run in the current host. Implementations
# that choose not to provide specific information return the
# property name "type".
# If the property is read-write, it means that it MAY be possible
# to run the CPU model in the current host if that property is
# changed. Management software can use it as hints to suggest or
# choose an alternative for the user, or just to generate meaningful
# error messages explaining why the CPU model can't be used.
# If @unavailable-features is an empty list, the CPU model is
# runnable using the current host and machine-type.
# If @unavailable-features is not present, runnability
# information for the CPU is not available.
#
# Since: 1.2.0
##
{
  "struct": "CpuDefinitionInfo",
  "data": {
    "name": "str",
    "*migration-safe": "bool",
    "static": "bool",
    "*unavailable-features": [
      "str"
    ],
    "typename": "str"
  }
}

##
# @MemoryInfo:
#
# Actual memory information in bytes.
#
# @base-memory: size of "base" memory specified with command line
#               option -m.
#
# @plugged-memory: size of memory that can be hot-unplugged. This field
#                  is omitted if target doesn't support memory hotplug
#                  (i.e. CONFIG_MEM_HOTPLUG not defined on build time).
#
# Since: 2.11.0
##
{
  "struct": "MemoryInfo",
  "data": {
    "base-memory": "size",
    "*plugged-memory": "size"
  }
}

##
# @query-memory-size-summary:
#
# Return the amount of initially allocated and present hotpluggable (if
# enabled) memory in bytes.
#
# Example:
#
# -> { "execute": "query-memory-size-summary" }
# <- { "return": { "base-memory": 4294967296, "plugged-memory": 0 } }
#
# Since: 2.11.0
##
{
  "command": "query-memory-size-summary",
  "returns": "MemoryInfo"
}

##
# @query-cpu-definitions:
#
# Return a list of supported virtual CPU definitions
#
# Returns: a list of CpuDefInfo
#
# Since: 1.2.0
##
{
  "command": "query-cpu-definitions",
  "returns": [
    "CpuDefinitionInfo"
  ]
}

##
# @CpuModelInfo:
#
# Virtual CPU model.
#
# A CPU model consists of the name of a CPU definition, to which
# delta changes are applied (e.g. features added/removed). Most magic values
# that an architecture might require should be hidden behind the name.
# However, if required, architectures can expose relevant properties.
#
# @name: the name of the CPU definition the model is based on
# @props: a dictionary of QOM properties to be applied
#
# Since: 2.8.0
##
{
  "struct": "CpuModelInfo",
  "data": {
    "name": "str",
    "*props": "any"
  }
}

##
# @CpuModelExpansionType:
#
# An enumeration of CPU model expansion types.
#
# @static: Expand to a static CPU model, a combination of a static base
#          model name and property delta changes. As the static base model will
#          never change, the expanded CPU model will be the same, independant of
#          independent of QEMU version, machine type, machine options, and
#          accelerator options. Therefore, the resulting model can be used by
#          tooling without having to specify a compatibility machine - e.g. when
#          displaying the "host" model. static CPU models are migration-safe.
#
# @full: Expand all properties. The produced model is not guaranteed to be
#        migration-safe, but allows tooling to get an insight and work with
#        model details.
#
# Note: When a non-migration-safe CPU model is expanded in static mode, some
# features enabled by the CPU model may be omitted, because they can't be
# implemented by a static CPU model definition (e.g. cache info passthrough and
# PMU passthrough in x86). If you need an accurate representation of the
# features enabled by a non-migration-safe CPU model, use @full. If you need a
# static representation that will keep ABI compatibility even when changing QEMU
# version or machine-type, use @static (but keep in mind that some features may
# be omitted).
#
# Since: 2.8.0
##
{
  "enum": "CpuModelExpansionType",
  "data": [
    "static",
    "full"
  ]
}


##
# @CpuModelExpansionInfo:
#
# The result of a cpu model expansion.
#
# @model: the expanded CpuModelInfo.
#
# Since: 2.8.0
##
{
  "struct": "CpuModelExpansionInfo",
  "data": {
    "model": "CpuModelInfo"
  }
}


##
# @query-cpu-model-expansion:
#
# Expands a given CPU model (or a combination of CPU model + additional options)
# to different granularities, allowing tooling to get an understanding what a
# specific CPU model looks like in QEMU under a certain configuration.
#
# This interface can be used to query the "host" CPU model.
#
# The data returned by this command may be affected by:
#
# * QEMU version: CPU models may look different depending on the QEMU version.
#   (Except for CPU models reported as "static" in query-cpu-definitions.)
# * machine-type: CPU model  may look different depending on the machine-type.
#   (Except for CPU models reported as "static" in query-cpu-definitions.)
# * machine options (including accelerator): in some architectures, CPU models
#   may look different depending on machine and accelerator options. (Except for
#   CPU models reported as "static" in query-cpu-definitions.)
# * "-cpu" arguments and global properties: arguments to the -cpu option and
#   global properties may affect expansion of CPU models. Using
#   query-cpu-model-expansion while using these is not advised.
#
# Some architectures may not support all expansion types. s390x supports
# "full" and "static".
#
# Returns: a CpuModelExpansionInfo. Returns an error if expanding CPU models is
#          not supported, if the model cannot be expanded, if the model contains
#          an unknown CPU definition name, unknown properties or properties
#          with a wrong type. Also returns an error if an expansion type is
#          not supported.
#
# Since: 2.8.0
##
{
  "command": "query-cpu-model-expansion",
  "data": {
    "type": "CpuModelExpansionType",
    "model": "CpuModelInfo"
  },
  "returns": "CpuModelExpansionInfo"
}

##
# @CpuModelCompareResult:
#
# An enumeration of CPU model comparation results. The result is usually
# calculated using e.g. CPU features or CPU generations.
#
# @incompatible: If model A is incompatible to model B, model A is not
#                guaranteed to run where model B runs and the other way around.
#
# @identical: If model A is identical to model B, model A is guaranteed to run
#             where model B runs and the other way around.
#
# @superset: If model A is a superset of model B, model B is guaranteed to run
#            where model A runs. There are no guarantees about the other way.
#
# @subset: If model A is a subset of model B, model A is guaranteed to run
#          where model B runs. There are no guarantees about the other way.
#
# Since: 2.8.0
##
{
  "enum": "CpuModelCompareResult",
  "data": [
    "incompatible",
    "identical",
    "superset",
    "subset"
  ]
}

##
# @CpuModelCompareInfo:
#
# The result of a CPU model comparison.
#
# @result: The result of the compare operation.
# @responsible-properties: List of properties that led to the comparison result
#                          not being identical.
#
# @responsible-properties is a list of QOM property names that led to
# both CPUs not being detected as identical. For identical models, this
# list is empty.
# If a QOM property is read-only, that means there's no known way to make the
# CPU models identical. If the special property name "type" is included, the
# models are by definition not identical and cannot be made identical.
#
# Since: 2.8.0
##
{
  "struct": "CpuModelCompareInfo",
  "data": {
    "result": "CpuModelCompareResult",
    "responsible-properties": [
      "str"
    ]
  }
}

##
# @query-cpu-model-comparison:
#
# Compares two CPU models, returning how they compare in a specific
# configuration. The results indicates how both models compare regarding
# runnability. This result can be used by tooling to make decisions if a
# certain CPU model will run in a certain configuration or if a compatible
# CPU model has to be created by baselining.
#
# Usually, a CPU model is compared against the maximum possible CPU model
# of a certain configuration (e.g. the "host" model for KVM). If that CPU
# model is identical or a subset, it will run in that configuration.
#
# The result returned by this command may be affected by:
#
# * QEMU version: CPU models may look different depending on the QEMU version.
#   (Except for CPU models reported as "static" in query-cpu-definitions.)
# * machine-type: CPU model may look different depending on the machine-type.
#   (Except for CPU models reported as "static" in query-cpu-definitions.)
# * machine options (including accelerator): in some architectures, CPU models
#   may look different depending on machine and accelerator options. (Except for
#   CPU models reported as "static" in query-cpu-definitions.)
# * "-cpu" arguments and global properties: arguments to the -cpu option and
#   global properties may affect expansion of CPU models. Using
#   query-cpu-model-expansion while using these is not advised.
#
# Some architectures may not support comparing CPU models. s390x supports
# comparing CPU models.
#
# Returns: a CpuModelBaselineInfo. Returns an error if comparing CPU models is
#          not supported, if a model cannot be used, if a model contains
#          an unknown cpu definition name, unknown properties or properties
#          with wrong types.
#
# Since: 2.8.0
##
{
  "command": "query-cpu-model-comparison",
  "data": {
    "modela": "CpuModelInfo",
    "modelb": "CpuModelInfo"
  },
  "returns": "CpuModelCompareInfo"
}

##
# @CpuModelBaselineInfo:
#
# The result of a CPU model baseline.
#
# @model: the baselined CpuModelInfo.
#
# Since: 2.8.0
##
{
  "struct": "CpuModelBaselineInfo",
  "data": {
    "model": "CpuModelInfo"
  }
}

##
# @query-cpu-model-baseline:
#
# Baseline two CPU models, creating a compatible third model. The created
# model will always be a static, migration-safe CPU model (see "static"
# CPU model expansion for details).
#
# This interface can be used by tooling to create a compatible CPU model out
# two CPU models. The created CPU model will be identical to or a subset of
# both CPU models when comparing them. Therefore, the created CPU model is
# guaranteed to run where the given CPU models run.
#
# The result returned by this command may be affected by:
#
# * QEMU version: CPU models may look different depending on the QEMU version.
#   (Except for CPU models reported as "static" in query-cpu-definitions.)
# * machine-type: CPU model may look different depending on the machine-type.
#   (Except for CPU models reported as "static" in query-cpu-definitions.)
# * machine options (including accelerator): in some architectures, CPU models
#   may look different depending on machine and accelerator options. (Except for
#   CPU models reported as "static" in query-cpu-definitions.)
# * "-cpu" arguments and global properties: arguments to the -cpu option and
#   global properties may affect expansion of CPU models. Using
#   query-cpu-model-expansion while using these is not advised.
#
# Some architectures may not support baselining CPU models. s390x supports
# baselining CPU models.
#
# Returns: a CpuModelBaselineInfo. Returns an error if baselining CPU models is
#          not supported, if a model cannot be used, if a model contains
#          an unknown cpu definition name, unknown properties or properties
#          with wrong types.
#
# Since: 2.8.0
##
{
  "command": "query-cpu-model-baseline",
  "data": {
    "modela": "CpuModelInfo",
    "modelb": "CpuModelInfo"
  },
  "returns": "CpuModelBaselineInfo"
}

##
# @AddfdInfo:
#
# Information about a file descriptor that was added to an fd set.
#
# @fdset-id: The ID of the fd set that @fd was added to.
#
# @fd: The file descriptor that was received via SCM rights and
#      added to the fd set.
#
# Since: 1.2.0
##
{
  "struct": "AddfdInfo",
  "data": {
    "fdset-id": "int",
    "fd": "int"
  }
}

##
# @add-fd:
#
# Add a file descriptor, that was passed via SCM rights, to an fd set.
#
# @fdset-id: The ID of the fd set to add the file descriptor to.
#
# @opaque: A free-form string that can be used to describe the fd.
#
# Returns: @AddfdInfo on success
#
#          If file descriptor was not received, FdNotSupplied
#
#          If @fdset-id is a negative value, InvalidParameterValue
#
# Notes: The list of fd sets is shared by all monitor connections.
#
#        If @fdset-id is not specified, a new fd set will be created.
#
# Since: 1.2.0
#
# Example:
#
# -> { "execute": "add-fd", "arguments": { "fdset-id": 1 } }
# <- { "return": { "fdset-id": 1, "fd": 3 } }
#
##
{
  "command": "add-fd",
  "data": {
    "*fdset-id": "int",
    "*opaque": "str"
  },
  "returns": "AddfdInfo"
}

##
# @remove-fd:
#
# Remove a file descriptor from an fd set.
#
# @fdset-id: The ID of the fd set that the file descriptor belongs to.
#
# @fd: The file descriptor that is to be removed.
#
# Returns: Nothing on success
#          If @fdset-id or @fd is not found, FdNotFound
#
# Since: 1.2.0
#
# Notes: The list of fd sets is shared by all monitor connections.
#
#        If @fd is not specified, all file descriptors in @fdset-id
#        will be removed.
#
# Example:
#
# -> { "execute": "remove-fd", "arguments": { "fdset-id": 1, "fd": 3 } }
# <- { "return": {} }
#
##
{
  "command": "remove-fd",
  "data": {
    "fdset-id": "int",
    "*fd": "int"
  }
}

##
# @FdsetFdInfo:
#
# Information about a file descriptor that belongs to an fd set.
#
# @fd: The file descriptor value.
#
# @opaque: A free-form string that can be used to describe the fd.
#
# Since: 1.2.0
##
{
  "struct": "FdsetFdInfo",
  "data": {
    "fd": "int",
    "*opaque": "str"
  }
}

##
# @FdsetInfo:
#
# Information about an fd set.
#
# @fdset-id: The ID of the fd set.
#
# @fds: A list of file descriptors that belong to this fd set.
#
# Since: 1.2.0
##
{
  "struct": "FdsetInfo",
  "data": {
    "fdset-id": "int",
    "fds": [
      "FdsetFdInfo"
    ]
  }
}

##
# @query-fdsets:
#
# Return information describing all fd sets.
#
# Returns: A list of @FdsetInfo
#
# Since: 1.2.0
#
# Note: The list of fd sets is shared by all monitor connections.
#
# Example:
#
# -> { "execute": "query-fdsets" }
# <- { "return": [
#        {
#          "fds": [
#            {
#              "fd": 30,
#              "opaque": "rdonly:/path/to/file"
#            },
#            {
#              "fd": 24,
#              "opaque": "rdwr:/path/to/file"
#            }
#          ],
#          "fdset-id": 1
#        },
#        {
#          "fds": [
#            {
#              "fd": 28
#            },
#            {
#              "fd": 29
#            }
#          ],
#          "fdset-id": 0
#        }
#      ]
#    }
#
##
{
  "command": "query-fdsets",
  "returns": [
    "FdsetInfo"
  ]
}

##
# @TargetInfo:
#
# Information describing the QEMU target.
#
# @arch: the target architecture (eg "x86_64", "i386", etc)
#
# Since: 1.2.0
##
{
  "struct": "TargetInfo",
  "data": {
    "arch": "str"
  }
}

##
# @query-target:
#
# Return information about the target for this QEMU
#
# Returns: TargetInfo
#
# Since: 1.2.0
##
{
  "command": "query-target",
  "returns": "TargetInfo"
}

##
# @AcpiTableOptions:
#
# Specify an ACPI table on the command line to load.
#
# At most one of @file and @data can be specified. The list of files specified
# by any one of them is loaded and concatenated in order. If both are omitted,
# @data is implied.
#
# Other fields / optargs can be used to override fields of the generic ACPI
# table header; refer to the ACPI specification 5.0, section 5.2.6 System
# Description Table Header. If a header field is not overridden, then the
# corresponding value from the concatenated blob is used (in case of @file), or
# it is filled in with a hard-coded value (in case of @data).
#
# String fields are copied into the matching ACPI member from lowest address
# upwards, and silently truncated / NUL-padded to length.
#
# @sig: table signature / identifier (4 bytes)
#
# @rev: table revision number (dependent on signature, 1 byte)
#
# @oem_id: OEM identifier (6 bytes)
#
# @oem_table_id: OEM table identifier (8 bytes)
#
# @oem_rev: OEM-supplied revision number (4 bytes)
#
# @asl_compiler_id: identifier of the utility that created the table
#                   (4 bytes)
#
# @asl_compiler_rev: revision number of the utility that created the
#                    table (4 bytes)
#
# @file: colon (:) separated list of pathnames to load and
#        concatenate as table data. The resultant binary blob is expected to
#        have an ACPI table header. At least one file is required. This field
#        excludes @data.
#
# @data: colon (:) separated list of pathnames to load and
#        concatenate as table data. The resultant binary blob must not have an
#        ACPI table header. At least one file is required. This field excludes
#        @file.
#
# Since: 1.5
##
{
  "struct": "AcpiTableOptions",
  "data": {
    "*sig": "str",
    "*rev": "uint8",
    "*oem_id": "str",
    "*oem_table_id": "str",
    "*oem_rev": "uint32",
    "*asl_compiler_id": "str",
    "*asl_compiler_rev": "uint32",
    "*file": "str",
    "*data": "str"
  }
}

##
# @CommandLineParameterType:
#
# Possible types for an option parameter.
#
# @string: accepts a character string
#
# @boolean: accepts "on" or "off"
#
# @number: accepts a number
#
# @size: accepts a number followed by an optional suffix (K)ilo,
#        (M)ega, (G)iga, (T)era
#
# Since: 1.5
##
{
  "enum": "CommandLineParameterType",
  "data": [
    "string",
    "boolean",
    "number",
    "size"
  ]
}

##
# @CommandLineParameterInfo:
#
# Details about a single parameter of a command line option.
#
# @name: parameter name
#
# @type: parameter @CommandLineParameterType
#
# @help: human readable text string, not suitable for parsing.
#
# @default: default value string (since 2.1)
#
# Since: 1.5
##
{
  "struct": "CommandLineParameterInfo",
  "data": {
    "name": "str",
    "type": "CommandLineParameterType",
    "*help": "str",
    "*default": "str"
  }
}

##
# @CommandLineOptionInfo:
#
# Details about a command line option, including its list of parameter details
#
# @option: option name
#
# @parameters: an array of @CommandLineParameterInfo
#
# Since: 1.5
##
{
  "struct": "CommandLineOptionInfo",
  "data": {
    "option": "str",
    "parameters": [
      "CommandLineParameterInfo"
    ]
  }
}

##
# @query-command-line-options:
#
# Query command line option schema.
#
# @option: option name
#
# Returns: list of @CommandLineOptionInfo for all options (or for the given
#          @option).  Returns an error if the given @option doesn't exist.
#
# Since: 1.5
#
# Example:
#
# -> { "execute": "query-command-line-options",
#      "arguments": { "option": "option-rom" } }
# <- { "return": [
#         {
#             "parameters": [
#                 {
#                     "name": "romfile",
#                     "type": "string"
#                 },
#                 {
#                     "name": "bootindex",
#                     "type": "number"
#                 }
#             ],
#             "option": "option-rom"
#         }
#      ]
#    }
#
##
{
  "command": "query-command-line-options",
  "data": {
    "*option": "str"
  },
  "returns": [
    "CommandLineOptionInfo"
  ]
}

##
# @X86CPURegister32:
#
# A X86 32-bit register
#
# Since: 1.5
##
{
  "enum": "X86CPURegister32",
  "data": [
    "EAX",
    "EBX",
    "ECX",
    "EDX",
    "ESP",
    "EBP",
    "ESI",
    "EDI"
  ]
}

##
# @X86CPUFeatureWordInfo:
#
# Information about a X86 CPU feature word
#
# @cpuid-input-eax: Input EAX value for CPUID instruction for that feature word
#
# @cpuid-input-ecx: Input ECX value for CPUID instruction for that
#                   feature word
#
# @cpuid-register: Output register containing the feature bits
#
# @features: value of output register, containing the feature bits
#
# Since: 1.5
##
{
  "struct": "X86CPUFeatureWordInfo",
  "data": {
    "cpuid-input-eax": "int",
    "*cpuid-input-ecx": "int",
    "cpuid-register": "X86CPURegister32",
    "features": "int"
  }
}

##
# @DummyForceArrays:
#
# Not used by QMP; hack to let us use X86CPUFeatureWordInfoList internally
#
# Since: 2.5
##
{
  "struct": "DummyForceArrays",
  "data": {
    "unused": [
      "X86CPUFeatureWordInfo"
    ]
  }
}


##
# @NumaOptionsType:
#
# @node: NUMA nodes configuration
#
# @dist: NUMA distance configuration (since 2.10)
#
# @cpu: property based CPU(s) to node mapping (Since: 2.10)
#
# Since: 2.1
##
{
  "enum": "NumaOptionsType",
  "data": [
    "node",
    "dist",
    "cpu"
  ]
}

##
# @NumaOptions:
#
# A discriminated record of NUMA options. (for OptsVisitor)
#
# Since: 2.1
##
{
  "union": "NumaOptions",
  "base": {
    "type": "NumaOptionsType"
  },
  "discriminator": "type",
  "data": {
    "node": "NumaNodeOptions",
    "dist": "NumaDistOptions",
    "cpu": "NumaCpuOptions"
  }
}

##
# @NumaNodeOptions:
#
# Create a guest NUMA node. (for OptsVisitor)
#
# @nodeid: NUMA node ID (increase by 1 from 0 if omitted)
#
# @cpus: VCPUs belonging to this node (assign VCPUS round-robin
#         if omitted)
#
# @mem: memory size of this node; mutually exclusive with @memdev.
#       Equally divide total memory among nodes if both @mem and @memdev are
#       omitted.
#
# @memdev: memory backend object.  If specified for one node,
#          it must be specified for all nodes.
#
# Since: 2.1
##
{
  "struct": "NumaNodeOptions",
  "data": {
    "*nodeid": "uint16",
    "*cpus": [
      "uint16"
    ],
    "*mem": "size",
    "*memdev": "str"
  }
}

##
# @NumaDistOptions:
#
# Set the distance between 2 NUMA nodes.
#
# @src: source NUMA node.
#
# @dst: destination NUMA node.
#
# @val: NUMA distance from source node to destination node.
#       When a node is unreachable from another node, set the distance
#       between them to 255.
#
# Since: 2.10
##
{
  "struct": "NumaDistOptions",
  "data": {
    "src": "uint16",
    "dst": "uint16",
    "val": "uint8"
  }
}

##
# @NumaCpuOptions:
#
# Option "-numa cpu" overrides default cpu to node mapping.
# It accepts the same set of cpu properties as returned by
# query-hotpluggable-cpus[].props, where node-id could be used to
# override default node mapping.
#
# Since: 2.10
##
{
  "struct": "NumaCpuOptions",
  "base": "CpuInstanceProperties",
  "data": {}
}

##
# @HostMemPolicy:
#
# Host memory policy types
#
# @default: restore default policy, remove any nondefault policy
#
# @preferred: set the preferred host nodes for allocation
#
# @bind: a strict policy that restricts memory allocation to the
#        host nodes specified
#
# @interleave: memory allocations are interleaved across the set
#              of host nodes specified
#
# Since: 2.1
##
{
  "enum": "HostMemPolicy",
  "data": [
    "default",
    "preferred",
    "bind",
    "interleave"
  ]
}

##
# @Memdev:
#
# Information about memory backend
#
# @id: backend's ID if backend has 'id' property (since 2.9)
#
# @size: memory backend size
#
# @merge: enables or disables memory merge support
#
# @dump: includes memory backend's memory in a core dump or not
#
# @prealloc: enables or disables memory preallocation
#
# @host-nodes: host nodes for its memory policy
#
# @policy: memory policy of memory backend
#
# Since: 2.1
##
{
  "struct": "Memdev",
  "data": {
    "*id": "str",
    "size": "size",
    "merge": "bool",
    "dump": "bool",
    "prealloc": "bool",
    "host-nodes": [
      "uint16"
    ],
    "policy": "HostMemPolicy"
  }
}

##
# @query-memdev:
#
# Returns information for all memory backends.
#
# Returns: a list of @Memdev.
#
# Since: 2.1
#
# Example:
#
# -> { "execute": "query-memdev" }
# <- { "return": [
#        {
#          "id": "mem1",
#          "size": 536870912,
#          "merge": false,
#          "dump": true,
#          "prealloc": false,
#          "host-nodes": [0, 1],
#          "policy": "bind"
#        },
#        {
#          "size": 536870912,
#          "merge": false,
#          "dump": true,
#          "prealloc": true,
#          "host-nodes": [2, 3],
#          "policy": "preferred"
#        }
#      ]
#    }
#
##
{
  "command": "query-memdev",
  "returns": [
    "Memdev"
  ]
}

##
# @PCDIMMDeviceInfo:
#
# PCDIMMDevice state information
#
# @id: device's ID
#
# @addr: physical address, where device is mapped
#
# @size: size of memory that the device provides
#
# @slot: slot number at which device is plugged in
#
# @node: NUMA node number where device is plugged in
#
# @memdev: memory backend linked with device
#
# @hotplugged: true if device was hotplugged
#
# @hotpluggable: true if device if could be added/removed while machine is running
#
# Since: 2.1
##
{
  "struct": "PCDIMMDeviceInfo",
  "data": {
    "*id": "str",
    "addr": "int",
    "size": "int",
    "slot": "int",
    "node": "int",
    "memdev": "str",
    "hotplugged": "bool",
    "hotpluggable": "bool"
  }
}

##
# @MemoryDeviceInfo:
#
# Union containing information about a memory device
#
# Since: 2.1
##
{
  "union": "MemoryDeviceInfo",
  "data": {
    "dimm": "PCDIMMDeviceInfo"
  }
}

##
# @query-memory-devices:
#
# Lists available memory devices and their state
#
# Since: 2.1
#
# Example:
#
# -> { "execute": "query-memory-devices" }
# <- { "return": [ { "data":
#                       { "addr": 5368709120,
#                         "hotpluggable": true,
#                         "hotplugged": true,
#                         "id": "d1",
#                         "memdev": "/objects/memX",
#                         "node": 0,
#                         "size": 1073741824,
#                         "slot": 0},
#                    "type": "dimm"
#                  } ] }
#
##
{
  "command": "query-memory-devices",
  "returns": [
    "MemoryDeviceInfo"
  ]
}

##
# @MEM_UNPLUG_ERROR:
#
# Emitted when memory hot unplug error occurs.
#
# @device: device name
#
# @msg: Informative message
#
# Since: 2.4
#
# Example:
#
# <- { "event": "MEM_UNPLUG_ERROR"
#      "data": { "device": "dimm1",
#                "msg": "acpi: device unplug for unsupported device"
#      },
#      "timestamp": { "seconds": 1265044230, "microseconds": 450486 } }
#
##
{
  "event": "MEM_UNPLUG_ERROR",
  "data": {
    "device": "str",
    "msg": "str"
  }
}

##
# @ACPISlotType:
#
# @DIMM: memory slot
# @CPU: logical CPU slot (since 2.7)
##
{
  "enum": "ACPISlotType",
  "data": [
    "DIMM",
    "CPU"
  ]
}

##
# @ACPIOSTInfo:
#
# OSPM Status Indication for a device
# For description of possible values of @source and @status fields
# see "_OST (OSPM Status Indication)" chapter of ACPI5.0 spec.
#
# @device: device ID associated with slot
#
# @slot: slot ID, unique per slot of a given @slot-type
#
# @slot-type: type of the slot
#
# @source: an integer containing the source event
#
# @status: an integer containing the status code
#
# Since: 2.1
##
{
  "struct": "ACPIOSTInfo",
  "data": {
    "*device": "str",
    "slot": "str",
    "slot-type": "ACPISlotType",
    "source": "int",
    "status": "int"
  }
}

##
# @query-acpi-ospm-status:
#
# Return a list of ACPIOSTInfo for devices that support status
# reporting via ACPI _OST method.
#
# Since: 2.1
#
# Example:
#
# -> { "execute": "query-acpi-ospm-status" }
# <- { "return": [ { "device": "d1", "slot": "0", "slot-type": "DIMM", "source": 1, "status": 0},
#                  { "slot": "1", "slot-type": "DIMM", "source": 0, "status": 0},
#                  { "slot": "2", "slot-type": "DIMM", "source": 0, "status": 0},
#                  { "slot": "3", "slot-type": "DIMM", "source": 0, "status": 0}
#    ]}
#
##
{
  "command": "query-acpi-ospm-status",
  "returns": [
    "ACPIOSTInfo"
  ]
}

##
# @ACPI_DEVICE_OST:
#
# Emitted when guest executes ACPI _OST method.
#
# @info: ACPIOSTInfo type as described in qapi-schema.json
#
# Since: 2.1
#
# Example:
#
# <- { "event": "ACPI_DEVICE_OST",
#      "data": { "device": "d1", "slot": "0",
#                "slot-type": "DIMM", "source": 1, "status": 0 } }
#
##
{
  "event": "ACPI_DEVICE_OST",
  "data": {
    "info": "ACPIOSTInfo"
  }
}

##
# @rtc-reset-reinjection:
#
# This command will reset the RTC interrupt reinjection backlog.
# Can be used if another mechanism to synchronize guest time
# is in effect, for example QEMU guest agent's guest-set-time
# command.
#
# Since: 2.1
#
# Example:
#
# -> { "execute": "rtc-reset-reinjection" }
# <- { "return": {} }
#
##
{
  "command": "rtc-reset-reinjection"
}

##
# @RTC_CHANGE:
#
# Emitted when the guest changes the RTC time.
#
# @offset: offset between base RTC clock (as specified by -rtc base), and
#          new RTC clock value
#
# Note: This event is rate-limited.
#
# Since: 0.13.0
#
# Example:
#
# <-   { "event": "RTC_CHANGE",
#        "data": { "offset": 78 },
#        "timestamp": { "seconds": 1267020223, "microseconds": 435656 } }
#
##
{
  "event": "RTC_CHANGE",
  "data": {
    "offset": "int"
  }
}

##
# @ReplayMode:
#
# Mode of the replay subsystem.
#
# @none: normal execution mode. Replay or record are not enabled.
#
# @record: record mode. All non-deterministic data is written into the
#          replay log.
#
# @play: replay mode. Non-deterministic data required for system execution
#        is read from the log.
#
# Since: 2.5
##
{
  "enum": "ReplayMode",
  "data": [
    "none",
    "record",
    "play"
  ]
}

##
# @xen-load-devices-state:
#
# Load the state of all devices from file. The RAM and the block devices
# of the VM are not loaded by this command.
#
# @filename: the file to load the state of the devices from as binary
# data. See xen-save-devices-state.txt for a description of the binary
# format.
#
# Since: 2.7
#
# Example:
#
# -> { "execute": "xen-load-devices-state",
#      "arguments": { "filename": "/tmp/resume" } }
# <- { "return": {} }
#
##
{
  "command": "xen-load-devices-state",
  "data": {
    "filename": "str"
  }
}

##
# @GICCapability:
#
# The struct describes capability for a specific GIC (Generic
# Interrupt Controller) version. These bits are not only decided by
# QEMU/KVM software version, but also decided by the hardware that
# the program is running upon.
#
# @version:  version of GIC to be described. Currently, only 2 and 3
#            are supported.
#
# @emulated: whether current QEMU/hardware supports emulated GIC
#            device in user space.
#
# @kernel:   whether current QEMU/hardware supports hardware
#            accelerated GIC device in kernel.
#
# Since: 2.6
##
{
  "struct": "GICCapability",
  "data": {
    "version": "int",
    "emulated": "bool",
    "kernel": "bool"
  }
}

##
# @query-gic-capabilities:
#
# This command is ARM-only. It will return a list of GICCapability
# objects that describe its capability bits.
#
# Returns: a list of GICCapability objects.
#
# Since: 2.6
#
# Example:
#
# -> { "execute": "query-gic-capabilities" }
# <- { "return": [{ "version": 2, "emulated": true, "kernel": false },
#                 { "version": 3, "emulated": false, "kernel": true } ] }
#
##
{
  "command": "query-gic-capabilities",
  "returns": [
    "GICCapability"
  ]
}

##
# @CpuInstanceProperties:
#
# List of properties to be used for hotplugging a CPU instance,
# it should be passed by management with device_add command when
# a CPU is being hotplugged.
#
# @node-id: NUMA node ID the CPU belongs to
# @socket-id: socket number within node/board the CPU belongs to
# @core-id: core number within socket the CPU belongs to
# @thread-id: thread number within core the CPU belongs to
#
# Note: currently there are 4 properties that could be present
# but management should be prepared to pass through other
# properties with device_add command to allow for future
# interface extension. This also requires the filed names to be kept in
# sync with the properties passed to -device/device_add.
#
# Since: 2.7
##
{
  "struct": "CpuInstanceProperties",
  "data": {
    "*node-id": "int",
    "*socket-id": "int",
    "*core-id": "int",
    "*thread-id": "int"
  }
}

##
# @HotpluggableCPU:
#
# @type: CPU object type for usage with device_add command
# @props: list of properties to be used for hotplugging CPU
# @vcpus-count: number of logical VCPU threads @HotpluggableCPU provides
# @qom-path: link to existing CPU object if CPU is present or
#            omitted if CPU is not present.
#
# Since: 2.7
##
{
  "struct": "HotpluggableCPU",
  "data": {
    "type": "str",
    "vcpus-count": "int",
    "props": "CpuInstanceProperties",
    "*qom-path": "str"
  }
}

##
# @query-hotpluggable-cpus:
#
# Returns: a list of HotpluggableCPU objects.
#
# Since: 2.7
#
# Example:
#
# For pseries machine type started with -smp 2,cores=2,maxcpus=4 -cpu POWER8:
#
# -> { "execute": "query-hotpluggable-cpus" }
# <- {"return": [
#      { "props": { "core": 8 }, "type": "POWER8-spapr-cpu-core",
#        "vcpus-count": 1 },
#      { "props": { "core": 0 }, "type": "POWER8-spapr-cpu-core",
#        "vcpus-count": 1, "qom-path": "/machine/unattached/device[0]"}
#    ]}'
#
# For pc machine type started with -smp 1,maxcpus=2:
#
# -> { "execute": "query-hotpluggable-cpus" }
# <- {"return": [
#      {
#         "type": "qemu64-x86_64-cpu", "vcpus-count": 1,
#         "props": {"core-id": 0, "socket-id": 1, "thread-id": 0}
#      },
#      {
#         "qom-path": "/machine/unattached/device[0]",
#         "type": "qemu64-x86_64-cpu", "vcpus-count": 1,
#         "props": {"core-id": 0, "socket-id": 0, "thread-id": 0}
#      }
#    ]}
#
# For s390x-virtio-ccw machine type started with -smp 1,maxcpus=2 -cpu qemu
# (Since: 2.11):
#
# -> { "execute": "query-hotpluggable-cpus" }
# <- {"return": [
#      {
#         "type": "qemu-s390x-cpu", "vcpus-count": 1,
#         "props": { "core-id": 1 }
#      },
#      {
#         "qom-path": "/machine/unattached/device[0]",
#         "type": "qemu-s390x-cpu", "vcpus-count": 1,
#         "props": { "core-id": 0 }
#      }
#    ]}
#
##
{
  "command": "query-hotpluggable-cpus",
  "returns": [
    "HotpluggableCPU"
  ]
}

##
# @GuidInfo:
#
# GUID information.
#
# @guid: the globally unique identifier
#
# Since: 2.9
##
{
  "struct": "GuidInfo",
  "data": {
    "guid": "str"
  }
}

##
# @query-vm-generation-id:
#
# Show Virtual Machine Generation ID
#
# Since 2.9
##
{
  "command": "query-vm-generation-id",
  "returns": "GuidInfo"
}

##
# @watchdog-set-action:
#
# Set watchdog action
#
# Since: 2.11
##
{
  "command": "watchdog-set-action",
  "data": {
    "action": "WatchdogAction"
  }
}


